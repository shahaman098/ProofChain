import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-256EKJAK.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl2) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl2.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl2.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++) x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/js-sha512/src/sha512.js
var require_sha512 = __commonJS({
  "node_modules/js-sha512/src/sha512.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA512_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, bits) {
        return function(message) {
          return new Sha512(bits, true).update(message)[outputType]();
        };
      };
      var createMethod = function(bits) {
        var method = createOutputMethod("hex", bits);
        method.create = function() {
          return new Sha512(bits);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type, bits);
        }
        return method;
      };
      var createHmacOutputMethod = function(outputType, bits) {
        return function(key, message) {
          return new HmacSha512(key, bits, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(bits) {
        var method = createHmacOutputMethod("hex", bits);
        method.create = function(key) {
          return new HmacSha512(key, bits);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type, bits);
        }
        return method;
      };
      function Sha512(bits, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (bits == 384) {
          this.h0h = 3418070365;
          this.h0l = 3238371032;
          this.h1h = 1654270250;
          this.h1l = 914150663;
          this.h2h = 2438529370;
          this.h2l = 812702999;
          this.h3h = 355462360;
          this.h3l = 4144912697;
          this.h4h = 1731405415;
          this.h4l = 4290775857;
          this.h5h = 2394180231;
          this.h5l = 1750603025;
          this.h6h = 3675008525;
          this.h6l = 1694076839;
          this.h7h = 1203062813;
          this.h7l = 3204075428;
        } else if (bits == 256) {
          this.h0h = 573645204;
          this.h0l = 4230739756;
          this.h1h = 2673172387;
          this.h1l = 3360449730;
          this.h2h = 596883563;
          this.h2l = 1867755857;
          this.h3h = 2520282905;
          this.h3l = 1497426621;
          this.h4h = 2519219938;
          this.h4l = 2827943907;
          this.h5h = 3193839141;
          this.h5l = 1401305490;
          this.h6h = 721525244;
          this.h6l = 746961066;
          this.h7h = 246885852;
          this.h7l = 2177182882;
        } else if (bits == 224) {
          this.h0h = 2352822216;
          this.h0l = 424955298;
          this.h1h = 1944164710;
          this.h1l = 2312950998;
          this.h2h = 502970286;
          this.h2l = 855612546;
          this.h3h = 1738396948;
          this.h3l = 1479516111;
          this.h4h = 258812777;
          this.h4l = 2077511080;
          this.h5h = 2011393907;
          this.h5l = 79989058;
          this.h6h = 1067287976;
          this.h6l = 1780299464;
          this.h7h = 286451373;
          this.h7l = 2446758561;
        } else {
          this.h0h = 1779033703;
          this.h0l = 4089235720;
          this.h1h = 3144134277;
          this.h1l = 2227873595;
          this.h2h = 1013904242;
          this.h2l = 4271175723;
          this.h3h = 2773480762;
          this.h3l = 1595750129;
          this.h4h = 1359893119;
          this.h4l = 2917565137;
          this.h5h = 2600822924;
          this.h5l = 725511199;
          this.h6h = 528734635;
          this.h6l = 4215389547;
          this.h7h = 1541459225;
          this.h7l = 327033209;
        }
        this.bits = bits;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
      }
      Sha512.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 128; ++index) {
              blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 128; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 128) {
            this.block = blocks2[32];
            this.start = i - 128;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha512.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[32] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[32];
        if (i >= 112) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[31] = this.bytes << 3;
        this.hash();
      };
      Sha512.prototype.hash = function() {
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
        for (j = 32; j < 160; j += 2) {
          t1h = blocks2[j - 30];
          t1l = blocks2[j - 29];
          s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
          s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
          t1h = blocks2[j - 4];
          t1l = blocks2[j - 3];
          s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
          s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
          t1h = blocks2[j - 32];
          t1l = blocks2[j - 31];
          t2h = blocks2[j - 14];
          t2l = blocks2[j - 13];
          c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
          blocks2[j] = c4 << 16 | c3 & 65535;
          blocks2[j + 1] = c2 << 16 | c1 & 65535;
        }
        var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
        bch = bh & ch;
        bcl = bl & cl;
        for (j = 0; j < 160; j += 8) {
          s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
          s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
          s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
          s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
          abh = ah & bh;
          abl = al & bl;
          majh = abh ^ ah & ch ^ bch;
          majl = abl ^ al & cl ^ bcl;
          chh = eh & fh ^ ~eh & gh;
          chl = el & fl ^ ~el & gl;
          t1h = blocks2[j];
          t1l = blocks2[j + 1];
          t2h = K[j];
          t2l = K[j + 1];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (dl & 65535) + (t1l & 65535);
          c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          hh = c4 << 16 | c3 & 65535;
          hl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          dh = c4 << 16 | c3 & 65535;
          dl = c2 << 16 | c1 & 65535;
          s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
          s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
          s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
          s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
          dah = dh & ah;
          dal = dl & al;
          majh = dah ^ dh & bh ^ abh;
          majl = dal ^ dl & bl ^ abl;
          chh = hh & eh ^ ~hh & fh;
          chl = hl & el ^ ~hl & fl;
          t1h = blocks2[j + 2];
          t1l = blocks2[j + 3];
          t2h = K[j + 2];
          t2l = K[j + 3];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (cl & 65535) + (t1l & 65535);
          c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          gh = c4 << 16 | c3 & 65535;
          gl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ch = c4 << 16 | c3 & 65535;
          cl = c2 << 16 | c1 & 65535;
          s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
          s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
          s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
          s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
          cdh = ch & dh;
          cdl = cl & dl;
          majh = cdh ^ ch & ah ^ dah;
          majl = cdl ^ cl & al ^ dal;
          chh = gh & hh ^ ~gh & eh;
          chl = gl & hl ^ ~gl & el;
          t1h = blocks2[j + 4];
          t1l = blocks2[j + 5];
          t2h = K[j + 4];
          t2l = K[j + 5];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (bl & 65535) + (t1l & 65535);
          c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          fh = c4 << 16 | c3 & 65535;
          fl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          bh = c4 << 16 | c3 & 65535;
          bl = c2 << 16 | c1 & 65535;
          s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
          s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
          s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
          s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
          bch = bh & ch;
          bcl = bl & cl;
          majh = bch ^ bh & dh ^ cdh;
          majl = bcl ^ bl & dl ^ cdl;
          chh = fh & gh ^ ~fh & hh;
          chl = fl & gl ^ ~fl & hl;
          t1h = blocks2[j + 6];
          t1l = blocks2[j + 7];
          t2h = K[j + 6];
          t2l = K[j + 7];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (al & 65535) + (t1l & 65535);
          c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          eh = c4 << 16 | c3 & 65535;
          el = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ah = c4 << 16 | c3 & 65535;
          al = c2 << 16 | c1 & 65535;
        }
        c1 = (h0l & 65535) + (al & 65535);
        c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
        c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
        c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
        this.h0h = c4 << 16 | c3 & 65535;
        this.h0l = c2 << 16 | c1 & 65535;
        c1 = (h1l & 65535) + (bl & 65535);
        c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
        c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
        c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
        this.h1h = c4 << 16 | c3 & 65535;
        this.h1l = c2 << 16 | c1 & 65535;
        c1 = (h2l & 65535) + (cl & 65535);
        c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
        c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
        c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
        this.h2h = c4 << 16 | c3 & 65535;
        this.h2l = c2 << 16 | c1 & 65535;
        c1 = (h3l & 65535) + (dl & 65535);
        c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
        c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
        c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
        this.h3h = c4 << 16 | c3 & 65535;
        this.h3l = c2 << 16 | c1 & 65535;
        c1 = (h4l & 65535) + (el & 65535);
        c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
        c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        this.h4h = c4 << 16 | c3 & 65535;
        this.h4l = c2 << 16 | c1 & 65535;
        c1 = (h5l & 65535) + (fl & 65535);
        c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
        c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        this.h5h = c4 << 16 | c3 & 65535;
        this.h5l = c2 << 16 | c1 & 65535;
        c1 = (h6l & 65535) + (gl & 65535);
        c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
        c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
        this.h6h = c4 << 16 | c3 & 65535;
        this.h6l = c2 << 16 | c1 & 65535;
        c1 = (h7l & 65535) + (hl & 65535);
        c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
        c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
        this.h7h = c4 << 16 | c3 & 65535;
        this.h7l = c2 << 16 | c1 & 65535;
      };
      Sha512.prototype.hex = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var hex = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
        if (bits >= 256) {
          hex += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
        }
        if (bits >= 384) {
          hex += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
        }
        if (bits == 512) {
          hex += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
        }
        return hex;
      };
      Sha512.prototype.toString = Sha512.prototype.hex;
      Sha512.prototype.digest = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var arr = [
          h0h >> 24 & 255,
          h0h >> 16 & 255,
          h0h >> 8 & 255,
          h0h & 255,
          h0l >> 24 & 255,
          h0l >> 16 & 255,
          h0l >> 8 & 255,
          h0l & 255,
          h1h >> 24 & 255,
          h1h >> 16 & 255,
          h1h >> 8 & 255,
          h1h & 255,
          h1l >> 24 & 255,
          h1l >> 16 & 255,
          h1l >> 8 & 255,
          h1l & 255,
          h2h >> 24 & 255,
          h2h >> 16 & 255,
          h2h >> 8 & 255,
          h2h & 255,
          h2l >> 24 & 255,
          h2l >> 16 & 255,
          h2l >> 8 & 255,
          h2l & 255,
          h3h >> 24 & 255,
          h3h >> 16 & 255,
          h3h >> 8 & 255,
          h3h & 255
        ];
        if (bits >= 256) {
          arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
        }
        if (bits >= 384) {
          arr.push(
            h4h >> 24 & 255,
            h4h >> 16 & 255,
            h4h >> 8 & 255,
            h4h & 255,
            h4l >> 24 & 255,
            h4l >> 16 & 255,
            h4l >> 8 & 255,
            h4l & 255,
            h5h >> 24 & 255,
            h5h >> 16 & 255,
            h5h >> 8 & 255,
            h5h & 255,
            h5l >> 24 & 255,
            h5l >> 16 & 255,
            h5l >> 8 & 255,
            h5l & 255
          );
        }
        if (bits == 512) {
          arr.push(
            h6h >> 24 & 255,
            h6h >> 16 & 255,
            h6h >> 8 & 255,
            h6h & 255,
            h6l >> 24 & 255,
            h6l >> 16 & 255,
            h6l >> 8 & 255,
            h6l & 255,
            h7h >> 24 & 255,
            h7h >> 16 & 255,
            h7h >> 8 & 255,
            h7h & 255,
            h7l >> 24 & 255,
            h7l >> 16 & 255,
            h7l >> 8 & 255,
            h7l & 255
          );
        }
        return arr;
      };
      Sha512.prototype.array = Sha512.prototype.digest;
      Sha512.prototype.arrayBuffer = function() {
        this.finalize();
        var bits = this.bits;
        var buffer = new ArrayBuffer(bits / 8);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0h);
        dataView.setUint32(4, this.h0l);
        dataView.setUint32(8, this.h1h);
        dataView.setUint32(12, this.h1l);
        dataView.setUint32(16, this.h2h);
        dataView.setUint32(20, this.h2l);
        dataView.setUint32(24, this.h3h);
        if (bits >= 256) {
          dataView.setUint32(28, this.h3l);
        }
        if (bits >= 384) {
          dataView.setUint32(32, this.h4h);
          dataView.setUint32(36, this.h4l);
          dataView.setUint32(40, this.h5h);
          dataView.setUint32(44, this.h5l);
        }
        if (bits == 512) {
          dataView.setUint32(48, this.h6h);
          dataView.setUint32(52, this.h6l);
          dataView.setUint32(56, this.h7h);
          dataView.setUint32(60, this.h7l);
        }
        return buffer;
      };
      Sha512.prototype.clone = function() {
        var hash = new Sha512(this.bits, false);
        this.copyTo(hash);
        return hash;
      };
      Sha512.prototype.copyTo = function(hash) {
        var i = 0, attrs = [
          "h0h",
          "h0l",
          "h1h",
          "h1l",
          "h2h",
          "h2l",
          "h3h",
          "h3l",
          "h4h",
          "h4l",
          "h5h",
          "h5l",
          "h6h",
          "h6l",
          "h7h",
          "h7l",
          "start",
          "bytes",
          "hBytes",
          "finalized",
          "hashed",
          "lastByteIndex"
        ];
        for (i = 0; i < attrs.length; ++i) {
          hash[attrs[i]] = this[attrs[i]];
        }
        for (i = 0; i < this.blocks.length; ++i) {
          hash.blocks[i] = this.blocks[i];
        }
      };
      function HmacSha512(key, bits, sharedMemory) {
        var notString, type = typeof key;
        if (type !== "string") {
          if (type === "object") {
            if (key === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var length = key.length;
        if (!notString) {
          var bytes = [], length = key.length, index = 0, code;
          for (var i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 128) {
          key = new Sha512(bits, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (var i = 0; i < 128; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha512.call(this, bits, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha512.prototype = new Sha512();
      HmacSha512.prototype.finalize = function() {
        Sha512.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha512.call(this, this.bits, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha512.prototype.finalize.call(this);
        }
      };
      HmacSha512.prototype.clone = function() {
        var hash = new HmacSha512([], this.bits, false);
        this.copyTo(hash);
        hash.inner = this.inner;
        for (var i = 0; i < this.oKeyPad.length; ++i) {
          hash.oKeyPad[i] = this.oKeyPad[i];
        }
        return hash;
      };
      var exports2 = createMethod(512);
      exports2.sha512 = exports2;
      exports2.sha384 = createMethod(384);
      exports2.sha512_256 = createMethod(256);
      exports2.sha512_224 = createMethod(224);
      exports2.sha512.hmac = createHmacMethod(512);
      exports2.sha384.hmac = createHmacMethod(384);
      exports2.sha512_256.hmac = createHmacMethod(256);
      exports2.sha512_224.hmac = createHmacMethod(224);
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.sha512 = exports2.sha512;
        root.sha384 = exports2.sha384;
        root.sha512_256 = exports2.sha512_256;
        root.sha512_224 = exports2.sha512_224;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign2;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne + (id === 2 && e > ne);
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports, module) {
    var BigNumber = require_bignumber();
    var JSON2 = module.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports, module) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports, module) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module.exports.parse = json_parse();
    module.exports.stringify = json_stringify;
  }
});

// node_modules/hi-base32/src/base32.js
var require_base32 = __commonJS({
  "node_modules/hi-base32/src/base32.js"(exports, module) {
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      }
      var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        "A": 0,
        "B": 1,
        "C": 2,
        "D": 3,
        "E": 4,
        "F": 5,
        "G": 6,
        "H": 7,
        "I": 8,
        "J": 9,
        "K": 10,
        "L": 11,
        "M": 12,
        "N": 13,
        "O": 14,
        "P": 15,
        "Q": 16,
        "R": 17,
        "S": 18,
        "T": 19,
        "U": 20,
        "V": 21,
        "W": 22,
        "X": 23,
        "Y": 24,
        "Z": 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err.position = position;
        throw err;
      };
      var toUtf8String = function(bytes) {
        var str = "", length = bytes.length, i = 0, followingChars = 0, b, c;
        while (i < length) {
          b = bytes[i++];
          if (b <= 127) {
            str += String.fromCharCode(b);
            continue;
          } else if (b > 191 && b <= 223) {
            c = b & 31;
            followingChars = 1;
          } else if (b <= 239) {
            c = b & 15;
            followingChars = 2;
          } else if (b <= 247) {
            c = b & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i, str);
          }
          for (var j = 0; j < followingChars; ++j) {
            b = bytes[i++];
            if (b < 128 || b > 191) {
              throwInvalidUtf8(i, str);
            }
            c <<= 6;
            c += b & 63;
          }
          if (c >= 55296 && c <= 57343) {
            throwInvalidUtf8(i, str);
          }
          if (c > 1114111) {
            throwInvalidUtf8(i, str);
          }
          if (c <= 65535) {
            str += String.fromCharCode(c);
          } else {
            c -= 65536;
            str += String.fromCharCode((c >> 10) + 55296);
            str += String.fromCharCode((c & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;
        for (var i = 0, count = length >> 3 << 3; i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          bytes[index++] = (v7 << 5 | v8) & 255;
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
        }
        return bytes;
      };
      var encodeAscii = function(str) {
        var v1, v2, v3, v4, v5, base32Str = "", length = str.length;
        for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v4 = str.charCodeAt(i++);
          v5 = str.charCodeAt(i++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v4 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v3, v4, v5, code, end = false, base32Str = "", index = 0, i, start = 0, bytes = 0, length = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks[0] = blocks[5];
          blocks[1] = blocks[6];
          blocks[2] = blocks[7];
          for (i = start; index < length && i < 5; ++index) {
            code = str.charCodeAt(index);
            if (code < 128) {
              blocks[i++] = code;
            } else if (code < 2048) {
              blocks[i++] = 192 | code >> 6;
              blocks[i++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              blocks[i++] = 224 | code >> 12;
              blocks[i++] = 128 | code >> 6 & 63;
              blocks[i++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++index) & 1023);
              blocks[i++] = 240 | code >> 18;
              blocks[i++] = 128 | code >> 12 & 63;
              blocks[i++] = 128 | code >> 6 & 63;
              blocks[i++] = 128 | code & 63;
            }
          }
          bytes += i - start;
          start = i - 5;
          if (index === length) {
            ++index;
          }
          if (index > length && i < 6) {
            end = true;
          }
          v1 = blocks[0];
          if (i > 4) {
            v2 = blocks[1];
            v3 = blocks[2];
            v4 = blocks[3];
            v5 = blocks[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          } else if (i === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i === 2) {
            v2 = blocks[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i === 3) {
            v2 = blocks[1];
            v3 = blocks[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else {
            v2 = blocks[1];
            v3 = blocks[2];
            v4 = blocks[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes = function(bytes) {
        var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length;
        for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          v4 = bytes[i++];
          v5 = bytes[i++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes[i++];
          v2 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          v4 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode2 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode3 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
        if (length === -1) {
          length = base32Str.length;
        }
        for (var i = 0, count = length >> 3 << 3; i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports2 = {
        encode: encode2,
        decode: decode3
      };
      decode3.asBytes = decodeAsBytes;
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.base32 = exports2;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/algosdk/dist/esm/main.js
var main_exports = {};
__export(main_exports, {
  ABIAddressType: () => ABIAddressType,
  ABIArrayDynamicType: () => ABIArrayDynamicType,
  ABIArrayStaticType: () => ABIArrayStaticType,
  ABIBoolType: () => ABIBoolType,
  ABIByteType: () => ABIByteType,
  ABIContract: () => ABIContract,
  ABIInterface: () => ABIInterface,
  ABIMethod: () => ABIMethod,
  ABIReferenceType: () => ABIReferenceType,
  ABIStringType: () => ABIStringType,
  ABITransactionType: () => ABITransactionType,
  ABITupleType: () => ABITupleType,
  ABIType: () => ABIType,
  ABIUfixedType: () => ABIUfixedType,
  ABIUintType: () => ABIUintType,
  ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
  ALGORAND_ZERO_ADDRESS_STRING: () => ALGORAND_ZERO_ADDRESS_STRING,
  AccountBaseData: () => AccountBaseData,
  AccountData: () => AccountData,
  AccountDeltas: () => AccountDeltas,
  AccountTotals: () => AccountTotals,
  Address: () => Address,
  AlgoCount: () => AlgoCount,
  Algodv2: () => AlgodClient,
  AppLocalState: () => AppLocalState,
  AppLocalStateDelta: () => AppLocalStateDelta,
  AppParams: () => AppParams,
  AppParamsDelta: () => AppParamsDelta,
  AppResourceRecord: () => AppResourceRecord,
  ApplyData: () => ApplyData,
  AssetHolding: () => AssetHolding,
  AssetHoldingDelta: () => AssetHoldingDelta,
  AssetParams: () => AssetParams,
  AssetParamsDelta: () => AssetParamsDelta,
  AssetResourceRecord: () => AssetResourceRecord,
  AtomicTransactionComposer: () => AtomicTransactionComposer,
  AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
  BalanceRecord: () => BalanceRecord,
  Block: () => Block,
  BlockHeader: () => BlockHeader,
  ENCODED_MULTISIG_SCHEMA: () => ENCODED_MULTISIG_SCHEMA,
  ENCODED_SUBSIG_SCHEMA: () => ENCODED_SUBSIG_SCHEMA,
  ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
  EvalDelta: () => EvalDelta,
  FalconSignatureStruct: () => FalconSignatureStruct,
  FalconVerifier: () => FalconVerifier,
  HashFactory: () => HashFactory,
  INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
  IncludedTransactions: () => IncludedTransactions,
  Indexer: () => IndexerClient,
  IntDecoding: () => intDecoding_default,
  Kmd: () => KmdClient,
  KvValueDelta: () => KvValueDelta,
  LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
  LedgerStateDelta: () => LedgerStateDelta,
  LogicSig: () => LogicSig,
  LogicSigAccount: () => LogicSigAccount,
  MAX_LEN: () => MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
  MerkleArrayProof: () => MerkleArrayProof,
  MerkleSignatureVerifier: () => MerkleSignatureVerifier,
  ModifiedCreatable: () => ModifiedCreatable,
  OnApplicationComplete: () => OnApplicationComplete,
  Participant: () => Participant,
  ParticipationUpdates: () => ParticipationUpdates,
  ProgramSourceMap: () => ProgramSourceMap,
  Reveal: () => Reveal,
  RewardState: () => RewardState,
  SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
  SignedTransaction: () => SignedTransaction,
  SignedTxnInBlock: () => SignedTxnInBlock,
  SignedTxnWithAD: () => SignedTxnWithAD,
  SigslotCommit: () => SigslotCommit,
  StateProof: () => StateProof,
  StateProofMessage: () => StateProofMessage,
  StateProofTrackingData: () => StateProofTrackingData,
  StateSchema: () => StateSchema,
  TealValue: () => TealValue,
  Transaction: () => Transaction,
  TransactionType: () => TransactionType,
  TxnCommitments: () => TxnCommitments,
  UntypedValue: () => UntypedValue,
  UpgradeState: () => UpgradeState,
  UpgradeVote: () => UpgradeVote,
  ValueDelta: () => ValueDelta,
  VotingData: () => VotingData,
  abiCheckTransactionType: () => abiCheckTransactionType,
  abiTypeIsReference: () => abiTypeIsReference,
  abiTypeIsTransaction: () => abiTypeIsTransaction,
  algosToMicroalgos: () => algosToMicroalgos,
  appendSignMultisigTransaction: () => appendSignMultisigTransaction,
  appendSignRawMultisigSignature: () => appendSignRawMultisigSignature,
  assignGroupID: () => assignGroupID,
  base64ToBytes: () => base64ToBytes,
  bigIntToBytes: () => bigIntToBytes,
  bytesToBase64: () => bytesToBase64,
  bytesToBigInt: () => bytesToBigInt,
  bytesToHex: () => bytesToHex,
  bytesToString: () => bytesToString,
  coerceToBytes: () => coerceToBytes,
  computeGroupID: () => computeGroupID,
  createDryrun: () => createDryrun,
  createMultisigTransaction: () => createMultisigTransaction,
  decodeAddress: () => decodeAddress,
  decodeJSON: () => decodeJSON,
  decodeMsgpack: () => decodeMsgpack,
  decodeObj: () => decodeObj,
  decodeSignedTransaction: () => decodeSignedTransaction,
  decodeUint64: () => decodeUint64,
  decodeUnsignedTransaction: () => decodeUnsignedTransaction,
  dryrunTxnResultAppTrace: () => dryrunTxnResultAppTrace,
  dryrunTxnResultLogicSigTrace: () => dryrunTxnResultLogicSigTrace,
  encodeAddress: () => encodeAddress,
  encodeJSON: () => encodeJSON,
  encodeMsgpack: () => encodeMsgpack,
  encodeObj: () => encodeObj,
  encodeUint64: () => encodeUint64,
  encodeUnsignedSimulateTransaction: () => encodeUnsignedSimulateTransaction,
  encodeUnsignedTransaction: () => encodeUnsignedTransaction,
  encodedMultiSigFromEncodingData: () => encodedMultiSigFromEncodingData,
  encodedMultiSigToEncodingData: () => encodedMultiSigToEncodingData,
  encodedSubsigFromEncodingData: () => encodedSubsigFromEncodingData,
  encodedSubsigToEncodingData: () => encodedSubsigToEncodingData,
  generateAccount: () => generateAccount,
  getApplicationAddress: () => getApplicationAddress,
  getMethodByName: () => getMethodByName,
  hexToBytes: () => hexToBytes,
  indexerModels: () => types_exports2,
  isOnApplicationComplete: () => isOnApplicationComplete,
  isTransactionType: () => isTransactionType,
  isTransactionWithSigner: () => isTransactionWithSigner,
  isValidAddress: () => isValidAddress,
  logicSigFromByte: () => logicSigFromByte,
  makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBaseAssetConfigTxn: () => makeBaseAssetConfigTxn,
  makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
  makeEmptyTransactionSigner: () => makeEmptyTransactionSigner,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
  makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
  mergeMultisigTransactions: () => mergeMultisigTransactions,
  microalgosToAlgos: () => microalgosToAlgos,
  mnemonicFromSeed: () => mnemonicFromSeed,
  mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
  mnemonicToSecretKey: () => mnemonicToSecretKey,
  modelsv2: () => types_exports,
  msgpackRawDecode: () => msgpackRawDecode,
  msgpackRawDecodeAsMap: () => msgpackRawDecodeAsMap,
  msgpackRawEncode: () => msgpackRawEncode,
  multisigAddress: () => multisigAddress,
  parseJSON: () => parseJSON,
  secretKeyToMnemonic: () => secretKeyToMnemonic,
  seedFromMnemonic: () => seedFromMnemonic,
  signBytes: () => signBytes,
  signLogicSigTransaction: () => signLogicSigTransaction,
  signLogicSigTransactionObject: () => signLogicSigTransactionObject,
  signMultisigTransaction: () => signMultisigTransaction,
  signTransaction: () => signTransaction,
  stringifyJSON: () => stringifyJSON,
  tealSign: () => tealSign,
  tealSignFromProgram: () => tealSignFromProgram,
  verifyBytes: () => verifyBytes,
  verifyMultisig: () => verifyMultisig,
  verifyTealSign: () => verifyTealSign,
  waitForConfirmation: () => waitForConfirmation
});

// node_modules/algosdk/dist/esm/nacl/naclWrappers.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var import_js_sha512 = __toESM(require_sha512(), 1);

// node_modules/algosdk/dist/esm/utils/utils.js
var import_json_bigint = __toESM(require_json_bigint(), 1);

// node_modules/algosdk/dist/esm/types/intDecoding.js
var IntDecoding;
(function(IntDecoding2) {
  IntDecoding2["UNSAFE"] = "unsafe";
  IntDecoding2["SAFE"] = "safe";
  IntDecoding2["MIXED"] = "mixed";
  IntDecoding2["BIGINT"] = "bigint";
})(IntDecoding || (IntDecoding = {}));
var intDecoding_default = IntDecoding;

// node_modules/algosdk/dist/esm/utils/utils.js
var JSONbig = (0, import_json_bigint.default)({
  useNativeBigInt: true,
  strict: true
});
function parseJSON(str, { intDecoding }) {
  if (intDecoding !== intDecoding_default.SAFE && intDecoding !== intDecoding_default.UNSAFE && intDecoding !== intDecoding_default.BIGINT && intDecoding !== intDecoding_default.MIXED) {
    throw new Error(`Invalid intDecoding option: ${intDecoding}`);
  }
  return JSONbig.parse(str, (_, value) => {
    if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
      Object.setPrototypeOf(value, Object.prototype);
    }
    if (typeof value === "bigint") {
      if (intDecoding === intDecoding_default.SAFE && value > Number.MAX_SAFE_INTEGER) {
        throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
      }
      if (intDecoding === intDecoding_default.BIGINT || intDecoding === intDecoding_default.MIXED && value > Number.MAX_SAFE_INTEGER) {
        return value;
      }
      return Number(value);
    }
    if (typeof value === "number") {
      if (intDecoding === intDecoding_default.BIGINT && Number.isInteger(value)) {
        return BigInt(value);
      }
    }
    return value;
  });
}
function stringifyJSON(value, replacer, space) {
  return JSONbig.stringify(value, replacer, space);
}
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  return Array.from(a).every((val, i) => val === b[i]);
}
function concatArrays(...arrs) {
  const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c = new Uint8Array(size);
  let offset = 0;
  for (let i = 0; i < arrs.length; i++) {
    c.set(arrs[i], offset);
    offset += arrs[i].length;
  }
  return c;
}
function isNode() {
  return (
    // @ts-ignore
    typeof process === "object" && // @ts-ignore
    typeof process.versions === "object" && // @ts-ignore
    typeof process.versions.node !== "undefined"
  );
}
function isReactNative() {
  const { navigator } = globalThis;
  if (typeof navigator === "object" && navigator.product === "ReactNative") {
    return true;
  }
  return false;
}
function ensureSafeInteger(value) {
  if (typeof value === "undefined") {
    throw new Error("Value is undefined");
  }
  if (typeof value === "bigint") {
    if (value > BigInt(Number.MAX_SAFE_INTEGER) || value < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new Error(`BigInt value ${value} is not a safe integer`);
    }
    return Number(value);
  }
  if (typeof value === "number") {
    if (Number.isSafeInteger(value)) {
      return value;
    }
    throw new Error(`Value ${value} is not a safe integer`);
  }
  throw new Error(`Unexpected type ${typeof value}, ${value}`);
}
function ensureSafeUnsignedInteger(value) {
  const intValue = ensureSafeInteger(value);
  if (intValue < 0) {
    throw new Error(`Value ${intValue} is negative`);
  }
  return intValue;
}
function ensureBigInt(value) {
  if (typeof value === "undefined") {
    throw new Error("Value is undefined");
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "number") {
    if (!Number.isSafeInteger(value)) {
      throw new Error(`Value ${value} is not a safe integer`);
    }
    return BigInt(value);
  }
  throw new Error(`Unexpected type ${typeof value}, ${value}`);
}
function ensureUint64(value) {
  const bigIntValue = ensureBigInt(value);
  if (bigIntValue < 0 || bigIntValue > BigInt("0xffffffffffffffff")) {
    throw new Error(`Value ${bigIntValue} is not a uint64`);
  }
  return bigIntValue;
}

// node_modules/algosdk/dist/esm/nacl/naclWrappers.js
function genericHash(arr) {
  return import_js_sha512.default.sha512_256.array(arr);
}
function randomBytes(length) {
  if (isReactNative()) {
    console.warn(`It looks like you're running in react-native. In order to perform common crypto operations you will need to polyfill common operations such as crypto.getRandomValues`);
  }
  return import_tweetnacl.default.randomBytes(length);
}
function keyPairFromSeed(seed) {
  return import_tweetnacl.default.sign.keyPair.fromSeed(seed);
}
function keyPair() {
  const seed = randomBytes(import_tweetnacl.default.box.secretKeyLength);
  return keyPairFromSeed(seed);
}
function isValidSignatureLength(len) {
  return len === import_tweetnacl.default.sign.signatureLength;
}
function keyPairFromSecretKey(sk) {
  return import_tweetnacl.default.sign.keyPair.fromSecretKey(sk);
}
function sign(msg, secretKey) {
  return import_tweetnacl.default.sign.detached(msg, secretKey);
}
function bytesEqual(a, b) {
  return import_tweetnacl.default.verify(a, b);
}
function verify(message, signature, verifyKey) {
  return import_tweetnacl.default.sign.detached.verify(message, signature, verifyKey);
}
var PUBLIC_KEY_LENGTH = import_tweetnacl.default.sign.publicKeyLength;
var SECRET_KEY_LENGTH = import_tweetnacl.default.sign.secretKeyLength;
var HASH_BYTES_LENGTH = 32;
var SEED_BTYES_LENGTH = 32;

// node_modules/algosdk/dist/esm/encoding/address.js
var import_hi_base32 = __toESM(require_base32(), 1);

// node_modules/algosdk/dist/esm/encoding/uint64.js
function encodeUint64(num) {
  const isInteger = typeof num === "bigint" || Number.isInteger(num);
  if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
    throw new Error("Input is not a 64-bit unsigned integer");
  }
  const encoding = new Uint8Array(8);
  const view = new DataView(encoding.buffer);
  view.setBigUint64(0, BigInt(num));
  return encoding;
}
function decodeUint64(data, decodingMode = "safe") {
  if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
    throw new Error(`Unknown decodingMode option: ${decodingMode}`);
  }
  if (data.byteLength === 0 || data.byteLength > 8) {
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
  }
  const padding = new Uint8Array(8 - data.byteLength);
  const encoding = concatArrays(padding, data);
  const view = new DataView(encoding.buffer);
  const num = view.getBigUint64(0);
  const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);
  if (decodingMode === "safe") {
    if (isBig) {
      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    }
    return Number(num);
  }
  if (decodingMode === "mixed" && !isBig) {
    return Number(num);
  }
  return num;
}

// node_modules/algosdk/dist/esm/encoding/binarydata.js
function base64ToBytes(base64String) {
  if (isNode()) {
    return new Uint8Array(Buffer.from(base64String, "base64"));
  }
  const binString = atob(base64String);
  return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
function bytesToBase64(byteArray) {
  if (isNode()) {
    return Buffer.from(byteArray).toString("base64");
  }
  const binString = Array.from(byteArray, (x) => String.fromCodePoint(x)).join("");
  return btoa(binString);
}
function bytesToString(byteArray) {
  return new TextDecoder().decode(byteArray);
}
function coerceToBytes(input) {
  if (typeof input === "string") {
    return new TextEncoder().encode(input);
  }
  return input;
}
function bytesToHex(byteArray) {
  if (isNode()) {
    return Buffer.from(byteArray).toString("hex");
  }
  return Array.from(byteArray).map((i) => i.toString(16).padStart(2, "0")).join("");
}
function hexToBytes(hexString) {
  if (isNode()) {
    return Buffer.from(hexString, "hex");
  }
  let hex = hexString;
  if (hexString.length % 2 !== 0) {
    hex = hexString.padStart(1, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length / 2; i++) {
    byteArray[i] = parseInt(hex.slice(2 * i, 2 * i + 2), 16);
  }
  return byteArray;
}

// node_modules/algosdk/dist/esm/encoding/address.js
var ALGORAND_ADDRESS_BYTE_LENGTH = 36;
var ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
var ALGORAND_ADDRESS_LENGTH = 58;
var ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
var MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
var CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
function checksumFromPublicKey(pk) {
  return Uint8Array.from(genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH));
}
var Address = class _Address {
  /**
   * Create a new Address object from its binary form.
   * @param publicKey - The binary form of the address. Must be 32 bytes.
   */
  constructor(publicKey) {
    if (!(publicKey instanceof Uint8Array)) {
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: ${publicKey} is not Uint8Array, type ${typeof publicKey}`);
    }
    if (publicKey.length !== ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: 0x${bytesToHex(publicKey)}, length ${publicKey.length}`);
    this.publicKey = publicKey;
  }
  /**
   * Check if the address is equal to another address.
   */
  equals(other) {
    return other instanceof _Address && arrayEqual(this.publicKey, other.publicKey);
  }
  /**
   * Compute the 4 byte checksum of the address.
   */
  checksum() {
    return checksumFromPublicKey(this.publicKey);
  }
  /**
   * Encode the address into a string form.
   */
  toString() {
    const addr = import_hi_base32.default.encode(concatArrays(this.publicKey, this.checksum()));
    return addr.slice(0, ALGORAND_ADDRESS_LENGTH);
  }
  /**
   * Decode an address from a string.
   * @param address - The address to decode. Must be 58 bytes long.
   * @returns An Address object corresponding to the input string.
   */
  static fromString(address) {
    if (typeof address !== "string")
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected string, got ${typeof address}, ${address}`);
    if (address.length !== ALGORAND_ADDRESS_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected length ${ALGORAND_ADDRESS_LENGTH}, got ${address.length}: ${address}`);
    const decoded = import_hi_base32.default.decode.asBytes(address);
    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected byte length ${ALGORAND_ADDRESS_BYTE_LENGTH}, got ${decoded.length}`);
    const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
    const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
    const checksum = checksumFromPublicKey(pk);
    if (!arrayEqual(checksum, cs))
      throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
    return new _Address(pk);
  }
  /**
   * Get the zero address.
   */
  static zeroAddress() {
    return new _Address(new Uint8Array(ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  }
};
function decodeAddress(address) {
  return Address.fromString(address);
}
function isValidAddress(address) {
  try {
    Address.fromString(address);
  } catch (e) {
    return false;
  }
  return true;
}
function encodeAddress(address) {
  return new Address(address).toString();
}
var APP_ID_PREFIX = new TextEncoder().encode("appID");
function getApplicationAddress(appID) {
  const toBeSigned = concatArrays(APP_ID_PREFIX, encodeUint64(appID));
  const hash = genericHash(toBeSigned);
  return new Address(Uint8Array.from(hash));
}

// node_modules/algosdk/dist/esm/convert.js
var MICROALGOS_TO_ALGOS_RATIO = 1e6;
var INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
function microalgosToAlgos(microalgos) {
  if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
    throw new Error(INVALID_MICROALGOS_ERROR_MSG);
  }
  return microalgos / MICROALGOS_TO_ALGOS_RATIO;
}
function algosToMicroalgos(algos) {
  const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
  return Math.round(microalgos);
}

// node_modules/algosdk/dist/esm/client/urlTokenBaseHTTPClient.js
var URLTokenBaseHTTPError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "URLTokenBaseHTTPError";
    this.response = response;
  }
};
var URLTokenBaseHTTPClient = class _URLTokenBaseHTTPClient {
  constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
    this.defaultHeaders = defaultHeaders;
    const fixedBaseServer = baseServer.endsWith("/") ? baseServer : `${baseServer}/`;
    const baseServerURL = new URL(fixedBaseServer);
    if (typeof port !== "undefined") {
      baseServerURL.port = port.toString();
    }
    if (baseServerURL.protocol.length === 0) {
      throw new Error("Invalid base server URL, protocol must be defined.");
    }
    this.baseURL = baseServerURL;
    this.tokenHeader = tokenHeader;
  }
  /**
   * Compute the URL for a path relative to the instance's address
   * @param relativePath - A path string
   * @param query - An optional key-value object of query parameters to add to the URL. If the
   *   relativePath already has query parameters on it, the additional parameters defined here will
   *   be added to the URL without modifying those (unless a key collision occurs).
   * @returns A URL string
   */
  getURL(relativePath, query) {
    let fixedRelativePath;
    if (relativePath.startsWith("./")) {
      fixedRelativePath = relativePath;
    } else if (relativePath.startsWith("/")) {
      fixedRelativePath = `.${relativePath}`;
    } else {
      fixedRelativePath = `./${relativePath}`;
    }
    const address = new URL(fixedRelativePath, this.baseURL);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        address.searchParams.set(key, value.toString());
      }
    }
    return address.toString();
  }
  static formatFetchResponseHeaders(headers) {
    const headersObj = {};
    headers.forEach((key, value) => {
      headersObj[key] = value;
    });
    return headersObj;
  }
  static async checkHttpError(res) {
    if (res.ok) {
      return;
    }
    let body;
    let bodyErrorMessage;
    try {
      body = new Uint8Array(await res.arrayBuffer());
      const decoded = JSON.parse(new TextDecoder().decode(body));
      if (decoded.message) {
        bodyErrorMessage = decoded.message;
      }
    } catch (_) {
    }
    let message = `Network request error. Received status ${res.status} (${res.statusText})`;
    if (bodyErrorMessage) {
      message += `: ${bodyErrorMessage}`;
    }
    throw new URLTokenBaseHTTPError(message, {
      body: body ?? new Uint8Array(),
      status: res.status,
      headers: _URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    });
  }
  static async formatFetchResponse(res) {
    await this.checkHttpError(res);
    return {
      body: new Uint8Array(await res.arrayBuffer()),
      status: res.status,
      headers: _URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    };
  }
  async get(relativePath, query, requestHeaders, customOptions) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders ?? {}
    };
    const res = await fetch(this.getURL(relativePath, query), {
      headers,
      ...customOptions ?? {}
    });
    return _URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async post(relativePath, data, query, requestHeaders, customOptions) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders ?? {}
    };
    const res = await fetch(this.getURL(relativePath, query), {
      method: "POST",
      body: data,
      headers,
      ...customOptions ?? {}
    });
    return _URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async delete(relativePath, data, query, requestHeaders, customOptions) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders ?? {}
    };
    const res = await fetch(this.getURL(relativePath, query), {
      method: "DELETE",
      body: data,
      headers,
      ...customOptions ?? {}
    });
    return _URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
};

// node_modules/algosdk/dist/esm/client/client.js
var HTTPClientResponse = class {
  constructor(options) {
    this.body = options.body;
    this.text = options.text;
    this.format = options.format;
    this.headers = options.headers;
    this.status = options.status;
    this.ok = options.ok;
  }
  /**
   * Returns the response body as a string, ready to be parsed as JSON.
   */
  getJSONText() {
    if (this.text === void 0) {
      throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
    }
    return this.text;
  }
  /**
   * Parses the response body as JSON with the given options.
   */
  parseBodyAsJSON(jsonOptions) {
    if (this.text === void 0) {
      throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
    }
    return HTTPClient.parseJSON(this.text, this.status, jsonOptions);
  }
};
function removeFalsyOrEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0)
        delete obj[key];
    }
  }
  return obj;
}
function tolowerCaseKeys(o) {
  return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});
}
function getAcceptFormat(query) {
  if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
    switch (query.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  } else
    return "application/json";
}
var HTTPClient = class _HTTPClient {
  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
    if (baseServer !== void 0) {
      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
    } else {
      this.bc = bcOrTokenHeader;
    }
  }
  /**
   * Parse JSON using utils.parseJSON
   *
   * @param text - JSON data
   * @param status - Status of the response (used in case parseJSON fails)
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   */
  static parseJSON(text, status, jsonOptions) {
    try {
      if (!text) {
        return null;
      }
      return parseJSON(text, jsonOptions);
    } catch (err_) {
      const err = err_;
      err.rawResponse = text || null;
      err.statusCode = status;
      throw err;
    }
  }
  /**
   * Serialize the data according to the requestHeaders
   * Assumes that requestHeaders contain a key "content-type"
   * If the content-type is "application/json", data is JSON serialized
   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
   * or an Uint8Array
   * @private
   */
  static serializeData(data, requestHeaders) {
    if (!data) {
      return new Uint8Array(0);
    }
    if (requestHeaders["content-type"] === "application/json") {
      return new TextEncoder().encode(stringifyJSON(data));
    }
    if (typeof data === "string") {
      return new TextEncoder().encode(data);
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  /**
   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
   * Parse the body in
   * Modifies in place res and return the result
   */
  static prepareResponse(res, format) {
    const { body } = res;
    let text;
    if (format !== "application/msgpack") {
      text = body && new TextDecoder().decode(body) || "";
    }
    return new HTTPClientResponse({
      ...res,
      format,
      text,
      ok: Math.trunc(res.status / 100) === 2
    });
  }
  /**
   * Prepare an error with a response
   * (the type of errors BaseHTTPClient are supposed to throw)
   * by adding the status and preparing the internal response
   * @private
   */
  static prepareResponseError(err) {
    if (err.response) {
      err.response = _HTTPClient.prepareResponse(err.response, "application/json");
      err.status = err.response.status;
    }
    return err;
  }
  /**
   * Send a GET request.
   *
   * @param options - The options to use for the request.
   * @param options.relativePath - The path of the request.
   * @param options.query - An object containing the query parameters of the request.
   * @param options.requestHeaders - An object containing additional request headers to use.
   *   or not.
   * @param options.customOptions - An object containing additional options to pass to the
   *   underlying BaseHTTPClient instance.
   * @returns Response object.
   */
  async get({ relativePath, query, requestHeaders, customOptions }) {
    const format = getAcceptFormat(query);
    const fullHeaders = { ...requestHeaders ?? {}, accept: format };
    try {
      const res = await this.bc.get(relativePath, query ? removeFalsyOrEmpty(query) : void 0, fullHeaders, customOptions);
      return _HTTPClient.prepareResponse(res, format);
    } catch (err) {
      throw _HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a POST request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   * @param options - The options to use for the request.
   */
  async post({ relativePath, data, query, requestHeaders, customOptions }) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders ?? {})
    };
    try {
      const res = await this.bc.post(relativePath, _HTTPClient.serializeData(data, fullHeaders), query, fullHeaders, customOptions);
      return _HTTPClient.prepareResponse(res, "application/json");
    } catch (err) {
      throw _HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a DELETE request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   * @param options - The options to use for the request.
   */
  async delete({ relativePath, data, requestHeaders, customOptions }) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders ?? {})
    };
    try {
      const res = await this.bc.delete(relativePath, typeof data !== "undefined" ? _HTTPClient.serializeData(data, fullHeaders) : void 0, void 0, fullHeaders, customOptions);
      return _HTTPClient.prepareResponse(res, "application/json");
    } catch (err) {
      throw _HTTPClient.prepareResponseError(err);
    }
  }
};

// node_modules/algosdk/dist/esm/client/v2/serviceClient.js
function convertTokenStringToTokenHeader(headerIdentifier, token = "") {
  const tokenHeader = {};
  if (token === "") {
    return tokenHeader;
  }
  tokenHeader[headerIdentifier] = token;
  return tokenHeader;
}
function isBaseHTTPClient(tbc) {
  return typeof tbc.get === "function";
}
var ServiceClient = class {
  constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
    if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
      this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
    } else {
      let tokenHeader;
      if (typeof tokenHeaderOrStrOrBaseClient === "string") {
        tokenHeader = convertTokenStringToTokenHeader(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient);
      } else {
        tokenHeader = tokenHeaderOrStrOrBaseClient;
      }
      this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
    }
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/models/types.js
var types_exports = {};
__export(types_exports, {
  Account: () => Account,
  AccountApplicationResponse: () => AccountApplicationResponse,
  AccountAssetHolding: () => AccountAssetHolding,
  AccountAssetResponse: () => AccountAssetResponse,
  AccountAssetsInformationResponse: () => AccountAssetsInformationResponse,
  AccountParticipation: () => AccountParticipation,
  AccountStateDelta: () => AccountStateDelta,
  AppCallLogs: () => AppCallLogs,
  Application: () => Application,
  ApplicationInitialStates: () => ApplicationInitialStates,
  ApplicationKVStorage: () => ApplicationKVStorage,
  ApplicationLocalReference: () => ApplicationLocalReference,
  ApplicationLocalState: () => ApplicationLocalState,
  ApplicationParams: () => ApplicationParams,
  ApplicationStateOperation: () => ApplicationStateOperation,
  ApplicationStateSchema: () => ApplicationStateSchema,
  Asset: () => Asset,
  AssetHolding: () => AssetHolding2,
  AssetHoldingReference: () => AssetHoldingReference,
  AssetParams: () => AssetParams2,
  AvmKeyValue: () => AvmKeyValue,
  AvmValue: () => AvmValue,
  BlockHashResponse: () => BlockHashResponse,
  BlockLogsResponse: () => BlockLogsResponse,
  BlockResponse: () => BlockResponse,
  BlockTxidsResponse: () => BlockTxidsResponse,
  Box: () => Box,
  BoxDescriptor: () => BoxDescriptor,
  BoxReference: () => BoxReference,
  BoxesResponse: () => BoxesResponse,
  BuildVersion: () => BuildVersion,
  CompileResponse: () => CompileResponse,
  DisassembleResponse: () => DisassembleResponse,
  DryrunRequest: () => DryrunRequest,
  DryrunResponse: () => DryrunResponse,
  DryrunSource: () => DryrunSource,
  DryrunState: () => DryrunState,
  DryrunTxnResult: () => DryrunTxnResult,
  ErrorResponse: () => ErrorResponse,
  EvalDelta: () => EvalDelta2,
  EvalDeltaKeyValue: () => EvalDeltaKeyValue,
  Genesis: () => Genesis,
  GenesisAllocation: () => GenesisAllocation,
  GetBlockTimeStampOffsetResponse: () => GetBlockTimeStampOffsetResponse,
  GetSyncRoundResponse: () => GetSyncRoundResponse,
  LedgerStateDeltaForTransactionGroup: () => LedgerStateDeltaForTransactionGroup,
  LightBlockHeaderProof: () => LightBlockHeaderProof,
  NodeStatusResponse: () => NodeStatusResponse,
  PendingTransactionResponse: () => PendingTransactionResponse,
  PendingTransactionsResponse: () => PendingTransactionsResponse,
  PostTransactionsResponse: () => PostTransactionsResponse,
  ScratchChange: () => ScratchChange,
  SimulateInitialStates: () => SimulateInitialStates,
  SimulateRequest: () => SimulateRequest,
  SimulateRequestTransactionGroup: () => SimulateRequestTransactionGroup,
  SimulateResponse: () => SimulateResponse,
  SimulateTraceConfig: () => SimulateTraceConfig,
  SimulateTransactionGroupResult: () => SimulateTransactionGroupResult,
  SimulateTransactionResult: () => SimulateTransactionResult,
  SimulateUnnamedResourcesAccessed: () => SimulateUnnamedResourcesAccessed,
  SimulationEvalOverrides: () => SimulationEvalOverrides,
  SimulationOpcodeTraceUnit: () => SimulationOpcodeTraceUnit,
  SimulationTransactionExecTrace: () => SimulationTransactionExecTrace,
  StateProof: () => StateProof2,
  StateProofMessage: () => StateProofMessage2,
  SupplyResponse: () => SupplyResponse,
  TealKeyValue: () => TealKeyValue,
  TealValue: () => TealValue2,
  TransactionGroupLedgerStateDeltasForRoundResponse: () => TransactionGroupLedgerStateDeltasForRoundResponse,
  TransactionParametersResponse: () => TransactionParametersResponse,
  TransactionProof: () => TransactionProof,
  Version: () => Version
});

// node_modules/algorand-msgpack/dist.es5+esm/utils/utf8.mjs
function utf8Count(str) {
  var strLength = str.length;
  var byteLength = 0;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
  var strLength = str.length;
  var offset = outputOffset;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output[offset++] = value >> 12 & 15 | 224;
        output[offset++] = value >> 6 & 63 | 128;
      } else {
        output[offset++] = value >> 18 & 7 | 240;
        output[offset++] = value >> 12 & 63 | 128;
        output[offset++] = value >> 6 & 63 | 128;
      }
    }
    output[offset++] = value & 63 | 128;
  }
}
var sharedTextEncoder = new TextEncoder();
var TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output, outputOffset);
  } else {
    utf8EncodeJs(str, output, outputOffset);
  }
}
var CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength) {
  var offset = inputOffset;
  var end = offset + byteLength;
  var units = [];
  var result = "";
  while (offset < end) {
    var byte1 = bytes[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      var byte2 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      var byte4 = bytes[offset++] & 63;
      var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode.apply(String, units);
  }
  return result;
}
var sharedTextDecoder = new TextDecoder();
var TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes, inputOffset, byteLength) {
  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength) {
  if (byteLength > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes, inputOffset, byteLength);
  } else {
    return utf8DecodeJs(bytes, inputOffset, byteLength);
  }
}

// node_modules/algorand-msgpack/dist.es5+esm/ExtData.mjs
var ExtData = (
  /** @class */
  /* @__PURE__ */ function() {
    function ExtData2(type, data) {
      this.type = type;
      this.data = data;
    }
    return ExtData2;
  }()
);

// node_modules/algorand-msgpack/dist.es5+esm/DecodeError.mjs
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DecodeError = (
  /** @class */
  function(_super) {
    __extends(DecodeError2, _super);
    function DecodeError2(message) {
      var _this = _super.call(this, message) || this;
      var proto = Object.create(DecodeError2.prototype);
      Object.setPrototypeOf(_this, proto);
      Object.defineProperty(_this, "name", {
        configurable: true,
        enumerable: false,
        value: DecodeError2.name
      });
      return _this;
    }
    return DecodeError2;
  }(Error)
);

// node_modules/algorand-msgpack/dist.es5+esm/utils/int.mjs
var IntMode;
(function(IntMode2) {
  IntMode2[IntMode2["UNSAFE_NUMBER"] = 0] = "UNSAFE_NUMBER";
  IntMode2[IntMode2["SAFE_NUMBER"] = 1] = "SAFE_NUMBER";
  IntMode2[IntMode2["AS_ENCODED"] = 2] = "AS_ENCODED";
  IntMode2[IntMode2["MIXED"] = 3] = "MIXED";
  IntMode2[IntMode2["BIGINT"] = 4] = "BIGINT";
})(IntMode || (IntMode = {}));
var UINT32_MAX = 4294967295;
function setUint64(view, offset, value) {
  var high = value / 4294967296;
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  var high = Math.floor(value / 4294967296);
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset, mode) {
  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {
    var high = view.getInt32(offset);
    var low = view.getUint32(offset + 4);
    if (mode === IntMode.SAFE_NUMBER && (high < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || high === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && low === 0 || high > (Number.MAX_SAFE_INTEGER - low) / 4294967296)) {
      var hexValue = "".concat(high < 0 ? "-" : "", "0x").concat(Math.abs(high).toString(16)).concat(low.toString(16).padStart(8, "0"));
      throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
    }
    return high * 4294967296 + low;
  }
  var value = view.getBigInt64(offset);
  if (mode === IntMode.MIXED && value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  return value;
}
function getUint64(view, offset, mode) {
  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {
    var high = view.getUint32(offset);
    var low = view.getUint32(offset + 4);
    if (mode === IntMode.SAFE_NUMBER && high > (Number.MAX_SAFE_INTEGER - low) / 4294967296) {
      var hexValue = "0x".concat(high.toString(16)).concat(low.toString(16).padStart(8, "0"));
      throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
    }
    return high * 4294967296 + low;
  }
  var value = view.getBigUint64(offset);
  if (mode === IntMode.MIXED && value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  return value;
}
function convertSafeIntegerToMode(value, mode) {
  if (mode === IntMode.BIGINT) {
    return BigInt(value);
  }
  return Number(value);
}

// node_modules/algorand-msgpack/dist.es5+esm/timestamp.mjs
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
function encodeTimeSpecToTimestamp(_a) {
  var sec = _a.sec, nsec = _a.nsec;
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      var rv = new Uint8Array(4);
      var view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      var secHigh = sec / 4294967296;
      var secLow = sec & 4294967295;
      var rv = new Uint8Array(8);
      var view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    var rv = new Uint8Array(12);
    var view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  var msec = date.getTime();
  var sec = Math.floor(msec / 1e3);
  var nsec = (msec - sec * 1e3) * 1e6;
  var nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    var timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      var sec = view.getUint32(0);
      var nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      var nsec30AndSecHigh2 = view.getUint32(0);
      var secLow32 = view.getUint32(4);
      var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      var nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      var sec = getInt64(view, 4, IntMode.UNSAFE_NUMBER);
      var nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
  }
}
function decodeTimestampExtension(data) {
  var timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
  type: EXT_TIMESTAMP,
  encode: encodeTimestampExtension,
  decode: decodeTimestampExtension
};

// node_modules/algorand-msgpack/dist.es5+esm/ExtensionCodec.mjs
var ExtensionCodec = (
  /** @class */
  function() {
    function ExtensionCodec2() {
      this.builtInEncoders = [];
      this.builtInDecoders = [];
      this.encoders = [];
      this.decoders = [];
      this.register(timestampExtension);
    }
    ExtensionCodec2.prototype.register = function(_a) {
      var type = _a.type, encode2 = _a.encode, decode3 = _a.decode;
      if (type >= 0) {
        this.encoders[type] = encode2;
        this.decoders[type] = decode3;
      } else {
        var index = 1 + type;
        this.builtInEncoders[index] = encode2;
        this.builtInDecoders[index] = decode3;
      }
    };
    ExtensionCodec2.prototype.tryToEncode = function(object, context) {
      for (var i = 0; i < this.builtInEncoders.length; i++) {
        var encodeExt = this.builtInEncoders[i];
        if (encodeExt != null) {
          var data = encodeExt(object, context);
          if (data != null) {
            var type = -1 - i;
            return new ExtData(type, data);
          }
        }
      }
      for (var i = 0; i < this.encoders.length; i++) {
        var encodeExt = this.encoders[i];
        if (encodeExt != null) {
          var data = encodeExt(object, context);
          if (data != null) {
            var type = i;
            return new ExtData(type, data);
          }
        }
      }
      if (object instanceof ExtData) {
        return object;
      }
      return null;
    };
    ExtensionCodec2.prototype.decode = function(data, type, context) {
      var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
      if (decodeExt) {
        return decodeExt(data, type, context);
      } else {
        return new ExtData(type, data);
      }
    };
    ExtensionCodec2.defaultCodec = new ExtensionCodec2();
    return ExtensionCodec2;
  }()
);

// node_modules/algorand-msgpack/dist.es5+esm/utils/typedArrays.mjs
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}
function createDataView(buffer) {
  if (buffer instanceof ArrayBuffer) {
    return new DataView(buffer);
  }
  var bufferView = ensureUint8Array(buffer);
  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}
function compareUint8Arrays(a, b) {
  var length = Math.min(a.length, b.length);
  for (var i = 0; i < length; i++) {
    var diff = a[i] - b[i];
    if (diff !== 0) {
      return diff;
    }
  }
  return a.length - b.length;
}
var RawBinaryString = (
  /** @class */
  /* @__PURE__ */ function() {
    function RawBinaryString2(rawBinaryValue) {
      this.rawBinaryValue = rawBinaryValue;
      if (!ArrayBuffer.isView(rawBinaryValue)) {
        throw new TypeError("RawBinaryString: rawBinaryValue must be an ArrayBufferView");
      }
    }
    return RawBinaryString2;
  }()
);

// node_modules/algorand-msgpack/dist.es5+esm/Encoder.mjs
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = (
  /** @class */
  function() {
    function Encoder2(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
      this.context = options === null || options === void 0 ? void 0 : options.context;
      this.forceBigIntToInt64 = (_b = options === null || options === void 0 ? void 0 : options.forceBigIntToInt64) !== null && _b !== void 0 ? _b : false;
      this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;
      this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;
      this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;
      this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;
      this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;
      this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;
      this.pos = 0;
      this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
      this.bytes = new Uint8Array(this.view.buffer);
    }
    Encoder2.prototype.reinitializeState = function() {
      this.pos = 0;
    };
    Encoder2.prototype.encodeSharedRef = function(object) {
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.subarray(0, this.pos);
    };
    Encoder2.prototype.encode = function(object) {
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.slice(0, this.pos);
    };
    Encoder2.prototype.doEncode = function(object, depth) {
      if (depth > this.maxDepth) {
        throw new Error("Too deep objects in depth ".concat(depth));
      }
      if (object == null) {
        this.encodeNil();
      } else if (typeof object === "boolean") {
        this.encodeBoolean(object);
      } else if (typeof object === "number") {
        this.encodeNumber(object);
      } else if (typeof object === "string") {
        this.encodeString(object);
      } else {
        this.encodeObject(object, depth);
      }
    };
    Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
      var requiredSize = this.pos + sizeToWrite;
      if (this.view.byteLength < requiredSize) {
        this.resizeBuffer(requiredSize * 2);
      }
    };
    Encoder2.prototype.resizeBuffer = function(newSize) {
      var newBuffer = new ArrayBuffer(newSize);
      var newBytes = new Uint8Array(newBuffer);
      var newView = new DataView(newBuffer);
      newBytes.set(this.bytes);
      this.view = newView;
      this.bytes = newBytes;
    };
    Encoder2.prototype.encodeNil = function() {
      this.writeU8(192);
    };
    Encoder2.prototype.encodeBoolean = function(object) {
      if (object === false) {
        this.writeU8(194);
      } else {
        this.writeU8(195);
      }
    };
    Encoder2.prototype.encodeNumber = function(object) {
      if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
        if (object >= 0) {
          if (object < 128) {
            this.writeU8(object);
          } else if (object < 256) {
            this.writeU8(204);
            this.writeU8(object);
          } else if (object < 65536) {
            this.writeU8(205);
            this.writeU16(object);
          } else if (object < 4294967296) {
            this.writeU8(206);
            this.writeU32(object);
          } else {
            this.writeU8(207);
            this.writeU64(object);
          }
        } else {
          if (object >= -32) {
            this.writeU8(224 | object + 32);
          } else if (object >= -128) {
            this.writeU8(208);
            this.writeI8(object);
          } else if (object >= -32768) {
            this.writeU8(209);
            this.writeI16(object);
          } else if (object >= -2147483648) {
            this.writeU8(210);
            this.writeI32(object);
          } else {
            this.writeU8(211);
            this.writeI64(object);
          }
        }
      } else {
        this.encodeNumberAsFloat(object);
      }
    };
    Encoder2.prototype.encodeNumberAsFloat = function(object) {
      if (this.forceFloat32) {
        this.writeU8(202);
        this.writeF32(object);
      } else {
        this.writeU8(203);
        this.writeF64(object);
      }
    };
    Encoder2.prototype.encodeBigInt = function(object) {
      if (this.forceBigIntToInt64) {
        this.encodeBigIntAsInt64(object);
      } else if (object >= 0) {
        if (object < 4294967296 || this.forceIntegerToFloat) {
          this.encodeNumber(Number(object));
        } else if (object < BigInt("0x10000000000000000")) {
          this.encodeBigIntAsInt64(object);
        } else {
          throw new Error("Bigint is too large for uint64: ".concat(object));
        }
      } else {
        if (object >= -2147483648 || this.forceIntegerToFloat) {
          this.encodeNumber(Number(object));
        } else if (object >= BigInt(-1) * BigInt("0x8000000000000000")) {
          this.encodeBigIntAsInt64(object);
        } else {
          throw new Error("Bigint is too small for int64: ".concat(object));
        }
      }
    };
    Encoder2.prototype.encodeBigIntAsInt64 = function(object) {
      if (object >= BigInt(0)) {
        this.writeU8(207);
        this.writeBigUint64(object);
      } else {
        this.writeU8(211);
        this.writeBigInt64(object);
      }
    };
    Encoder2.prototype.writeStringHeader = function(byteLength) {
      if (byteLength < 32) {
        this.writeU8(160 + byteLength);
      } else if (byteLength < 256) {
        this.writeU8(217);
        this.writeU8(byteLength);
      } else if (byteLength < 65536) {
        this.writeU8(218);
        this.writeU16(byteLength);
      } else if (byteLength < 4294967296) {
        this.writeU8(219);
        this.writeU32(byteLength);
      } else {
        throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
      }
    };
    Encoder2.prototype.encodeString = function(object) {
      var maxHeaderSize = 1 + 4;
      var byteLength = utf8Count(object);
      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
      this.writeStringHeader(byteLength);
      utf8Encode(object, this.bytes, this.pos);
      this.pos += byteLength;
    };
    Encoder2.prototype.encodeObject = function(object, depth) {
      var ext = this.extensionCodec.tryToEncode(object, this.context);
      if (ext != null) {
        this.encodeExtension(ext);
      } else if (Array.isArray(object)) {
        this.encodeArray(object, depth);
      } else if (ArrayBuffer.isView(object)) {
        this.encodeBinary(object);
      } else if (object instanceof RawBinaryString) {
        this.encodeBinaryAsString(object);
      } else if (typeof object === "bigint") {
        this.encodeBigInt(object);
      } else if (object instanceof Map) {
        this.encodeMap(object, depth);
      } else if (typeof object === "object") {
        this.encodeMapObject(object, depth);
      } else {
        throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
      }
    };
    Encoder2.prototype.encodeBinary = function(object) {
      var size = object.byteLength;
      if (size < 256) {
        this.writeU8(196);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(197);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(198);
        this.writeU32(size);
      } else {
        throw new Error("Too large binary: ".concat(size));
      }
      var bytes = ensureUint8Array(object);
      this.writeU8a(bytes);
    };
    Encoder2.prototype.encodeBinaryAsString = function(binaryString) {
      var object = binaryString.rawBinaryValue;
      this.writeStringHeader(object.byteLength);
      var bytes = ensureUint8Array(object);
      this.writeU8a(bytes);
    };
    Encoder2.prototype.encodeArray = function(object, depth) {
      var size = object.length;
      if (size < 16) {
        this.writeU8(144 + size);
      } else if (size < 65536) {
        this.writeU8(220);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(221);
        this.writeU32(size);
      } else {
        throw new Error("Too large array: ".concat(size));
      }
      for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
        var item = object_1[_i];
        this.doEncode(item, depth + 1);
      }
    };
    Encoder2.prototype.countWithoutUndefined = function(map, keys) {
      var count = 0;
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (map.get(key) !== void 0) {
          count++;
        }
      }
      return count;
    };
    Encoder2.prototype.sortMapKeys = function(keys) {
      var numericKeys = [];
      var stringKeys = [];
      var rawStringKeys = [];
      var binaryKeys = [];
      for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
        var key = keys_2[_i];
        if (typeof key === "number") {
          if (isNaN(key)) {
            throw new Error("Cannot sort map keys with NaN value");
          }
          numericKeys.push(key);
        } else if (typeof key === "bigint") {
          numericKeys.push(key);
        } else if (typeof key === "string") {
          stringKeys.push(key);
        } else if (ArrayBuffer.isView(key)) {
          binaryKeys.push(ensureUint8Array(key));
        } else if (key instanceof RawBinaryString) {
          rawStringKeys.push(key);
        } else {
          throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
        }
      }
      numericKeys.sort(function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      });
      stringKeys.sort();
      rawStringKeys.sort(function(a, b) {
        return compareUint8Arrays(ensureUint8Array(a.rawBinaryValue), ensureUint8Array(b.rawBinaryValue));
      });
      binaryKeys.sort(compareUint8Arrays);
      return [].concat(numericKeys, stringKeys, rawStringKeys, binaryKeys);
    };
    Encoder2.prototype.encodeMapObject = function(object, depth) {
      this.encodeMap(new Map(Object.entries(object)), depth);
    };
    Encoder2.prototype.encodeMap = function(map, depth) {
      var keys = Array.from(map.keys());
      if (this.sortKeys) {
        keys = this.sortMapKeys(keys);
      }
      var size = this.ignoreUndefined ? this.countWithoutUndefined(map, keys) : keys.length;
      if (size < 16) {
        this.writeU8(128 + size);
      } else if (size < 65536) {
        this.writeU8(222);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(223);
        this.writeU32(size);
      } else {
        throw new Error("Too large map object: ".concat(size));
      }
      for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
        var key = keys_3[_i];
        var value = map.get(key);
        if (!(this.ignoreUndefined && value === void 0)) {
          if (typeof key === "string") {
            this.encodeString(key);
          } else if (typeof key === "number") {
            this.encodeNumber(key);
          } else if (typeof key === "bigint") {
            this.encodeBigInt(key);
          } else if (ArrayBuffer.isView(key)) {
            this.encodeBinary(key);
          } else if (key instanceof RawBinaryString) {
            this.encodeBinaryAsString(key);
          } else {
            throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
          }
          this.doEncode(value, depth + 1);
        }
      }
    };
    Encoder2.prototype.encodeExtension = function(ext) {
      var size = ext.data.length;
      if (size === 1) {
        this.writeU8(212);
      } else if (size === 2) {
        this.writeU8(213);
      } else if (size === 4) {
        this.writeU8(214);
      } else if (size === 8) {
        this.writeU8(215);
      } else if (size === 16) {
        this.writeU8(216);
      } else if (size < 256) {
        this.writeU8(199);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(200);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(201);
        this.writeU32(size);
      } else {
        throw new Error("Too large extension object: ".concat(size));
      }
      this.writeI8(ext.type);
      this.writeU8a(ext.data);
    };
    Encoder2.prototype.writeU8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setUint8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU8a = function(values) {
      var size = values.length;
      this.ensureBufferSizeToWrite(size);
      this.bytes.set(values, this.pos);
      this.pos += size;
    };
    Encoder2.prototype.writeI8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setInt8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setUint16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeI16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setInt16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeU32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setUint32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeI32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setInt32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setFloat32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setFloat64(this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeU64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setUint64(this.view, this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeI64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setInt64(this.view, this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeBigUint64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigUint64(this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeBigInt64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigInt64(this.pos, value);
      this.pos += 8;
    };
    return Encoder2;
  }()
);

// node_modules/algorand-msgpack/dist.es5+esm/encode.mjs
function encode(value, options) {
  var encoder = new Encoder(options);
  return encoder.encodeSharedRef(value);
}

// node_modules/algorand-msgpack/dist.es5+esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
}

// node_modules/algorand-msgpack/dist.es5+esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH = 16;
var DEFAULT_MAX_LENGTH_PER_KEY = 16;
var CachedKeyDecoder = (
  /** @class */
  function() {
    function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {
      if (maxKeyLength === void 0) {
        maxKeyLength = DEFAULT_MAX_KEY_LENGTH;
      }
      if (maxLengthPerKey === void 0) {
        maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;
      }
      this.maxKeyLength = maxKeyLength;
      this.maxLengthPerKey = maxLengthPerKey;
      this.hit = 0;
      this.miss = 0;
      this.caches = [];
      for (var i = 0; i < this.maxKeyLength; i++) {
        this.caches.push([]);
      }
    }
    CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {
      return byteLength > 0 && byteLength <= this.maxKeyLength;
    };
    CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {
      var records = this.caches[byteLength - 1];
      FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
        var record = records_1[_i];
        var recordBytes = record.bytes;
        for (var j = 0; j < byteLength; j++) {
          if (recordBytes[j] !== bytes[inputOffset + j]) {
            continue FIND_CHUNK;
          }
        }
        return record.str;
      }
      return null;
    };
    CachedKeyDecoder2.prototype.store = function(bytes, value) {
      var records = this.caches[bytes.length - 1];
      var record = { bytes, str: value };
      if (records.length >= this.maxLengthPerKey) {
        records[Math.random() * records.length | 0] = record;
      } else {
        records.push(record);
      }
    };
    CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {
      var cachedValue = this.find(bytes, inputOffset, byteLength);
      if (cachedValue != null) {
        this.hit++;
        return cachedValue;
      }
      this.miss++;
      var str = utf8DecodeJs(bytes, inputOffset, byteLength);
      var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
      this.store(slicedCopyOfBytes, str);
      return str;
    };
    return CachedKeyDecoder2;
  }()
);

// node_modules/algorand-msgpack/dist.es5+esm/Decoder.mjs
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};
var STATE_ARRAY = "array";
var STATE_MAP_KEY = "map_key";
var STATE_MAP_VALUE = "map_value";
function isValidMapKeyType(key, useMap, supportObjectNumberKeys) {
  if (useMap) {
    return typeof key === "string" || typeof key === "number" || typeof key === "bigint" || key instanceof Uint8Array || key instanceof RawBinaryString;
  }
  return typeof key === "string" || supportObjectNumberKeys && typeof key === "number";
}
var StackPool = (
  /** @class */
  function() {
    function StackPool2(useMap) {
      this.useMap = useMap;
      this.stack = [];
      this.stackHeadPosition = -1;
    }
    Object.defineProperty(StackPool2.prototype, "length", {
      get: function() {
        return this.stackHeadPosition + 1;
      },
      enumerable: false,
      configurable: true
    });
    StackPool2.prototype.top = function() {
      return this.stack[this.stackHeadPosition];
    };
    StackPool2.prototype.pushArrayState = function(size) {
      var state = this.getUninitializedStateFromPool();
      state.type = STATE_ARRAY;
      state.position = 0;
      state.size = size;
      state.array = new Array(size);
    };
    StackPool2.prototype.pushMapState = function(size) {
      var state = this.getUninitializedStateFromPool();
      state.type = STATE_MAP_KEY;
      state.readCount = 0;
      state.size = size;
      state.map = this.useMap ? /* @__PURE__ */ new Map() : {};
    };
    StackPool2.prototype.getUninitializedStateFromPool = function() {
      this.stackHeadPosition++;
      if (this.stackHeadPosition === this.stack.length) {
        var partialState = {
          type: void 0,
          size: 0,
          array: void 0,
          position: 0,
          readCount: 0,
          map: void 0,
          key: null
        };
        this.stack.push(partialState);
      }
      return this.stack[this.stackHeadPosition];
    };
    StackPool2.prototype.release = function(state) {
      var topStackState = this.stack[this.stackHeadPosition];
      if (topStackState !== state) {
        throw new Error("Invalid stack state. Released state is not on top of the stack.");
      }
      if (state.type === STATE_ARRAY) {
        var partialState = state;
        partialState.size = 0;
        partialState.array = void 0;
        partialState.position = 0;
        partialState.type = void 0;
      }
      if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
        var partialState = state;
        partialState.size = 0;
        partialState.map = void 0;
        partialState.readCount = 0;
        partialState.type = void 0;
      }
      this.stackHeadPosition--;
    };
    StackPool2.prototype.reset = function() {
      this.stack.length = 0;
      this.stackHeadPosition = -1;
    };
    return StackPool2;
  }()
);
var HEAD_BYTE_REQUIRED = -1;
var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
  EMPTY_VIEW.getInt8(0);
} catch (e) {
  if (!(e instanceof RangeError)) {
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
  }
}
var DataViewIndexOutOfBoundsError = RangeError;
var MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
var sharedCachedKeyDecoder = new CachedKeyDecoder();
var Decoder = (
  /** @class */
  function() {
    function Decoder2(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.totalPos = 0;
      this.pos = 0;
      this.view = EMPTY_VIEW;
      this.bytes = EMPTY_BYTES;
      this.headByte = HEAD_BYTE_REQUIRED;
      this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
      this.context = options === null || options === void 0 ? void 0 : options.context;
      this.intMode = (_b = options === null || options === void 0 ? void 0 : options.intMode) !== null && _b !== void 0 ? _b : (options === null || options === void 0 ? void 0 : options.useBigInt64) ? IntMode.AS_ENCODED : IntMode.UNSAFE_NUMBER;
      this.rawBinaryStringValues = (_c = options === null || options === void 0 ? void 0 : options.rawBinaryStringValues) !== null && _c !== void 0 ? _c : false;
      this.rawBinaryStringKeys = (_d = options === null || options === void 0 ? void 0 : options.rawBinaryStringKeys) !== null && _d !== void 0 ? _d : false;
      this.useRawBinaryStringClass = (_e = options === null || options === void 0 ? void 0 : options.useRawBinaryStringClass) !== null && _e !== void 0 ? _e : false;
      this.useMap = (_f = options === null || options === void 0 ? void 0 : options.useMap) !== null && _f !== void 0 ? _f : false;
      this.supportObjectNumberKeys = (_g = options === null || options === void 0 ? void 0 : options.supportObjectNumberKeys) !== null && _g !== void 0 ? _g : false;
      this.maxStrLength = (_h = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _h !== void 0 ? _h : UINT32_MAX;
      this.maxBinLength = (_j = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _j !== void 0 ? _j : UINT32_MAX;
      this.maxArrayLength = (_k = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _k !== void 0 ? _k : UINT32_MAX;
      this.maxMapLength = (_l = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _l !== void 0 ? _l : UINT32_MAX;
      this.maxExtLength = (_m = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _m !== void 0 ? _m : UINT32_MAX;
      this.keyDecoder = (options === null || options === void 0 ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
      if (this.rawBinaryStringKeys && !this.useMap) {
        throw new Error("rawBinaryStringKeys is only supported when useMap is true");
      }
      this.stack = new StackPool(this.useMap);
    }
    Decoder2.prototype.reinitializeState = function() {
      this.totalPos = 0;
      this.headByte = HEAD_BYTE_REQUIRED;
      this.stack.reset();
    };
    Decoder2.prototype.setBuffer = function(buffer) {
      this.bytes = ensureUint8Array(buffer);
      this.view = createDataView(this.bytes);
      this.pos = 0;
    };
    Decoder2.prototype.appendBuffer = function(buffer) {
      if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
        this.setBuffer(buffer);
      } else {
        var remainingData = this.bytes.subarray(this.pos);
        var newData = ensureUint8Array(buffer);
        var newBuffer = new Uint8Array(remainingData.length + newData.length);
        newBuffer.set(remainingData);
        newBuffer.set(newData, remainingData.length);
        this.setBuffer(newBuffer);
      }
    };
    Decoder2.prototype.hasRemaining = function(size) {
      return this.view.byteLength - this.pos >= size;
    };
    Decoder2.prototype.createExtraByteError = function(posToShow) {
      var _a = this, view = _a.view, pos = _a.pos;
      return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
    };
    Decoder2.prototype.decode = function(buffer) {
      this.reinitializeState();
      this.setBuffer(buffer);
      var object = this.doDecodeSync();
      if (this.hasRemaining(1)) {
        throw this.createExtraByteError(this.pos);
      }
      return object;
    };
    Decoder2.prototype.decodeMulti = function(buffer) {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.reinitializeState();
            this.setBuffer(buffer);
            _a.label = 1;
          case 1:
            if (!this.hasRemaining(1)) return [3, 3];
            return [4, this.doDecodeSync()];
          case 2:
            _a.sent();
            return [3, 1];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    Decoder2.prototype.decodeAsync = function(stream) {
      var _a, stream_1, stream_1_1;
      var _b, e_1, _c, _d;
      return __awaiter(this, void 0, void 0, function() {
        var decoded, object, buffer, e_1_1, _e, headByte, pos, totalPos;
        return __generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              decoded = false;
              _f.label = 1;
            case 1:
              _f.trys.push([1, 6, 7, 12]);
              _a = true, stream_1 = __asyncValues(stream);
              _f.label = 2;
            case 2:
              return [4, stream_1.next()];
            case 3:
              if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3, 5];
              _d = stream_1_1.value;
              _a = false;
              buffer = _d;
              if (decoded) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(buffer);
              try {
                object = this.doDecodeSync();
                decoded = true;
              } catch (e) {
                if (!(e instanceof DataViewIndexOutOfBoundsError)) {
                  throw e;
                }
              }
              this.totalPos += this.pos;
              _f.label = 4;
            case 4:
              _a = true;
              return [3, 2];
            case 5:
              return [3, 12];
            case 6:
              e_1_1 = _f.sent();
              e_1 = { error: e_1_1 };
              return [3, 12];
            case 7:
              _f.trys.push([7, , 10, 11]);
              if (!(!_a && !_b && (_c = stream_1.return))) return [3, 9];
              return [4, _c.call(stream_1)];
            case 8:
              _f.sent();
              _f.label = 9;
            case 9:
              return [3, 11];
            case 10:
              if (e_1) throw e_1.error;
              return [
                7
                /*endfinally*/
              ];
            case 11:
              return [
                7
                /*endfinally*/
              ];
            case 12:
              if (decoded) {
                if (this.hasRemaining(1)) {
                  throw this.createExtraByteError(this.totalPos);
                }
                return [2, object];
              }
              _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;
              throw new RangeError("Insufficient data in parsing ".concat(prettyByte(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
          }
        });
      });
    };
    Decoder2.prototype.decodeArrayStream = function(stream) {
      return this.decodeMultiAsync(stream, true);
    };
    Decoder2.prototype.decodeStream = function(stream) {
      return this.decodeMultiAsync(stream, false);
    };
    Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {
      return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {
        var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer, e_2, e_3_1;
        var _b, e_3, _c, _d;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              isArrayHeaderRequired = isArray;
              arrayItemsLeft = -1;
              _e.label = 1;
            case 1:
              _e.trys.push([1, 13, 14, 19]);
              _a = true, stream_2 = __asyncValues(stream);
              _e.label = 2;
            case 2:
              return [4, __await(stream_2.next())];
            case 3:
              if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3, 12];
              _d = stream_2_1.value;
              _a = false;
              buffer = _d;
              if (isArray && arrayItemsLeft === 0) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(buffer);
              if (isArrayHeaderRequired) {
                arrayItemsLeft = this.readArraySize();
                isArrayHeaderRequired = false;
                this.complete();
              }
              _e.label = 4;
            case 4:
              _e.trys.push([4, 9, , 10]);
              _e.label = 5;
            case 5:
              if (false) return [3, 8];
              return [4, __await(this.doDecodeSync())];
            case 6:
              return [4, _e.sent()];
            case 7:
              _e.sent();
              if (--arrayItemsLeft === 0) {
                return [3, 8];
              }
              return [3, 5];
            case 8:
              return [3, 10];
            case 9:
              e_2 = _e.sent();
              if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {
                throw e_2;
              }
              return [3, 10];
            case 10:
              this.totalPos += this.pos;
              _e.label = 11;
            case 11:
              _a = true;
              return [3, 2];
            case 12:
              return [3, 19];
            case 13:
              e_3_1 = _e.sent();
              e_3 = { error: e_3_1 };
              return [3, 19];
            case 14:
              _e.trys.push([14, , 17, 18]);
              if (!(!_a && !_b && (_c = stream_2.return))) return [3, 16];
              return [4, __await(_c.call(stream_2))];
            case 15:
              _e.sent();
              _e.label = 16;
            case 16:
              return [3, 18];
            case 17:
              if (e_3) throw e_3.error;
              return [
                7
                /*endfinally*/
              ];
            case 18:
              return [
                7
                /*endfinally*/
              ];
            case 19:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Decoder2.prototype.doDecodeSync = function() {
      DECODE: while (true) {
        var headByte = this.readHeadByte();
        var object = void 0;
        if (headByte >= 224) {
          object = this.convertNumber(headByte - 256);
        } else if (headByte < 192) {
          if (headByte < 128) {
            object = this.convertNumber(headByte);
          } else if (headByte < 144) {
            var size = headByte - 128;
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = this.useMap ? /* @__PURE__ */ new Map() : {};
            }
          } else if (headByte < 160) {
            var size = headByte - 144;
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else {
            var byteLength = headByte - 160;
            object = this.decodeString(byteLength, 0);
          }
        } else if (headByte === 192) {
          object = null;
        } else if (headByte === 194) {
          object = false;
        } else if (headByte === 195) {
          object = true;
        } else if (headByte === 202) {
          object = this.readF32();
        } else if (headByte === 203) {
          object = this.readF64();
        } else if (headByte === 204) {
          object = this.convertNumber(this.readU8());
        } else if (headByte === 205) {
          object = this.convertNumber(this.readU16());
        } else if (headByte === 206) {
          object = this.convertNumber(this.readU32());
        } else if (headByte === 207) {
          object = this.readU64();
        } else if (headByte === 208) {
          object = this.convertNumber(this.readI8());
        } else if (headByte === 209) {
          object = this.convertNumber(this.readI16());
        } else if (headByte === 210) {
          object = this.convertNumber(this.readI32());
        } else if (headByte === 211) {
          object = this.readI64();
        } else if (headByte === 217) {
          var byteLength = this.lookU8();
          object = this.decodeString(byteLength, 1);
        } else if (headByte === 218) {
          var byteLength = this.lookU16();
          object = this.decodeString(byteLength, 2);
        } else if (headByte === 219) {
          var byteLength = this.lookU32();
          object = this.decodeString(byteLength, 4);
        } else if (headByte === 220) {
          var size = this.readU16();
          if (size !== 0) {
            this.pushArrayState(size);
            this.complete();
            continue DECODE;
          } else {
            object = [];
          }
        } else if (headByte === 221) {
          var size = this.readU32();
          if (size !== 0) {
            this.pushArrayState(size);
            this.complete();
            continue DECODE;
          } else {
            object = [];
          }
        } else if (headByte === 222) {
          var size = this.readU16();
          if (size !== 0) {
            this.pushMapState(size);
            this.complete();
            continue DECODE;
          } else {
            object = {};
          }
        } else if (headByte === 223) {
          var size = this.readU32();
          if (size !== 0) {
            this.pushMapState(size);
            this.complete();
            continue DECODE;
          } else {
            object = {};
          }
        } else if (headByte === 196) {
          var size = this.lookU8();
          object = this.decodeBinary(size, 1);
        } else if (headByte === 197) {
          var size = this.lookU16();
          object = this.decodeBinary(size, 2);
        } else if (headByte === 198) {
          var size = this.lookU32();
          object = this.decodeBinary(size, 4);
        } else if (headByte === 212) {
          object = this.decodeExtension(1, 0);
        } else if (headByte === 213) {
          object = this.decodeExtension(2, 0);
        } else if (headByte === 214) {
          object = this.decodeExtension(4, 0);
        } else if (headByte === 215) {
          object = this.decodeExtension(8, 0);
        } else if (headByte === 216) {
          object = this.decodeExtension(16, 0);
        } else if (headByte === 199) {
          var size = this.lookU8();
          object = this.decodeExtension(size, 1);
        } else if (headByte === 200) {
          var size = this.lookU16();
          object = this.decodeExtension(size, 2);
        } else if (headByte === 201) {
          var size = this.lookU32();
          object = this.decodeExtension(size, 4);
        } else {
          throw new DecodeError("Unrecognized type byte: ".concat(prettyByte(headByte)));
        }
        this.complete();
        var stack = this.stack;
        while (stack.length > 0) {
          var state = stack.top();
          if (state.type === STATE_ARRAY) {
            state.array[state.position] = object;
            state.position++;
            if (state.position === state.size) {
              object = state.array;
              stack.release(state);
            } else {
              continue DECODE;
            }
          } else if (state.type === STATE_MAP_KEY) {
            if (!isValidMapKeyType(object, this.useMap, this.supportObjectNumberKeys)) {
              var acceptableTypes = this.useMap ? "string, number, bigint, or Uint8Array" : this.supportObjectNumberKeys ? "string or number" : "string";
              throw new DecodeError("The type of key must be ".concat(acceptableTypes, " but got ").concat(typeof object));
            }
            if (!this.useMap && object === "__proto__") {
              throw new DecodeError("The key __proto__ is not allowed");
            }
            state.key = object;
            state.type = STATE_MAP_VALUE;
            continue DECODE;
          } else {
            if (this.useMap) {
              state.map.set(state.key, object);
            } else {
              state.map[state.key] = object;
            }
            state.readCount++;
            if (state.readCount === state.size) {
              object = state.map;
              stack.release(state);
            } else {
              state.key = null;
              state.type = STATE_MAP_KEY;
              continue DECODE;
            }
          }
        }
        return object;
      }
    };
    Decoder2.prototype.readHeadByte = function() {
      if (this.headByte === HEAD_BYTE_REQUIRED) {
        this.headByte = this.readU8();
      }
      return this.headByte;
    };
    Decoder2.prototype.complete = function() {
      this.headByte = HEAD_BYTE_REQUIRED;
    };
    Decoder2.prototype.readArraySize = function() {
      var headByte = this.readHeadByte();
      switch (headByte) {
        case 220:
          return this.readU16();
        case 221:
          return this.readU32();
        default: {
          if (headByte < 160) {
            return headByte - 144;
          } else {
            throw new DecodeError("Unrecognized array type byte: ".concat(prettyByte(headByte)));
          }
        }
      }
    };
    Decoder2.prototype.pushMapState = function(size) {
      if (size > this.maxMapLength) {
        throw new DecodeError("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
      }
      this.stack.pushMapState(size);
    };
    Decoder2.prototype.pushArrayState = function(size) {
      if (size > this.maxArrayLength) {
        throw new DecodeError("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
      }
      this.stack.pushArrayState(size);
    };
    Decoder2.prototype.decodeString = function(byteLength, headerOffset) {
      if (this.stateIsMapKey() ? this.rawBinaryStringKeys : this.rawBinaryStringValues) {
        var decoded = this.decodeBinary(byteLength, headerOffset);
        if (this.useRawBinaryStringClass) {
          return new RawBinaryString(decoded);
        }
        return decoded;
      }
      return this.decodeUtf8String(byteLength, headerOffset);
    };
    Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {
      var _a;
      if (byteLength > this.maxStrLength) {
        throw new DecodeError("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
      }
      if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
        throw MORE_DATA;
      }
      var offset = this.pos + headerOffset;
      var object;
      if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
        object = this.keyDecoder.decode(this.bytes, offset, byteLength);
      } else {
        object = utf8Decode(this.bytes, offset, byteLength);
      }
      this.pos += headerOffset + byteLength;
      return object;
    };
    Decoder2.prototype.stateIsMapKey = function() {
      if (this.stack.length > 0) {
        var state = this.stack.top();
        return state.type === STATE_MAP_KEY;
      }
      return false;
    };
    Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {
      if (byteLength > this.maxBinLength) {
        throw new DecodeError("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
      }
      if (!this.hasRemaining(byteLength + headOffset)) {
        throw MORE_DATA;
      }
      var offset = this.pos + headOffset;
      var object = this.bytes.subarray(offset, offset + byteLength);
      this.pos += headOffset + byteLength;
      return object;
    };
    Decoder2.prototype.decodeExtension = function(size, headOffset) {
      if (size > this.maxExtLength) {
        throw new DecodeError("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
      }
      var extType = this.view.getInt8(this.pos + headOffset);
      var data = this.decodeBinary(
        size,
        headOffset + 1
        /* extType */
      );
      return this.extensionCodec.decode(data, extType, this.context);
    };
    Decoder2.prototype.convertNumber = function(value) {
      return convertSafeIntegerToMode(value, this.intMode);
    };
    Decoder2.prototype.lookU8 = function() {
      return this.view.getUint8(this.pos);
    };
    Decoder2.prototype.lookU16 = function() {
      return this.view.getUint16(this.pos);
    };
    Decoder2.prototype.lookU32 = function() {
      return this.view.getUint32(this.pos);
    };
    Decoder2.prototype.readU8 = function() {
      var value = this.view.getUint8(this.pos);
      this.pos++;
      return value;
    };
    Decoder2.prototype.readI8 = function() {
      var value = this.view.getInt8(this.pos);
      this.pos++;
      return value;
    };
    Decoder2.prototype.readU16 = function() {
      var value = this.view.getUint16(this.pos);
      this.pos += 2;
      return value;
    };
    Decoder2.prototype.readI16 = function() {
      var value = this.view.getInt16(this.pos);
      this.pos += 2;
      return value;
    };
    Decoder2.prototype.readU32 = function() {
      var value = this.view.getUint32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readI32 = function() {
      var value = this.view.getInt32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readU64 = function() {
      var value = getUint64(this.view, this.pos, this.intMode);
      this.pos += 8;
      return value;
    };
    Decoder2.prototype.readI64 = function() {
      var value = getInt64(this.view, this.pos, this.intMode);
      this.pos += 8;
      return value;
    };
    Decoder2.prototype.readF32 = function() {
      var value = this.view.getFloat32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readF64 = function() {
      var value = this.view.getFloat64(this.pos);
      this.pos += 8;
      return value;
    };
    return Decoder2;
  }()
);

// node_modules/algorand-msgpack/dist.es5+esm/decode.mjs
function decode(buffer, options) {
  var decoder = new Decoder(options);
  return decoder.decode(buffer);
}

// node_modules/algosdk/dist/esm/encoding/encoding.js
var ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function containsEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0) {
        return { containsEmpty: true, firstEmptyKey: key };
      }
    }
  }
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function msgpackRawEncode(obj) {
  const options = { sortKeys: true };
  return encode(obj, options);
}
function encodeObj(obj) {
  const emptyCheck = containsEmpty(obj);
  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  }
  return msgpackRawEncode(obj);
}
function intDecodingToIntMode(intDecoding) {
  switch (intDecoding) {
    case intDecoding_default.UNSAFE:
      return IntMode.UNSAFE_NUMBER;
    case intDecoding_default.SAFE:
      return IntMode.SAFE_NUMBER;
    case intDecoding_default.MIXED:
      return IntMode.MIXED;
    case intDecoding_default.BIGINT:
      return IntMode.BIGINT;
    default:
      throw new Error(`Invalid intDecoding: ${intDecoding}`);
  }
}
function msgpackRawDecode(buffer, options) {
  const decoderOptions = {
    intMode: (options == null ? void 0 : options.intDecoding) ? intDecodingToIntMode(options == null ? void 0 : options.intDecoding) : IntMode.BIGINT
  };
  return decode(buffer, decoderOptions);
}
function decodeObj(o) {
  return msgpackRawDecode(o, { intDecoding: intDecoding_default.MIXED });
}
function msgpackRawDecodeAsMap(encoded, options) {
  const decoderOptions = {
    intMode: (options == null ? void 0 : options.intDecoding) ? intDecodingToIntMode(options == null ? void 0 : options.intDecoding) : IntMode.BIGINT,
    useMap: true
  };
  return decode(encoded, decoderOptions);
}
function msgpackRawDecodeAsMapWithRawStrings(encoded, options) {
  const decoderOptions = {
    intMode: (options == null ? void 0 : options.intDecoding) ? intDecodingToIntMode(options == null ? void 0 : options.intDecoding) : IntMode.BIGINT,
    useMap: true,
    rawBinaryStringKeys: true,
    rawBinaryStringValues: true,
    useRawBinaryStringClass: true
  };
  return decode(encoded, decoderOptions);
}
function msgpackEncodingDataToJSONEncodingData(e) {
  if (e === null || e === void 0) {
    return e;
  }
  if (e instanceof Uint8Array) {
    return bytesToBase64(e);
  }
  if (Array.isArray(e)) {
    return e.map(msgpackEncodingDataToJSONEncodingData);
  }
  if (e instanceof Map) {
    const obj = {};
    for (const [k, v] of e) {
      if (typeof k !== "string") {
        throw new Error(`JSON map key must be a string: ${k}`);
      }
      obj[k] = msgpackEncodingDataToJSONEncodingData(v);
    }
    return obj;
  }
  return e;
}
function jsonEncodingDataToMsgpackEncodingData(e) {
  if (e === null || e === void 0) {
    return e;
  }
  if (typeof e === "string" || // Note, this will not convert base64 to Uint8Array
  typeof e === "number" || typeof e === "bigint" || typeof e === "boolean") {
    return e;
  }
  if (Array.isArray(e)) {
    return e.map(jsonEncodingDataToMsgpackEncodingData);
  }
  if (typeof e === "object") {
    const obj = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(e)) {
      obj.set(key, jsonEncodingDataToMsgpackEncodingData(value));
    }
    return obj;
  }
  throw new Error(`Invalid JSON encoding data: ${e}`);
}
var MsgpackObjectPathSegmentKind;
(function(MsgpackObjectPathSegmentKind2) {
  MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["MAP_VALUE"] = 0] = "MAP_VALUE";
  MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["ARRAY_ELEMENT"] = 1] = "ARRAY_ELEMENT";
})(MsgpackObjectPathSegmentKind || (MsgpackObjectPathSegmentKind = {}));
var MsgpackRawStringProvider = class _MsgpackRawStringProvider {
  constructor({ parent, segment, baseObjectBytes }) {
    this.resolvedCache = null;
    this.resolvedCachePresent = false;
    this.parent = parent;
    this.segment = segment;
    this.baseObjectBytes = baseObjectBytes;
  }
  /**
   * Create a new provider that resolves to the current provider's map value at the given key.
   */
  withMapValue(key) {
    return new _MsgpackRawStringProvider({
      parent: this,
      segment: {
        kind: MsgpackObjectPathSegmentKind.MAP_VALUE,
        key
      }
    });
  }
  /**
   * Create a new provider that resolves to the current provider's array element at the given index.
   */
  withArrayElement(index) {
    return new _MsgpackRawStringProvider({
      parent: this,
      segment: {
        kind: MsgpackObjectPathSegmentKind.ARRAY_ELEMENT,
        key: index
      }
    });
  }
  /**
   * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.
   */
  getRawStringAtCurrentLocation() {
    const resolved = this.resolve();
    if (resolved instanceof RawBinaryString) {
      return resolved.rawBinaryValue;
    }
    throw new Error(`Invalid type. Expected RawBinaryString, got ${resolved} (${typeof resolved})`);
  }
  /**
   * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.
   */
  getRawStringKeysAndValuesAtCurrentLocation() {
    const resolved = this.resolve();
    if (!(resolved instanceof Map)) {
      throw new Error(`Invalid type. Expected Map, got ${resolved} (${typeof resolved})`);
    }
    const keysAndValues = /* @__PURE__ */ new Map();
    for (const [key, value] of resolved) {
      if (key instanceof RawBinaryString) {
        keysAndValues.set(key.rawBinaryValue, value);
      } else {
        throw new Error(`Invalid type for map key. Expected RawBinaryString, got ${key} (${typeof key})`);
      }
    }
    return keysAndValues;
  }
  /**
   * Resolve the provider by extracting the value it indicates from the base msgpack object.
   */
  resolve() {
    if (this.resolvedCachePresent) {
      return this.resolvedCache;
    }
    let parentResolved;
    if (this.parent) {
      parentResolved = this.parent.resolve();
    } else {
      parentResolved = msgpackRawDecodeAsMapWithRawStrings(this.baseObjectBytes);
    }
    if (!this.segment) {
      this.resolvedCache = parentResolved;
      this.resolvedCachePresent = true;
      return parentResolved;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
      if (!(parentResolved instanceof Map)) {
        throw new Error(`Invalid type. Expected Map, got ${parentResolved} (${typeof parentResolved})`);
      }
      if (typeof this.segment.key === "string" || this.segment.key instanceof Uint8Array || this.segment.key instanceof RawBinaryString) {
        const targetBytes = this.segment.key instanceof RawBinaryString ? (
          // Decoded rawBinaryValue will always be a Uint8Array
          this.segment.key.rawBinaryValue
        ) : coerceToBytes(this.segment.key);
        const targetIsRawString = typeof this.segment.key === "string" || this.segment.key instanceof RawBinaryString;
        for (const [key, value] of parentResolved) {
          let potentialKeyBytes;
          if (targetIsRawString) {
            if (key instanceof RawBinaryString) {
              potentialKeyBytes = key.rawBinaryValue;
            }
          } else if (key instanceof Uint8Array) {
            potentialKeyBytes = key;
          }
          if (potentialKeyBytes && arrayEqual(targetBytes, potentialKeyBytes)) {
            this.resolvedCache = value;
            break;
          }
        }
      } else {
        this.resolvedCache = parentResolved.get(this.segment.key);
      }
      this.resolvedCachePresent = true;
      return this.resolvedCache;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
      if (!Array.isArray(parentResolved)) {
        throw new Error(`Invalid type. Expected Array, got ${parentResolved} (${typeof parentResolved})`);
      }
      this.resolvedCache = parentResolved[this.segment.key];
      this.resolvedCachePresent = true;
      return this.resolvedCache;
    }
    throw new Error(`Invalid segment kind: ${this.segment.kind}`);
  }
  /**
   * Get the path string of the current location indicated by the provider. Useful for debugging.
   */
  getPathString() {
    const parentPathString = this.parent ? this.parent.getPathString() : "root";
    if (!this.segment) {
      return parentPathString;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
      return `${parentPathString} -> map key "${this.segment.key}" (${typeof this.segment.key})`;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
      return `${parentPathString} -> array index ${this.segment.key} (${typeof this.segment.key})`;
    }
    return `${parentPathString} -> unknown segment kind ${this.segment.kind}`;
  }
};
var Schema = class {
};
function decodeMsgpack(encoded, c) {
  const decoded = msgpackRawDecodeAsMap(encoded);
  const rawStringProvider = new MsgpackRawStringProvider({
    baseObjectBytes: encoded
  });
  return c.fromEncodingData(c.encodingSchema.fromPreparedMsgpack(decoded, rawStringProvider));
}
function encodeMsgpack(e) {
  return msgpackRawEncode(e.getEncodingSchema().prepareMsgpack(e.toEncodingData()));
}
function decodeJSON(encoded, c) {
  const decoded = parseJSON(encoded, {
    intDecoding: intDecoding_default.BIGINT
  });
  return c.fromEncodingData(c.encodingSchema.fromPreparedJSON(decoded));
}
function encodeJSON(e, options) {
  const { space, ...prepareJSONOptions } = options ?? {};
  const prepared = e.getEncodingSchema().prepareJSON(e.toEncodingData(), prepareJSONOptions);
  return stringifyJSON(prepared, void 0, space);
}

// node_modules/algosdk/dist/esm/encoding/schema/boolean.js
var BooleanSchema = class extends Schema {
  defaultValue() {
    return false;
  }
  isDefaultValue(data) {
    return data === false;
  }
  prepareMsgpack(data) {
    if (typeof data === "boolean") {
      return data;
    }
    throw new Error("Invalid boolean");
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (typeof encoded === "boolean") {
      return encoded;
    }
    throw new Error("Invalid boolean");
  }
  prepareJSON(data, _options) {
    if (typeof data === "boolean") {
      return data;
    }
    throw new Error("Invalid boolean");
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "boolean") {
      return encoded;
    }
    throw new Error("Invalid boolean");
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/string.js
var StringSchema = class extends Schema {
  defaultValue() {
    return "";
  }
  isDefaultValue(data) {
    return data === "";
  }
  prepareMsgpack(data) {
    if (typeof data === "string") {
      return data;
    }
    throw new Error(`Invalid string: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (typeof encoded === "string") {
      return encoded;
    }
    throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (typeof data === "string") {
      return data;
    }
    throw new Error(`Invalid string: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      return encoded;
    }
    throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/uint64.js
var Uint64Schema = class extends Schema {
  defaultValue() {
    return BigInt(0);
  }
  isDefaultValue(data) {
    if (typeof data === "bigint")
      return data === BigInt(0);
    if (typeof data === "number")
      return data === 0;
    return false;
  }
  prepareMsgpack(data) {
    return ensureUint64(data);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return ensureUint64(encoded);
  }
  prepareJSON(data, _options) {
    return ensureUint64(data);
  }
  fromPreparedJSON(encoded) {
    return ensureUint64(encoded);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/address.js
var AddressSchema = class extends Schema {
  defaultValue() {
    return Address.zeroAddress();
  }
  isDefaultValue(data) {
    return Address.zeroAddress().equals(data);
  }
  prepareMsgpack(data) {
    if (data instanceof Address) {
      return data.publicKey;
    }
    throw new Error(`Invalid address: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return new Address(encoded);
  }
  prepareJSON(data, _options) {
    if (data instanceof Address) {
      return data.toString();
    }
    throw new Error(`Invalid address: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    return Address.fromString(encoded);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/bytearray.js
var ByteArraySchema = class extends Schema {
  defaultValue() {
    return new Uint8Array();
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === 0;
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array) {
      return encoded;
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (data instanceof Uint8Array) {
      return bytesToBase64(data);
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (encoded === null || encoded === void 0) {
      return this.defaultValue();
    }
    if (typeof encoded === "string") {
      return base64ToBytes(encoded);
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
};
var FixedLengthByteArraySchema = class extends Schema {
  constructor(length) {
    super();
    this.length = length;
  }
  defaultValue() {
    return new Uint8Array(this.length);
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === this.length && data.every((byte) => byte === 0);
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      if (data.byteLength === this.length) {
        return data;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array) {
      if (encoded.byteLength === this.length) {
        return encoded;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${encoded.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  prepareJSON(data) {
    if (data instanceof Uint8Array) {
      if (data.byteLength === this.length) {
        return bytesToBase64(data);
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      const bytes = base64ToBytes(encoded);
      if (bytes.byteLength === this.length) {
        return bytes;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${bytes.byteLength}`);
    }
    throw new Error("Invalid base64 byte array");
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/blockhash.js
var import_hi_base322 = __toESM(require_base32(), 1);
var blockHashByteLength = 32;
var base32Length = 52;
var BlockHashSchema = class extends Schema {
  defaultValue() {
    return new Uint8Array(blockHashByteLength);
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === blockHashByteLength && data.every((byte) => byte === 0);
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
      return data;
    }
    throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array && encoded.byteLength === blockHashByteLength) {
      return encoded;
    }
    throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
      return `blk-${import_hi_base322.default.encode(data).slice(0, base32Length)}`;
    }
    throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string" && encoded.length === base32Length + 4 && encoded.startsWith("blk-")) {
      return Uint8Array.from(import_hi_base322.default.decode.asBytes(encoded.slice(4)));
    }
    throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/binarystring.js
var SpecialCaseBinaryStringSchema = class extends Schema {
  defaultValue() {
    return new Uint8Array();
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === 0;
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      return new RawBinaryString(data);
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(_encoded, rawStringProvider) {
    return rawStringProvider.getRawStringAtCurrentLocation();
  }
  prepareJSON(data, options) {
    if (data instanceof Uint8Array) {
      const stringValue = bytesToString(data);
      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(stringValue), data)) {
        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(data)}`);
      }
      return stringValue;
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      return coerceToBytes(encoded);
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/array.js
var ArraySchema = class extends Schema {
  constructor(itemSchema) {
    super();
    this.itemSchema = itemSchema;
  }
  defaultValue() {
    return [];
  }
  isDefaultValue(data) {
    return Array.isArray(data) && data.length === 0;
  }
  prepareMsgpack(data) {
    if (Array.isArray(data)) {
      return data.map((item) => this.itemSchema.prepareMsgpack(item));
    }
    throw new Error("ArraySchema data must be an array");
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (Array.isArray(encoded)) {
      return encoded.map((item, index) => this.itemSchema.fromPreparedMsgpack(item, rawStringProvider.withArrayElement(index)));
    }
    throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
  }
  prepareJSON(data, options) {
    if (Array.isArray(data)) {
      return data.map((item) => this.itemSchema.prepareJSON(item, options));
    }
    throw new Error("ArraySchema data must be an array");
  }
  fromPreparedJSON(encoded) {
    if (Array.isArray(encoded)) {
      return encoded.map((item) => this.itemSchema.fromPreparedJSON(item));
    }
    throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/map.js
function allOmitEmpty(entries) {
  return entries.map((entry) => ({ ...entry, omitEmpty: true }));
}
var NamedMapSchema = class _NamedMapSchema extends Schema {
  constructor(entries) {
    super();
    this.entries = entries;
    this.checkEntries();
  }
  /**
   * Adds new entries to the map schema. WARNING: this is a mutable operation, and you should be very
   * careful when using it. Any error that happens here is non-recoverable and will corrupt the
   * NamedMapSchema object;
   * @param entries - The entries to add.
   */
  pushEntries(...entries) {
    this.entries.push(...entries);
    this.checkEntries();
  }
  checkEntries() {
    for (const entry of this.entries) {
      if (entry.embedded) {
        if (entry.key !== "") {
          throw new Error("Embedded entries must have an empty key");
        }
        if (!(entry.valueSchema instanceof _NamedMapSchema)) {
          throw new Error("Embedded entry valueSchema must be a NamedMapSchema");
        }
      }
    }
    const keys = /* @__PURE__ */ new Set();
    for (const entry of this.getEntries()) {
      if (keys.has(entry.key)) {
        throw new Error(`Duplicate key: ${entry.key}`);
      }
      keys.add(entry.key);
    }
  }
  /**
   * Returns all top-level entries, properly accounting for fields from embedded entries.
   * @returns An array of all top-level entries for this map.
   */
  getEntries() {
    const entries = [];
    for (const entry of this.entries) {
      if (entry.embedded) {
        const embeddedMapSchema = entry.valueSchema;
        entries.push(...embeddedMapSchema.getEntries());
      } else {
        entries.push(entry);
      }
    }
    return entries;
  }
  defaultValue() {
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      map.set(entry.key, entry.valueSchema.defaultValue());
    }
    return map;
  }
  isDefaultValue(data) {
    if (!(data instanceof Map))
      return false;
    for (const entry of this.getEntries()) {
      if (!entry.valueSchema.isDefaultValue(data.get(entry.key))) {
        return false;
      }
    }
    return true;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`NamedMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      const value = data.get(entry.key);
      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
        continue;
      }
      map.set(entry.key, entry.valueSchema.prepareMsgpack(value));
    }
    return map;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("NamedMapSchema data must be a Map");
    }
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      if (encoded.has(entry.key)) {
        map.set(entry.key, entry.valueSchema.fromPreparedMsgpack(encoded.get(entry.key), rawStringProvider.withMapValue(entry.key)));
      } else if (entry.omitEmpty) {
        map.set(entry.key, entry.valueSchema.defaultValue());
      } else {
        throw new Error(`Missing key: ${entry.key}`);
      }
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error("NamedMapSchema data must be a Map");
    }
    const obj = {};
    for (const entry of this.getEntries()) {
      const value = data.get(entry.key);
      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
        continue;
      }
      obj[entry.key] = entry.valueSchema.prepareJSON(value, options);
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("NamedMapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      if (Object.prototype.hasOwnProperty.call(encoded, entry.key)) {
        map.set(entry.key, entry.valueSchema.fromPreparedJSON(encoded[entry.key]));
      } else if (entry.omitEmpty) {
        map.set(entry.key, entry.valueSchema.defaultValue());
      } else {
        throw new Error(`Missing key: ${entry.key}`);
      }
    }
    return map;
  }
};
function combineMaps(...maps) {
  const combined = /* @__PURE__ */ new Map();
  for (const map of maps) {
    for (const [key, value] of map) {
      if (combined.has(key)) {
        throw new Error(`Duplicate key: ${key}`);
      }
      combined.set(key, value);
    }
  }
  return combined;
}
function convertMap(map, func) {
  const mapped = /* @__PURE__ */ new Map();
  for (const [key, value] of map) {
    const [newKey, newValue] = func(key, value);
    mapped.set(newKey, newValue);
  }
  return mapped;
}
var Uint64MapSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      const bigintKey = ensureUint64(key);
      if (prepared.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      prepared.set(bigintKey, this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("Uint64MapSchema data must be a Map");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of encoded) {
      const bigintKey = ensureUint64(key);
      if (map.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      map.set(bigintKey, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      const bigintKey = ensureUint64(key);
      if (prepared.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      prepared.set(bigintKey, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key.toString()] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("Uint64MapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      const bigintKey = BigInt(key);
      if (map.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      map.set(bigintKey, this.valueSchema.fromPreparedJSON(value));
    }
    return map;
  }
};
var ByteArrayMapSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      prepared.set(key, this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("ByteArrayMapSchema data must be a Map");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of encoded) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      map.set(key, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      const b64Encoded = bytesToBase64(key);
      if (prepared.has(b64Encoded)) {
        throw new Error(`Duplicate key (base64): ${b64Encoded}`);
      }
      prepared.set(b64Encoded, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("ByteArrayMapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      map.set(base64ToBytes(key), this.valueSchema.fromPreparedJSON(value));
    }
    return map;
  }
};
function convertRawStringsInMsgpackValue(value) {
  if (value instanceof RawBinaryString) {
    return bytesToString(value.rawBinaryValue);
  }
  if (value instanceof Map) {
    const newMap = /* @__PURE__ */ new Map();
    for (const [key, val] of value) {
      newMap.set(convertRawStringsInMsgpackValue(key), convertRawStringsInMsgpackValue(val));
    }
    return newMap;
  }
  if (Array.isArray(value)) {
    return value.map(convertRawStringsInMsgpackValue);
  }
  return value;
}
var SpecialCaseBinaryStringMapSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      prepared.set(new RawBinaryString(key), this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(_encoded, rawStringProvider) {
    const map = /* @__PURE__ */ new Map();
    const keysAndValues = rawStringProvider.getRawStringKeysAndValuesAtCurrentLocation();
    for (const [key, value] of keysAndValues) {
      map.set(key, this.valueSchema.fromPreparedMsgpack(convertRawStringsInMsgpackValue(value), rawStringProvider.withMapValue(new RawBinaryString(key))));
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key}`);
      }
      const keyStringValue = bytesToString(key);
      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(keyStringValue), key)) {
        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(key)}`);
      }
      prepared.set(keyStringValue, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("SpecialCaseBinaryStringMapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      map.set(coerceToBytes(key), this.valueSchema.fromPreparedJSON(value));
    }
    return map;
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/optional.js
var OptionalSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return void 0;
  }
  isDefaultValue(data) {
    return data === void 0 || this.valueSchema.isDefaultValue(data);
  }
  prepareMsgpack(data) {
    if (data === void 0) {
      return void 0;
    }
    return this.valueSchema.prepareMsgpack(data);
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (encoded === void 0 || encoded === null) {
      return void 0;
    }
    return this.valueSchema.fromPreparedMsgpack(encoded, rawStringProvider);
  }
  prepareJSON(data, options) {
    if (data === void 0) {
      return null;
    }
    return this.valueSchema.prepareJSON(data, options);
  }
  fromPreparedJSON(encoded) {
    if (encoded === void 0 || encoded === null) {
      return void 0;
    }
    return this.valueSchema.fromPreparedJSON(encoded);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/untyped.js
var UntypedSchema = class extends Schema {
  defaultValue() {
    return void 0;
  }
  isDefaultValue(data) {
    return data === void 0;
  }
  prepareMsgpack(data) {
    return data;
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return encoded;
  }
  prepareJSON(data, _options) {
    return msgpackEncodingDataToJSONEncodingData(data);
  }
  fromPreparedJSON(encoded) {
    return jsonEncodingDataToMsgpackEncodingData(encoded);
  }
};

// node_modules/algosdk/dist/esm/transaction.js
var import_hi_base323 = __toESM(require_base32(), 1);

// node_modules/algosdk/dist/esm/boxStorage.js
function boxReferenceToEncodingData(reference, foreignApps, appIndex) {
  const referenceId = BigInt(reference.appIndex);
  const referenceName = reference.name;
  const isOwnReference = referenceId === BigInt(0) || referenceId === appIndex;
  const index = foreignApps.indexOf(referenceId) + 1;
  if (index === 0 && !isOwnReference) {
    throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
  }
  return /* @__PURE__ */ new Map([
    ["i", index],
    ["n", referenceName]
  ]);
}
function boxReferencesToEncodingData(references, foreignApps, appIndex) {
  const appIndexBigInt = BigInt(appIndex);
  const foreignAppsBigInt = foreignApps.map(BigInt);
  return references.map((bx) => boxReferenceToEncodingData(bx, foreignAppsBigInt, appIndexBigInt));
}

// node_modules/algosdk/dist/esm/appAccess.js
function resourceReferencesToEncodingData(appIndex, references) {
  const accessList = [];
  function ensure(target) {
    for (let idx = 0; idx < accessList.length; idx++) {
      const a = accessList[idx];
      const aAddress = a.get("d");
      const addressesEqual = !target.address && !aAddress || target.address && aAddress && target.address.equals(aAddress);
      if (addressesEqual && a.get("s") === target.assetIndex && a.get("p") === target.appIndex) {
        return idx + 1;
      }
    }
    if (target.address) {
      accessList.push(/* @__PURE__ */ new Map([["d", target.address]]));
    }
    if (target.assetIndex) {
      accessList.push(/* @__PURE__ */ new Map([["s", target.assetIndex]]));
    }
    if (target.appIndex) {
      accessList.push(/* @__PURE__ */ new Map([["p", target.appIndex]]));
    }
    return accessList.length;
  }
  const zeroAddr = Address.zeroAddress();
  for (const rr of references) {
    if (rr.address || rr.assetIndex || rr.appIndex) {
      ensure(rr);
      continue;
    }
    if (rr.holding) {
      const h = rr.holding;
      let addrIdx = 0;
      if (h.address && !h.address.equals(zeroAddr)) {
        addrIdx = ensure({ address: h.address });
      }
      const assetIdx = ensure({ assetIndex: h.assetIndex });
      accessList.push(/* @__PURE__ */ new Map([
        [
          "h",
          /* @__PURE__ */ new Map([
            ["d", addrIdx],
            ["s", assetIdx]
          ])
        ]
      ]));
      continue;
    }
    if (rr.locals) {
      const l = rr.locals;
      let addrIdx = 0;
      if (l.address && !l.address.equals(zeroAddr)) {
        addrIdx = ensure({ address: l.address });
      }
      let appIdx = 0;
      if (l.appIndex && BigInt(l.appIndex) !== appIndex) {
        appIdx = ensure({ appIndex: l.appIndex });
      }
      accessList.push(/* @__PURE__ */ new Map([
        [
          "l",
          /* @__PURE__ */ new Map([
            ["d", addrIdx],
            ["p", appIdx]
          ])
        ]
      ]));
      continue;
    }
    if (rr.box) {
      const b = rr.box;
      let appIdx = 0;
      if (b.appIndex && BigInt(b.appIndex) !== appIndex) {
        appIdx = ensure({ appIndex: b.appIndex });
      }
      accessList.push(/* @__PURE__ */ new Map([
        [
          "b",
          /* @__PURE__ */ new Map([
            ["i", appIdx],
            ["n", b.name]
          ])
        ]
      ]));
    }
  }
  return accessList;
}
function convertIndicesToResourceReferences(accessList) {
  const references = [];
  for (const item of accessList) {
    const address = item.get("d");
    const assetIndex = item.get("s");
    const appIndex = item.get("p");
    if (address) {
      references.push({ address });
      continue;
    }
    if (assetIndex) {
      references.push({ assetIndex });
      continue;
    }
    if (appIndex) {
      references.push({ appIndex });
      continue;
    }
    const holding = item.get("h");
    if (holding) {
      const hAddressIndex = ensureSafeUnsignedInteger(holding.get("d") ?? 0);
      const hAssetIndex = ensureSafeUnsignedInteger(holding.get("s"));
      if (!hAssetIndex) {
        throw new Error(`Holding missing asset index: ${holding}`);
      }
      const hAddress = hAddressIndex === 0 ? Address.zeroAddress() : references[hAddressIndex - 1].address;
      const asset = references[hAssetIndex - 1].assetIndex;
      references.push({ holding: { address: hAddress, assetIndex: asset } });
      continue;
    }
    const locals = item.get("l");
    if (locals) {
      const lAddressIndex = ensureSafeUnsignedInteger(locals.get("d") ?? 0);
      const lAppIndex = ensureSafeUnsignedInteger(locals.get("p") ?? 0);
      const lAddress = lAddressIndex === 0 ? Address.zeroAddress() : references[lAddressIndex - 1].address;
      const app = lAppIndex === 0 ? BigInt(0) : references[lAppIndex - 1].appIndex;
      references.push({ locals: { address: lAddress, appIndex: app } });
      continue;
    }
    const box = item.get("b");
    if (box) {
      const bAppIndex = ensureSafeUnsignedInteger(box.get("i") ?? 0);
      const name = box.get("n");
      if (!name) {
        throw new Error(`Box missing name: ${box}`);
      }
      const app = bAppIndex === 0 ? BigInt(0) : references[bAppIndex - 1].appIndex;
      references.push({ box: { appIndex: app, name } });
    }
  }
  return references;
}
function foreignArraysToResourceReferences({ appIndex, accounts, foreignAssets, foreignApps, holdings, locals, boxes }) {
  const accessList = [];
  function ensureAddress2(addr) {
    let addr2;
    if (typeof addr === "string") {
      if (addr === "") {
        return;
      }
      addr2 = Address.fromString(addr);
    } else {
      addr2 = addr;
    }
    if (addr2.equals(Address.zeroAddress())) {
      return;
    }
    let addrFound = false;
    for (const rr of accessList) {
      if (!rr.address) {
        continue;
      }
      let rrAddress = rr.address;
      if (typeof rr.address === "string") {
        rrAddress = Address.fromString(rr.address);
      }
      if (rrAddress.equals(addr2)) {
        addrFound = true;
        break;
      }
    }
    if (!addrFound) {
      accessList.push({ address: addr });
    }
  }
  function ensureAsset(asset) {
    let assetFound = false;
    for (const rr of accessList) {
      if (rr.assetIndex === asset) {
        assetFound = true;
        break;
      }
    }
    if (!assetFound) {
      accessList.push({ assetIndex: asset });
    }
  }
  function ensureApp(app) {
    let appFound = false;
    for (const rr of accessList) {
      if (rr.appIndex === app) {
        appFound = true;
        break;
      }
    }
    if (!appFound) {
      accessList.push({ appIndex: app });
    }
  }
  for (const acct of accounts ?? []) {
    ensureAddress2(acct);
  }
  for (const asset of foreignAssets ?? []) {
    ensureAsset(asset);
  }
  for (const app of foreignApps ?? []) {
    ensureApp(app);
  }
  for (const holding of holdings ?? []) {
    if (holding.address) {
      ensureAddress2(holding.address);
    }
    ensureAsset(holding.assetIndex);
    accessList.push({ holding });
  }
  for (const local of locals ?? []) {
    if (local.address) {
      ensureAddress2(local.address);
    }
    if (local.appIndex && BigInt(local.appIndex) !== appIndex) {
      ensureApp(local.appIndex);
    }
    accessList.push({ locals: local });
  }
  for (const box of boxes ?? []) {
    if (box.appIndex && BigInt(box.appIndex) !== appIndex) {
      ensureApp(box.appIndex);
    }
    accessList.push({ box });
  }
  return accessList;
}

// node_modules/algosdk/dist/esm/types/transactions/base.js
var TransactionType;
(function(TransactionType2) {
  TransactionType2["pay"] = "pay";
  TransactionType2["keyreg"] = "keyreg";
  TransactionType2["acfg"] = "acfg";
  TransactionType2["axfer"] = "axfer";
  TransactionType2["afrz"] = "afrz";
  TransactionType2["appl"] = "appl";
  TransactionType2["stpf"] = "stpf";
  TransactionType2["hb"] = "hb";
})(TransactionType || (TransactionType = {}));
function isTransactionType(s) {
  return s === TransactionType.pay || s === TransactionType.keyreg || s === TransactionType.acfg || s === TransactionType.axfer || s === TransactionType.afrz || s === TransactionType.appl || s === TransactionType.stpf || s === TransactionType.hb;
}
var OnApplicationComplete;
(function(OnApplicationComplete2) {
  OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
  OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
  OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
  OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
  OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
  OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
})(OnApplicationComplete || (OnApplicationComplete = {}));
function isOnApplicationComplete(v) {
  return v === OnApplicationComplete.NoOpOC || v === OnApplicationComplete.OptInOC || v === OnApplicationComplete.CloseOutOC || v === OnApplicationComplete.ClearStateOC || v === OnApplicationComplete.UpdateApplicationOC || v === OnApplicationComplete.DeleteApplicationOC;
}

// node_modules/algosdk/dist/esm/stateproof.js
var HashFactory = class _HashFactory {
  constructor(params) {
    this.hashType = params.hashType;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HashFactory.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["t", this.hashType]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HashFactory: ${data}`);
    }
    return new _HashFactory({
      hashType: Number(data.get("t"))
    });
  }
};
HashFactory.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "t", valueSchema: new Uint64Schema() }
  // hashType
]));
var MerkleArrayProof = class _MerkleArrayProof {
  constructor(params) {
    this.path = params.path;
    this.hashFactory = params.hashFactory;
    this.treeDepth = params.treeDepth;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MerkleArrayProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["pth", this.path],
      ["hsh", this.hashFactory.toEncodingData()],
      ["td", this.treeDepth]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
    }
    return new _MerkleArrayProof({
      path: data.get("pth"),
      hashFactory: HashFactory.fromEncodingData(data.get("hsh")),
      treeDepth: Number(data.get("td"))
    });
  }
};
MerkleArrayProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "pth",
    // path
    valueSchema: new ArraySchema(new ByteArraySchema())
  },
  {
    key: "hsh",
    // hashFactory
    valueSchema: HashFactory.encodingSchema
  },
  {
    key: "td",
    // treeDepth
    valueSchema: new Uint64Schema()
  }
]));
var MerkleSignatureVerifier = class _MerkleSignatureVerifier {
  constructor(params) {
    this.commitment = params.commitment;
    this.keyLifetime = params.keyLifetime;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MerkleSignatureVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["cmt", this.commitment],
      ["lf", this.keyLifetime]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleSignatureVerifier: ${data}`);
    }
    return new _MerkleSignatureVerifier({
      commitment: data.get("cmt"),
      keyLifetime: data.get("lf")
    });
  }
};
MerkleSignatureVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "cmt",
    // commitment
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "lf",
    // keyLifetime
    valueSchema: new Uint64Schema()
  }
]));
var Participant = class _Participant {
  constructor(params) {
    this.pk = params.pk;
    this.weight = params.weight;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Participant.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["p", this.pk.toEncodingData()],
      ["w", this.weight]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Participant: ${data}`);
    }
    return new _Participant({
      pk: MerkleSignatureVerifier.fromEncodingData(data.get("p")),
      weight: data.get("w")
    });
  }
};
Participant.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "p",
    // pk
    valueSchema: MerkleSignatureVerifier.encodingSchema
  },
  {
    key: "w",
    // weight
    valueSchema: new Uint64Schema()
  }
]));
var FalconVerifier = class _FalconVerifier {
  constructor(params) {
    this.publicKey = params.publicKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _FalconVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["k", this.publicKey]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded FalconVerifier: ${data}`);
    }
    return new _FalconVerifier({
      publicKey: data.get("k")
    });
  }
};
FalconVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "k", valueSchema: new FixedLengthByteArraySchema(1793) }
  // publicKey
]));
var FalconSignatureStruct = class _FalconSignatureStruct {
  constructor(params) {
    this.signature = params.signature;
    this.vectorCommitmentIndex = params.index;
    this.proof = params.proof;
    this.verifyingKey = params.verifyingKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _FalconSignatureStruct.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["sig", this.signature],
      ["idx", this.vectorCommitmentIndex],
      ["prf", this.proof.toEncodingData()],
      ["vkey", this.verifyingKey.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded FalconSignatureStruct: ${data}`);
    }
    return new _FalconSignatureStruct({
      signature: data.get("sig"),
      index: data.get("idx"),
      proof: MerkleArrayProof.fromEncodingData(data.get("prf")),
      verifyingKey: FalconVerifier.fromEncodingData(data.get("vkey"))
    });
  }
};
FalconSignatureStruct.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "sig", valueSchema: new ByteArraySchema() },
  // signature
  { key: "idx", valueSchema: new Uint64Schema() },
  // index
  { key: "prf", valueSchema: MerkleArrayProof.encodingSchema },
  // proof
  { key: "vkey", valueSchema: FalconVerifier.encodingSchema }
  // verifyingKey
]));
var SigslotCommit = class _SigslotCommit {
  constructor(params) {
    this.sig = params.sig;
    this.l = params.l;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SigslotCommit.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sig.toEncodingData()],
      ["l", this.l]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SigslotCommit: ${data}`);
    }
    return new _SigslotCommit({
      sig: FalconSignatureStruct.fromEncodingData(data.get("s")),
      l: data.get("l")
    });
  }
};
SigslotCommit.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "s", valueSchema: FalconSignatureStruct.encodingSchema },
  // sigslot
  { key: "l", valueSchema: new Uint64Schema() }
  // l
]));
var Reveal = class _Reveal {
  constructor(params) {
    this.sigslot = params.sigslot;
    this.participant = params.participant;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Reveal.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sigslot.toEncodingData()],
      ["p", this.participant.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Reveal: ${data}`);
    }
    return new _Reveal({
      sigslot: SigslotCommit.fromEncodingData(data.get("s")),
      participant: Participant.fromEncodingData(data.get("p"))
    });
  }
};
Reveal.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "s", valueSchema: SigslotCommit.encodingSchema },
  // sigslotCommit
  { key: "p", valueSchema: Participant.encodingSchema }
  // participant
]));
var StateProof = class _StateProof {
  constructor(params) {
    this.sigCommit = params.sigCommit;
    this.signedWeight = params.signedWeight;
    this.sigProofs = params.sigProofs;
    this.partProofs = params.partProofs;
    this.merkleSignatureSaltVersion = params.merkleSignatureSaltVersion;
    this.reveals = params.reveals;
    this.positionsToReveal = params.positionsToReveal;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["c", this.sigCommit],
      ["w", this.signedWeight],
      ["S", this.sigProofs.toEncodingData()],
      ["P", this.partProofs.toEncodingData()],
      ["v", this.merkleSignatureSaltVersion],
      [
        "r",
        convertMap(this.reveals, (key, value) => [key, value.toEncodingData()])
      ],
      ["pr", this.positionsToReveal]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProof: ${data}`);
    }
    return new _StateProof({
      sigCommit: data.get("c"),
      signedWeight: data.get("w"),
      sigProofs: MerkleArrayProof.fromEncodingData(data.get("S")),
      partProofs: MerkleArrayProof.fromEncodingData(data.get("P")),
      merkleSignatureSaltVersion: Number(data.get("v")),
      reveals: convertMap(data.get("r"), (key, value) => [
        key,
        Reveal.fromEncodingData(value)
      ]),
      positionsToReveal: data.get("pr")
    });
  }
};
StateProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "c",
    // sigCommit
    valueSchema: new ByteArraySchema()
  },
  {
    key: "w",
    // signedWeight
    valueSchema: new Uint64Schema()
  },
  {
    key: "S",
    // sigProofs
    valueSchema: MerkleArrayProof.encodingSchema
  },
  {
    key: "P",
    // partProofs
    valueSchema: MerkleArrayProof.encodingSchema
  },
  {
    key: "v",
    // merkleSignatureSaltVersion
    valueSchema: new Uint64Schema()
  },
  {
    key: "r",
    // reveals
    valueSchema: new Uint64MapSchema(Reveal.encodingSchema)
  },
  {
    key: "pr",
    // positionsToReveal
    valueSchema: new ArraySchema(new Uint64Schema())
  }
]));
var StateProofMessage = class _StateProofMessage {
  constructor(params) {
    this.blockHeadersCommitment = params.blockHeadersCommitment;
    this.votersCommitment = params.votersCommitment;
    this.lnProvenWeight = params.lnProvenWeight;
    this.firstAttestedRound = params.firstAttestedRound;
    this.lastAttestedRound = params.lastAttestedRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofMessage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["b", this.blockHeadersCommitment],
      ["v", this.votersCommitment],
      ["P", this.lnProvenWeight],
      ["f", this.firstAttestedRound],
      ["l", this.lastAttestedRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofMessage: ${data}`);
    }
    return new _StateProofMessage({
      blockHeadersCommitment: data.get("b"),
      votersCommitment: data.get("v"),
      lnProvenWeight: data.get("P"),
      firstAttestedRound: data.get("f"),
      lastAttestedRound: data.get("l")
    });
  }
  static fromMap(data) {
    return new _StateProofMessage({
      blockHeadersCommitment: data.get("b"),
      votersCommitment: data.get("v"),
      lnProvenWeight: data.get("P"),
      firstAttestedRound: data.get("f"),
      lastAttestedRound: data.get("l")
    });
  }
};
StateProofMessage.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "b", valueSchema: new ByteArraySchema() },
  // blockHeadersCommitment
  { key: "v", valueSchema: new ByteArraySchema() },
  // votersCommitment
  { key: "P", valueSchema: new Uint64Schema() },
  // lnProvenWeight
  { key: "f", valueSchema: new Uint64Schema() },
  // firstAttestedRound
  { key: "l", valueSchema: new Uint64Schema() }
  // lastAttestedRound
]));

// node_modules/algosdk/dist/esm/heartbeat.js
var HeartbeatProof = class _HeartbeatProof {
  constructor(params) {
    this.sig = params.sig;
    this.pk = params.pk;
    this.pk2 = params.pk2;
    this.pk1Sig = params.pk1Sig;
    this.pk2Sig = params.pk2Sig;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HeartbeatProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sig],
      ["p", this.pk],
      ["p2", this.pk2],
      ["p1s", this.pk1Sig],
      ["p2s", this.pk2Sig]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HeartbeatProof: ${data}`);
    }
    return new _HeartbeatProof({
      sig: data.get("s"),
      pk: data.get("p"),
      pk2: data.get("p2"),
      pk1Sig: data.get("p1s"),
      pk2Sig: data.get("p2s")
    });
  }
};
HeartbeatProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "s",
    // Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "p",
    // PK
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "p2",
    // PK2
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "p1s",
    // PK1Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "p2s",
    // PK2Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  }
]));
var Heartbeat = class _Heartbeat {
  constructor(params) {
    this.address = params.address;
    this.proof = params.proof;
    this.seed = params.seed;
    this.voteID = params.voteID;
    this.keyDilution = params.keyDilution;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Heartbeat.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["a", this.address],
      ["prf", this.proof.toEncodingData()],
      ["sd", this.seed],
      ["vid", this.voteID],
      ["kd", this.keyDilution]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Heartbeat: ${data}`);
    }
    return new _Heartbeat({
      address: data.get("a"),
      proof: HeartbeatProof.fromEncodingData(data.get("prf")),
      seed: data.get("sd"),
      voteID: data.get("vid"),
      keyDilution: data.get("kd")
    });
  }
};
Heartbeat.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "a",
    // HbAddress
    valueSchema: new AddressSchema()
  },
  {
    key: "prf",
    // HbProof
    valueSchema: HeartbeatProof.encodingSchema
  },
  {
    key: "sd",
    // HbSeed
    valueSchema: new ByteArraySchema()
  },
  {
    key: "vid",
    // HbVoteID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "kd",
    // HbKeyDilution
    valueSchema: new Uint64Schema()
  }
]));

// node_modules/algosdk/dist/esm/transaction.js
var ALGORAND_TRANSACTION_LENGTH = 52;
var ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
var NUM_ADDL_BYTES_AFTER_SIGNING = 75;
var ASSET_METADATA_HASH_LENGTH = 32;
var KEYREG_VOTE_KEY_LENGTH = 32;
var KEYREG_SELECTION_KEY_LENGTH = 32;
var KEYREG_STATE_PROOF_KEY_LENGTH = 64;
var ALGORAND_TRANSACTION_GROUP_LENGTH = 32;
function uint8ArrayIsEmpty(input) {
  return input.every((value) => value === 0);
}
function getKeyregKey(input, inputName, length) {
  if (input == null) {
    return void 0;
  }
  let inputBytes;
  if (input instanceof Uint8Array) {
    inputBytes = input;
  }
  if (inputBytes == null || inputBytes.byteLength !== length) {
    throw Error(`${inputName} must be a ${length} byte Uint8Array`);
  }
  return inputBytes;
}
function ensureAddress(input) {
  if (input == null) {
    throw new Error("Address must not be null or undefined");
  }
  if (typeof input === "string") {
    return Address.fromString(input);
  }
  if (input instanceof Address) {
    return input;
  }
  throw new Error(`Not an address: ${input}`);
}
function optionalAddress(input) {
  if (input == null) {
    return void 0;
  }
  let addr;
  if (input instanceof Address) {
    addr = input;
  } else if (typeof input === "string") {
    addr = Address.fromString(input);
  } else {
    throw new Error(`Not an address: ${input}`);
  }
  if (uint8ArrayIsEmpty(addr.publicKey)) {
    throw new Error("Invalid use of the zero address. To omit this value, pass in undefined");
  }
  return addr;
}
function optionalUint8Array(input) {
  if (typeof input === "undefined") {
    return void 0;
  }
  if (input instanceof Uint8Array) {
    return input;
  }
  throw new Error(`Not a Uint8Array: ${input}`);
}
function ensureUint8Array2(input) {
  if (input instanceof Uint8Array) {
    return input;
  }
  throw new Error(`Not a Uint8Array: ${input}`);
}
function optionalUint64(input) {
  if (typeof input === "undefined") {
    return void 0;
  }
  return ensureUint64(input);
}
function ensureBoolean(input) {
  if (input === true || input === false) {
    return input;
  }
  throw new Error(`Not a boolean: ${input}`);
}
function ensureArray(input) {
  if (Array.isArray(input)) {
    return input.slice();
  }
  throw new Error(`Not an array: ${input}`);
}
function optionalFixedLengthByteArray(input, length, name) {
  const bytes = optionalUint8Array(input);
  if (typeof bytes === "undefined") {
    return void 0;
  }
  if (bytes.byteLength !== length) {
    throw new Error(`${name} must be ${length} bytes long, was ${bytes.byteLength}`);
  }
  if (uint8ArrayIsEmpty(bytes)) {
    return void 0;
  }
  return bytes;
}
function ensureBoxReference(input) {
  if (input != null && typeof input === "object") {
    const { appIndex, name } = input;
    return {
      appIndex: ensureUint64(appIndex),
      name: ensureUint8Array2(name)
    };
  }
  throw new Error(`Not a box reference: ${input}`);
}
function ensureHoldingReference(input) {
  if (input != null && typeof input === "object") {
    const { assetIndex, address } = input;
    return {
      assetIndex: ensureUint64(assetIndex),
      address: ensureAddress(address)
    };
  }
  throw new Error(`Not a holding reference: ${input}`);
}
function ensureLocalsReference(input) {
  if (input != null && typeof input === "object") {
    const { appIndex, address } = input;
    return {
      appIndex: ensureUint64(appIndex),
      address: ensureAddress(address)
    };
  }
  throw new Error(`Not a locals reference: ${input}`);
}
function ensureResourceReference(input) {
  if (input != null && typeof input === "object") {
    const { address, appIndex, assetIndex, holding, locals, box } = input;
    if (address !== void 0) {
      return { address: ensureAddress(address) };
    }
    if (appIndex !== void 0) {
      return { appIndex: ensureUint64(appIndex) };
    }
    if (assetIndex !== void 0) {
      return { assetIndex: ensureUint64(assetIndex) };
    }
    if (holding !== void 0) {
      return { holding: ensureHoldingReference(holding) };
    }
    if (locals !== void 0) {
      return { locals: ensureLocalsReference(locals) };
    }
    if (box !== void 0) {
      return { box: ensureBoxReference(box) };
    }
  }
  throw new Error(`Not a resource reference: ${input}`);
}
var TX_TAG = new TextEncoder().encode("TX");
var Transaction = class _Transaction {
  constructor(params) {
    if (!isTransactionType(params.type)) {
      throw new Error(`Invalid transaction type: ${params.type}`);
    }
    this.type = params.type;
    this.sender = ensureAddress(params.sender);
    this.note = ensureUint8Array2(params.note ?? new Uint8Array());
    this.lease = optionalFixedLengthByteArray(params.lease, ALGORAND_TRANSACTION_LEASE_LENGTH, "lease");
    this.rekeyTo = optionalAddress(params.rekeyTo);
    this.group = void 0;
    this.firstValid = ensureUint64(params.suggestedParams.firstValid);
    this.lastValid = ensureUint64(params.suggestedParams.lastValid);
    if (params.suggestedParams.genesisID) {
      if (typeof params.suggestedParams.genesisID !== "string") {
        throw new Error("Genesis ID must be a string if present");
      }
      this.genesisID = params.suggestedParams.genesisID;
    }
    this.genesisHash = optionalUint8Array(params.suggestedParams.genesisHash);
    const fieldsPresent = [];
    if (params.paymentParams)
      fieldsPresent.push(TransactionType.pay);
    if (params.keyregParams)
      fieldsPresent.push(TransactionType.keyreg);
    if (params.assetConfigParams)
      fieldsPresent.push(TransactionType.acfg);
    if (params.assetTransferParams)
      fieldsPresent.push(TransactionType.axfer);
    if (params.assetFreezeParams)
      fieldsPresent.push(TransactionType.afrz);
    if (params.appCallParams)
      fieldsPresent.push(TransactionType.appl);
    if (params.stateProofParams)
      fieldsPresent.push(TransactionType.stpf);
    if (params.heartbeatParams)
      fieldsPresent.push(TransactionType.hb);
    if (fieldsPresent.length !== 1) {
      throw new Error(`Transaction has wrong number of type fields present (${fieldsPresent.length}): ${fieldsPresent}`);
    }
    if (this.type !== fieldsPresent[0]) {
      throw new Error(`Transaction has type ${this.type} but fields present for ${fieldsPresent[0]}`);
    }
    if (params.paymentParams) {
      this.payment = {
        receiver: ensureAddress(params.paymentParams.receiver),
        amount: ensureUint64(params.paymentParams.amount),
        closeRemainderTo: optionalAddress(params.paymentParams.closeRemainderTo)
      };
    }
    if (params.keyregParams) {
      this.keyreg = {
        voteKey: getKeyregKey(params.keyregParams.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH),
        selectionKey: getKeyregKey(params.keyregParams.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH),
        stateProofKey: getKeyregKey(params.keyregParams.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH),
        voteFirst: optionalUint64(params.keyregParams.voteFirst),
        voteLast: optionalUint64(params.keyregParams.voteLast),
        voteKeyDilution: optionalUint64(params.keyregParams.voteKeyDilution),
        nonParticipation: ensureBoolean(params.keyregParams.nonParticipation ?? false)
      };
      if (this.keyreg.nonParticipation && (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined")) {
        throw new Error("nonParticipation is true but participation params are present.");
      }
      if (
        // If we are participating
        !this.keyreg.nonParticipation && // And *ANY* participating fields are present
        (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined") && // Then *ALL* participating fields must be present (with an exception for stateProofKey,
        // which was introduced later so for backwards compatibility we don't require it)
        !(this.keyreg.voteKey && this.keyreg.selectionKey && typeof this.keyreg.voteFirst !== "undefined" && typeof this.keyreg.voteLast !== "undefined" && typeof this.keyreg.voteKeyDilution !== "undefined")
      ) {
        throw new Error(`Online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution`);
      }
    }
    if (params.assetConfigParams) {
      this.assetConfig = {
        assetIndex: ensureUint64(params.assetConfigParams.assetIndex ?? 0),
        total: ensureUint64(params.assetConfigParams.total ?? 0),
        decimals: ensureSafeUnsignedInteger(params.assetConfigParams.decimals ?? 0),
        defaultFrozen: ensureBoolean(params.assetConfigParams.defaultFrozen ?? false),
        manager: optionalAddress(params.assetConfigParams.manager),
        reserve: optionalAddress(params.assetConfigParams.reserve),
        freeze: optionalAddress(params.assetConfigParams.freeze),
        clawback: optionalAddress(params.assetConfigParams.clawback),
        unitName: params.assetConfigParams.unitName,
        assetName: params.assetConfigParams.assetName,
        assetURL: params.assetConfigParams.assetURL,
        assetMetadataHash: optionalFixedLengthByteArray(params.assetConfigParams.assetMetadataHash, ASSET_METADATA_HASH_LENGTH, "assetMetadataHash")
      };
    }
    if (params.assetTransferParams) {
      this.assetTransfer = {
        assetIndex: ensureUint64(params.assetTransferParams.assetIndex),
        amount: ensureUint64(params.assetTransferParams.amount),
        assetSender: optionalAddress(params.assetTransferParams.assetSender),
        receiver: ensureAddress(params.assetTransferParams.receiver),
        closeRemainderTo: optionalAddress(params.assetTransferParams.closeRemainderTo)
      };
    }
    if (params.assetFreezeParams) {
      this.assetFreeze = {
        assetIndex: ensureUint64(params.assetFreezeParams.assetIndex),
        freezeAccount: ensureAddress(params.assetFreezeParams.freezeTarget),
        frozen: ensureBoolean(params.assetFreezeParams.frozen)
      };
    }
    if (params.appCallParams) {
      const { onComplete } = params.appCallParams;
      if (!isOnApplicationComplete(onComplete)) {
        throw new Error(`Invalid onCompletion value: ${onComplete}`);
      }
      this.applicationCall = {
        appIndex: ensureUint64(params.appCallParams.appIndex),
        onComplete,
        numLocalInts: ensureSafeUnsignedInteger(params.appCallParams.numLocalInts ?? 0),
        numLocalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numLocalByteSlices ?? 0),
        numGlobalInts: ensureSafeUnsignedInteger(params.appCallParams.numGlobalInts ?? 0),
        numGlobalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numGlobalByteSlices ?? 0),
        extraPages: ensureSafeUnsignedInteger(params.appCallParams.extraPages ?? 0),
        approvalProgram: ensureUint8Array2(params.appCallParams.approvalProgram ?? new Uint8Array()),
        clearProgram: ensureUint8Array2(params.appCallParams.clearProgram ?? new Uint8Array()),
        appArgs: ensureArray(params.appCallParams.appArgs ?? []).map(ensureUint8Array2),
        accounts: ensureArray(params.appCallParams.accounts ?? []).map(ensureAddress),
        foreignApps: ensureArray(params.appCallParams.foreignApps ?? []).map(ensureUint64),
        foreignAssets: ensureArray(params.appCallParams.foreignAssets ?? []).map(ensureUint64),
        boxes: ensureArray(params.appCallParams.boxes ?? []).map(ensureBoxReference),
        access: ensureArray(params.appCallParams.access ?? []).map(ensureResourceReference),
        rejectVersion: ensureSafeUnsignedInteger(params.appCallParams.rejectVersion ?? 0)
      };
    }
    if (params.stateProofParams) {
      this.stateProof = {
        stateProofType: ensureSafeUnsignedInteger(params.stateProofParams.stateProofType ?? 0),
        stateProof: params.stateProofParams.stateProof,
        message: params.stateProofParams.message
      };
    }
    if (params.heartbeatParams) {
      this.heartbeat = new Heartbeat({
        address: params.heartbeatParams.address,
        proof: params.heartbeatParams.proof,
        seed: params.heartbeatParams.seed,
        voteID: params.heartbeatParams.voteID,
        keyDilution: params.heartbeatParams.keyDilution
      });
    }
    this.fee = ensureUint64(params.suggestedParams.fee);
    const feeDependsOnSize = !ensureBoolean(params.suggestedParams.flatFee ?? false);
    if (feeDependsOnSize) {
      const minFee = ensureUint64(params.suggestedParams.minFee);
      this.fee *= BigInt(this.estimateSize());
      if (this.fee < minFee) {
        this.fee = minFee;
      }
    }
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Transaction.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["type", this.type],
      ["fv", this.firstValid],
      ["lv", this.lastValid],
      ["snd", this.sender],
      ["gen", this.genesisID],
      ["gh", this.genesisHash],
      ["fee", this.fee],
      ["note", this.note],
      ["lx", this.lease],
      ["rekey", this.rekeyTo],
      ["grp", this.group]
    ]);
    if (this.payment) {
      data.set("amt", this.payment.amount);
      data.set("rcv", this.payment.receiver);
      data.set("close", this.payment.closeRemainderTo);
      return data;
    }
    if (this.keyreg) {
      data.set("votekey", this.keyreg.voteKey);
      data.set("selkey", this.keyreg.selectionKey);
      data.set("sprfkey", this.keyreg.stateProofKey);
      data.set("votefst", this.keyreg.voteFirst);
      data.set("votelst", this.keyreg.voteLast);
      data.set("votekd", this.keyreg.voteKeyDilution);
      data.set("nonpart", this.keyreg.nonParticipation);
      return data;
    }
    if (this.assetConfig) {
      data.set("caid", this.assetConfig.assetIndex);
      const assetParams = /* @__PURE__ */ new Map([
        ["t", this.assetConfig.total],
        ["dc", this.assetConfig.decimals],
        ["df", this.assetConfig.defaultFrozen],
        ["m", this.assetConfig.manager],
        ["r", this.assetConfig.reserve],
        ["f", this.assetConfig.freeze],
        ["c", this.assetConfig.clawback],
        ["un", this.assetConfig.unitName],
        ["an", this.assetConfig.assetName],
        ["au", this.assetConfig.assetURL],
        ["am", this.assetConfig.assetMetadataHash]
      ]);
      data.set("apar", assetParams);
      return data;
    }
    if (this.assetTransfer) {
      data.set("xaid", this.assetTransfer.assetIndex);
      data.set("aamt", this.assetTransfer.amount);
      data.set("arcv", this.assetTransfer.receiver);
      data.set("aclose", this.assetTransfer.closeRemainderTo);
      data.set("asnd", this.assetTransfer.assetSender);
      return data;
    }
    if (this.assetFreeze) {
      data.set("faid", this.assetFreeze.assetIndex);
      data.set("afrz", this.assetFreeze.frozen);
      data.set("fadd", this.assetFreeze.freezeAccount);
      return data;
    }
    if (this.applicationCall) {
      data.set("apid", this.applicationCall.appIndex);
      data.set("apan", this.applicationCall.onComplete);
      data.set("apaa", this.applicationCall.appArgs);
      data.set("apat", this.applicationCall.accounts);
      data.set("apas", this.applicationCall.foreignAssets);
      data.set("apfa", this.applicationCall.foreignApps);
      data.set("apbx", boxReferencesToEncodingData(this.applicationCall.boxes, this.applicationCall.foreignApps, this.applicationCall.appIndex));
      data.set("al", resourceReferencesToEncodingData(this.applicationCall.appIndex, this.applicationCall.access));
      data.set("apap", this.applicationCall.approvalProgram);
      data.set("apsu", this.applicationCall.clearProgram);
      data.set("apls", /* @__PURE__ */ new Map([
        ["nui", this.applicationCall.numLocalInts],
        ["nbs", this.applicationCall.numLocalByteSlices]
      ]));
      data.set("apgs", /* @__PURE__ */ new Map([
        ["nui", this.applicationCall.numGlobalInts],
        ["nbs", this.applicationCall.numGlobalByteSlices]
      ]));
      data.set("apep", this.applicationCall.extraPages);
      data.set("aprv", this.applicationCall.rejectVersion);
      return data;
    }
    if (this.stateProof) {
      data.set("sptype", this.stateProof.stateProofType);
      data.set("sp", this.stateProof.stateProof ? this.stateProof.stateProof.toEncodingData() : void 0);
      data.set("spmsg", this.stateProof.message ? this.stateProof.message.toEncodingData() : void 0);
      return data;
    }
    if (this.heartbeat) {
      const heartbeat = new Heartbeat({
        address: this.heartbeat.address,
        proof: this.heartbeat.proof,
        seed: this.heartbeat.seed,
        voteID: this.heartbeat.voteID,
        keyDilution: this.heartbeat.keyDilution
      });
      data.set("hb", heartbeat.toEncodingData());
      return data;
    }
    throw new Error(`Unexpected transaction type: ${this.type}`);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig account: ${data}`);
    }
    const suggestedParams = {
      minFee: BigInt(0),
      flatFee: true,
      fee: data.get("fee") ?? 0,
      firstValid: data.get("fv") ?? 0,
      lastValid: data.get("lv") ?? 0,
      genesisHash: data.get("gh"),
      genesisID: data.get("gen")
    };
    const txnType = data.get("type");
    if (!isTransactionType(txnType)) {
      throw new Error(`Unrecognized transaction type: ${txnType}`);
    }
    const params = {
      type: txnType,
      sender: data.get("snd") ?? Address.zeroAddress(),
      note: data.get("note"),
      lease: data.get("lx"),
      suggestedParams
    };
    if (data.get("rekey")) {
      params.rekeyTo = data.get("rekey");
    }
    if (params.type === TransactionType.pay) {
      const paymentParams = {
        amount: data.get("amt") ?? 0,
        receiver: data.get("rcv") ?? Address.zeroAddress()
      };
      if (data.get("close")) {
        paymentParams.closeRemainderTo = data.get("close");
      }
      params.paymentParams = paymentParams;
    } else if (params.type === TransactionType.keyreg) {
      const keyregParams = {
        voteKey: data.get("votekey"),
        selectionKey: data.get("selkey"),
        stateProofKey: data.get("sprfkey"),
        voteFirst: data.get("votefst"),
        voteLast: data.get("votelst"),
        voteKeyDilution: data.get("votekd"),
        nonParticipation: data.get("nonpart")
      };
      params.keyregParams = keyregParams;
    } else if (params.type === TransactionType.acfg) {
      const assetConfigParams = {
        assetIndex: data.get("caid")
      };
      if (data.get("apar")) {
        const assetParams = data.get("apar");
        assetConfigParams.total = assetParams.get("t");
        assetConfigParams.decimals = assetParams.get("dc");
        assetConfigParams.defaultFrozen = assetParams.get("df");
        assetConfigParams.unitName = assetParams.get("un");
        assetConfigParams.assetName = assetParams.get("an");
        assetConfigParams.assetURL = assetParams.get("au");
        assetConfigParams.assetMetadataHash = assetParams.get("am");
        if (assetParams.get("m")) {
          assetConfigParams.manager = assetParams.get("m");
        }
        if (assetParams.get("r")) {
          assetConfigParams.reserve = assetParams.get("r");
        }
        if (assetParams.get("f")) {
          assetConfigParams.freeze = assetParams.get("f");
        }
        if (assetParams.get("c")) {
          assetConfigParams.clawback = assetParams.get("c");
        }
      }
      params.assetConfigParams = assetConfigParams;
    } else if (params.type === TransactionType.axfer) {
      const assetTransferParams = {
        assetIndex: data.get("xaid") ?? 0,
        amount: data.get("aamt") ?? 0,
        receiver: data.get("arcv") ?? Address.zeroAddress()
      };
      if (data.get("aclose")) {
        assetTransferParams.closeRemainderTo = data.get("aclose");
      }
      if (data.get("asnd")) {
        assetTransferParams.assetSender = data.get("asnd");
      }
      params.assetTransferParams = assetTransferParams;
    } else if (params.type === TransactionType.afrz) {
      const assetFreezeParams = {
        assetIndex: data.get("faid") ?? 0,
        freezeTarget: data.get("fadd") ?? Address.zeroAddress(),
        frozen: data.get("afrz") ?? false
      };
      params.assetFreezeParams = assetFreezeParams;
    } else if (params.type === TransactionType.appl) {
      const appCallParams = {
        appIndex: data.get("apid") ?? 0,
        onComplete: ensureSafeUnsignedInteger(data.get("apan") ?? 0),
        appArgs: data.get("apaa"),
        accounts: data.get("apat"),
        foreignAssets: data.get("apas"),
        foreignApps: data.get("apfa"),
        approvalProgram: data.get("apap"),
        clearProgram: data.get("apsu"),
        extraPages: data.get("apep"),
        rejectVersion: data.get("aprv") ?? 0
      };
      const localSchema = data.get("apls");
      if (localSchema) {
        appCallParams.numLocalInts = localSchema.get("nui");
        appCallParams.numLocalByteSlices = localSchema.get("nbs");
      }
      const globalSchema = data.get("apgs");
      if (globalSchema) {
        appCallParams.numGlobalInts = globalSchema.get("nui");
        appCallParams.numGlobalByteSlices = globalSchema.get("nbs");
      }
      const boxes = data.get("apbx");
      if (boxes) {
        appCallParams.boxes = boxes.map((box) => {
          const index = ensureSafeUnsignedInteger(box.get("i") ?? 0);
          const name = ensureUint8Array2(box.get("n") ?? new Uint8Array());
          if (index === 0) {
            return {
              appIndex: 0,
              name
            };
          }
          if (!appCallParams.foreignApps || index > appCallParams.foreignApps.length) {
            throw new Error(`Cannot find foreign app index ${index} in ${appCallParams.foreignApps}`);
          }
          return {
            appIndex: appCallParams.foreignApps[index - 1],
            name
          };
        });
      }
      const references = data.get("al");
      if (references) {
        appCallParams.access = convertIndicesToResourceReferences(references);
      }
      params.appCallParams = appCallParams;
    } else if (params.type === TransactionType.stpf) {
      const stateProofParams = {
        stateProofType: data.get("sptype"),
        stateProof: data.get("sp") ? StateProof.fromEncodingData(data.get("sp")) : void 0,
        message: data.get("spmsg") ? StateProofMessage.fromEncodingData(data.get("spmsg")) : void 0
      };
      params.stateProofParams = stateProofParams;
    } else if (params.type === TransactionType.hb) {
      const heartbeat = Heartbeat.fromEncodingData(data.get("hb"));
      const heartbeatParams = {
        address: heartbeat.address,
        proof: heartbeat.proof,
        seed: heartbeat.seed,
        voteID: heartbeat.voteID,
        keyDilution: heartbeat.keyDilution
      };
      params.heartbeatParams = heartbeatParams;
    } else {
      const exhaustiveCheck = params.type;
      throw new Error(`Unexpected transaction type: ${exhaustiveCheck}`);
    }
    const txn = new _Transaction(params);
    if (data.get("grp")) {
      const group = ensureUint8Array2(data.get("grp"));
      if (group.byteLength !== ALGORAND_TRANSACTION_GROUP_LENGTH) {
        throw new Error(`Invalid group length: ${group.byteLength}`);
      }
      txn.group = group;
    }
    return txn;
  }
  estimateSize() {
    return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
  }
  bytesToSign() {
    const encodedMsg = this.toByte();
    return concatArrays(TX_TAG, encodedMsg);
  }
  toByte() {
    return encodeMsgpack(this);
  }
  // returns the raw signature
  rawSignTxn(sk) {
    const toBeSigned = this.bytesToSign();
    const sig = sign(toBeSigned, sk);
    return sig;
  }
  signTxn(sk) {
    const keypair = keyPairFromSecretKey(sk);
    const signerAddr = new Address(keypair.publicKey);
    const sig = this.rawSignTxn(sk);
    return this.attachSignature(signerAddr, sig);
  }
  attachSignature(signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error("Invalid signature length");
    }
    const sTxn = /* @__PURE__ */ new Map([
      ["sig", signature],
      ["txn", this.toEncodingData()]
    ]);
    const signerAddrObj = ensureAddress(signerAddr);
    if (!this.sender.equals(signerAddrObj)) {
      sTxn.set("sgnr", signerAddrObj);
    }
    const stxnSchema = new NamedMapSchema(allOmitEmpty([
      {
        key: "txn",
        valueSchema: _Transaction.encodingSchema
      },
      {
        key: "sig",
        valueSchema: new FixedLengthByteArraySchema(64)
      },
      {
        key: "sgnr",
        valueSchema: new OptionalSchema(new AddressSchema())
      }
    ]));
    return msgpackRawEncode(stxnSchema.prepareMsgpack(sTxn));
  }
  rawTxID() {
    const enMsg = this.toByte();
    const gh = concatArrays(TX_TAG, enMsg);
    return Uint8Array.from(genericHash(gh));
  }
  txID() {
    const hash = this.rawTxID();
    return import_hi_base323.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
  }
};
Transaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
  // Common
  { key: "type", valueSchema: new StringSchema() },
  { key: "snd", valueSchema: new AddressSchema() },
  { key: "lv", valueSchema: new Uint64Schema() },
  { key: "gen", valueSchema: new OptionalSchema(new StringSchema()) },
  {
    key: "gh",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  { key: "fee", valueSchema: new Uint64Schema() },
  { key: "fv", valueSchema: new Uint64Schema() },
  { key: "note", valueSchema: new ByteArraySchema() },
  {
    key: "lx",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  { key: "rekey", valueSchema: new OptionalSchema(new AddressSchema()) },
  {
    key: "grp",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  // We mark all top-level type-specific fields optional because they will not be present when
  // the transaction is not that type.
  // Payment
  { key: "amt", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "rcv", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "close", valueSchema: new OptionalSchema(new AddressSchema()) },
  // Keyreg
  {
    key: "votekey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  {
    key: "selkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  {
    key: "sprfkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  { key: "votefst", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "votelst", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "votekd", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "nonpart", valueSchema: new OptionalSchema(new BooleanSchema()) },
  // AssetConfig
  { key: "caid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  {
    key: "apar",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      { key: "t", valueSchema: new Uint64Schema() },
      { key: "dc", valueSchema: new Uint64Schema() },
      { key: "df", valueSchema: new BooleanSchema() },
      {
        key: "m",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "r",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "f",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "c",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "un",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "an",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "au",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "am",
        valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
      }
    ])))
  },
  // AssetTransfer
  { key: "xaid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "aamt", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "arcv", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "aclose", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "asnd", valueSchema: new OptionalSchema(new AddressSchema()) },
  // AssetFreeze
  { key: "faid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "afrz", valueSchema: new OptionalSchema(new BooleanSchema()) },
  { key: "fadd", valueSchema: new OptionalSchema(new AddressSchema()) },
  // Application
  { key: "apid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "apan", valueSchema: new OptionalSchema(new Uint64Schema()) },
  {
    key: "apaa",
    valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema()))
  },
  {
    key: "apat",
    valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
  },
  {
    key: "apas",
    valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
  },
  {
    key: "apfa",
    valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
  },
  {
    key: "apbx",
    valueSchema: new OptionalSchema(new ArraySchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "i",
        valueSchema: new Uint64Schema()
      },
      {
        key: "n",
        valueSchema: new ByteArraySchema()
      }
    ]))))
  },
  {
    key: "al",
    valueSchema: new OptionalSchema(new ArraySchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "d",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "s",
        valueSchema: new OptionalSchema(new Uint64Schema())
      },
      {
        key: "p",
        valueSchema: new OptionalSchema(new Uint64Schema())
      },
      {
        key: "h",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "d",
            valueSchema: new Uint64Schema()
          },
          {
            key: "s",
            valueSchema: new Uint64Schema()
          }
        ])))
      },
      {
        key: "l",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "d",
            valueSchema: new Uint64Schema()
          },
          {
            key: "p",
            valueSchema: new Uint64Schema()
          }
        ])))
      },
      {
        key: "b",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "i",
            valueSchema: new Uint64Schema()
          },
          {
            key: "n",
            valueSchema: new ByteArraySchema()
          }
        ])))
      }
    ]))))
  },
  { key: "apap", valueSchema: new OptionalSchema(new ByteArraySchema()) },
  { key: "apsu", valueSchema: new OptionalSchema(new ByteArraySchema()) },
  {
    key: "apls",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "nui",
        valueSchema: new Uint64Schema()
      },
      {
        key: "nbs",
        valueSchema: new Uint64Schema()
      }
    ])))
  },
  {
    key: "apgs",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "nui",
        valueSchema: new Uint64Schema()
      },
      {
        key: "nbs",
        valueSchema: new Uint64Schema()
      }
    ])))
  },
  { key: "apep", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "aprv", valueSchema: new OptionalSchema(new Uint64Schema()) },
  // StateProof
  { key: "sptype", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "sp", valueSchema: new OptionalSchema(StateProof.encodingSchema) },
  {
    key: "spmsg",
    valueSchema: new OptionalSchema(StateProofMessage.encodingSchema)
  },
  // Heartbeat
  { key: "hb", valueSchema: new OptionalSchema(Heartbeat.encodingSchema) }
]));
function encodeUnsignedTransaction(transactionObject) {
  return encodeMsgpack(transactionObject);
}
function decodeUnsignedTransaction(transactionBuffer) {
  return decodeMsgpack(transactionBuffer, Transaction);
}

// node_modules/algosdk/dist/esm/multisig.js
var MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
  77,
  117,
  108,
  116,
  105,
  115,
  105,
  103,
  65,
  100,
  100,
  114
]);
var INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
var INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
var INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
var UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
function pksFromAddresses(addrs) {
  return addrs.map((addr) => {
    if (typeof addr === "string") {
      return Address.fromString(addr).publicKey;
    }
    return addr.publicKey;
  });
}
function addressFromMultisigPreImg({ version, threshold, pks }) {
  if (version !== 1 || version > 255 || version < 0) {
    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
  }
  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
  }
  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
  if (pkLen !== PUBLIC_KEY_LENGTH) {
    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
  }
  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
  for (let i = 0; i < pks.length; i++) {
    if (pks[i].length !== pkLen) {
      throw new Error(INVALID_MSIG_PK_ERROR_MSG);
    }
    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);
  }
  return new Address(Uint8Array.from(genericHash(merged)));
}
function addressFromMultisigPreImgAddrs({ version, threshold, addrs }) {
  const pks = pksFromAddresses(addrs);
  return addressFromMultisigPreImg({ version, threshold, pks });
}
function verifyMultisig(toBeVerified, msig, publicKey) {
  const version = msig.v;
  const threshold = msig.thr;
  const subsigs = msig.subsig;
  const pks = subsigs.map((subsig) => subsig.pk);
  if (msig.subsig.length < threshold) {
    return false;
  }
  let pk;
  try {
    pk = addressFromMultisigPreImg({ version, threshold, pks }).publicKey;
  } catch (e) {
    return false;
  }
  if (!arrayEqual(pk, publicKey)) {
    return false;
  }
  let counter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      counter += 1;
    }
  }
  if (counter < threshold) {
    return false;
  }
  let verifiedCounter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      if (verify(toBeVerified, subsig.s, subsig.pk)) {
        verifiedCounter += 1;
      }
    }
  }
  if (verifiedCounter < threshold) {
    return false;
  }
  return true;
}
function multisigAddress({ version, threshold, addrs }) {
  return addressFromMultisigPreImgAddrs({ version, threshold, addrs });
}

// node_modules/algosdk/dist/esm/types/transactions/encoded.js
var ENCODED_SUBSIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
  {
    key: "pk",
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "s",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  }
]));
function encodedSubsigFromEncodingData(data) {
  if (!(data instanceof Map)) {
    throw new Error(`Invalid decoded EncodedSubsig: ${data}`);
  }
  const subsig = {
    pk: data.get("pk")
  };
  if (data.get("s")) {
    subsig.s = data.get("s");
  }
  return subsig;
}
function encodedSubsigToEncodingData(subsig) {
  const data = /* @__PURE__ */ new Map([["pk", subsig.pk]]);
  if (subsig.s) {
    data.set("s", subsig.s);
  }
  return data;
}
var ENCODED_MULTISIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
  {
    key: "v",
    valueSchema: new Uint64Schema()
  },
  {
    key: "thr",
    valueSchema: new Uint64Schema()
  },
  {
    key: "subsig",
    valueSchema: new ArraySchema(ENCODED_SUBSIG_SCHEMA)
  }
]));
function encodedMultiSigFromEncodingData(data) {
  if (!(data instanceof Map)) {
    throw new Error(`Invalid decoded EncodedMultiSig: ${data}`);
  }
  return {
    v: ensureSafeUnsignedInteger(data.get("v")),
    thr: ensureSafeUnsignedInteger(data.get("thr")),
    subsig: data.get("subsig").map(encodedSubsigFromEncodingData)
  };
}
function encodedMultiSigToEncodingData(msig) {
  return /* @__PURE__ */ new Map([
    ["v", msig.v],
    ["thr", msig.thr],
    ["subsig", msig.subsig.map(encodedSubsigToEncodingData)]
  ]);
}

// node_modules/algosdk/dist/esm/logicsig.js
var base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
function sanityCheckProgram(program) {
  if (!program || program.length === 0)
    throw new Error("empty program");
  const lineBreakOrd = "\n".charCodeAt(0);
  const blankSpaceOrd = " ".charCodeAt(0);
  const tildeOrd = "~".charCodeAt(0);
  const isPrintable = (x) => blankSpaceOrd <= x && x <= tildeOrd;
  const isAsciiPrintable = program.every((x) => x === lineBreakOrd || isPrintable(x));
  if (isAsciiPrintable) {
    const programStr = new TextDecoder().decode(program);
    if (isValidAddress(programStr))
      throw new Error("requesting program bytes, get Algorand address");
    if (base64regex.test(programStr))
      throw new Error("program should not be b64 encoded");
    throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
var programTag = new TextEncoder().encode("Program");
var multisigProgramTag = new TextEncoder().encode("MsigProgram");
var LogicSig = class _LogicSig {
  constructor(program, programArgs) {
    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array))) {
      throw new TypeError("Invalid arguments");
    }
    let args = [];
    if (programArgs != null)
      args = programArgs.map((arg) => new Uint8Array(arg));
    sanityCheckProgram(program);
    this.logic = program;
    this.args = args;
    this.sig = void 0;
    this.msig = void 0;
    this.lmsig = void 0;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LogicSig.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["l", this.logic],
      ["arg", this.args],
      ["sig", this.sig]
    ]);
    if (this.msig) {
      data.set("msig", encodedMultiSigToEncodingData(this.msig));
    }
    if (this.lmsig) {
      data.set("lmsig", encodedMultiSigToEncodingData(this.lmsig));
    }
    return data;
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig: ${data}`);
    }
    const lsig = new _LogicSig(data.get("l"), data.get("arg"));
    lsig.sig = data.get("sig");
    if (data.get("msig")) {
      lsig.msig = encodedMultiSigFromEncodingData(data.get("msig"));
    }
    if (data.get("lmsig")) {
      lsig.lmsig = encodedMultiSigFromEncodingData(data.get("lmsig"));
    }
    return lsig;
  }
  /**
   * Performs signature verification
   * @param publicKey - Verification key (derived from sender address or escrow address)
   */
  verify(publicKey) {
    const sigCount = [this.sig, this.msig, this.lmsig].filter(Boolean).length;
    if (sigCount > 1) {
      return false;
    }
    try {
      sanityCheckProgram(this.logic);
    } catch (e) {
      return false;
    }
    const toBeSigned = concatArrays(programTag, this.logic);
    if (!this.sig && !this.msig && !this.lmsig) {
      const hash = genericHash(toBeSigned);
      return arrayEqual(hash, publicKey);
    }
    if (this.sig) {
      return verify(toBeSigned, this.sig, publicKey);
    }
    if (this.lmsig) {
      const multisigAddr = addressFromMultisigPreImg({
        version: this.lmsig.v,
        threshold: this.lmsig.thr,
        pks: this.lmsig.subsig.map((subsig) => subsig.pk)
      });
      const lmsigProgram = concatArrays(multisigProgramTag, multisigAddr.publicKey, this.logic);
      return verifyMultisig(lmsigProgram, this.lmsig, publicKey);
    }
    if (this.msig) {
      return verifyMultisig(toBeSigned, this.msig, publicKey);
    }
    return false;
  }
  /**
   * Compute hash of the logic sig program (that is the same as escrow account address) as string address
   * @returns String representation of the address
   */
  address() {
    const toBeSigned = concatArrays(programTag, this.logic);
    const hash = genericHash(toBeSigned);
    return new Address(Uint8Array.from(hash));
  }
  /**
   * Creates signature (if no msig provided) or multi signature otherwise
   * @param secretKey - Secret key to sign with
   * @param msig - Multisig account as \{version, threshold, addrs\}
   */
  sign(secretKey, msig) {
    if (msig == null) {
      this.sig = this.signProgram(secretKey);
    } else {
      const subsigs = pksFromAddresses(msig.addrs).map((pk) => ({ pk }));
      this.lmsig = {
        v: msig.version,
        thr: msig.threshold,
        subsig: subsigs
      };
      const [sig, index] = this.singleSignMultisig(secretKey, this.lmsig);
      this.lmsig.subsig[index].s = sig;
    }
  }
  /**
   * Appends a signature to multi signature
   * @param secretKey - Secret key to sign with
   */
  appendToMultisig(secretKey) {
    if (this.lmsig === void 0) {
      throw new Error("no multisig present");
    }
    const [sig, index] = this.singleSignMultisig(secretKey, this.lmsig);
    this.lmsig.subsig[index].s = sig;
  }
  signProgram(secretKey) {
    const toBeSigned = concatArrays(programTag, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  signProgramMultisig(secretKey, msig) {
    const multisigAddr = addressFromMultisigPreImg({
      version: msig.v,
      threshold: msig.thr,
      pks: msig.subsig.map((subsig) => subsig.pk)
    });
    const toBeSigned = concatArrays(multisigProgramTag, multisigAddr.publicKey, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  singleSignMultisig(secretKey, msig) {
    let index = -1;
    const myPk = keyPairFromSecretKey(secretKey).publicKey;
    for (let i = 0; i < msig.subsig.length; i++) {
      const { pk } = msig.subsig[i];
      if (arrayEqual(pk, myPk)) {
        index = i;
        break;
      }
    }
    if (index === -1) {
      throw new Error("invalid secret key");
    }
    const sig = this.signProgramMultisig(secretKey, msig);
    return [sig, index];
  }
  toByte() {
    return encodeMsgpack(this);
  }
  static fromByte(encoded) {
    return decodeMsgpack(encoded, _LogicSig);
  }
};
LogicSig.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "l",
    valueSchema: new ByteArraySchema()
  },
  {
    key: "arg",
    valueSchema: new ArraySchema(new ByteArraySchema())
  },
  {
    key: "sig",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  {
    key: "msig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  },
  {
    key: "lmsig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  }
]));
var LogicSigAccount = class _LogicSigAccount {
  /**
   * Create a new LogicSigAccount. By default this will create an escrow
   * LogicSig account. Call `sign` or `signMultisig` on the newly created
   * LogicSigAccount to make it a delegated account.
   *
   * @param program - The compiled TEAL program which contains the logic for
   *   this LogicSig.
   * @param args - An optional array of arguments for the program.
   */
  constructor(program, args) {
    this.lsig = new LogicSig(program, args);
    this.sigkey = void 0;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LogicSigAccount.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["lsig", this.lsig.toEncodingData()],
      ["sigkey", this.sigkey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig account: ${data}`);
    }
    const value = data;
    const lsig = LogicSig.fromEncodingData(value.get("lsig"));
    const lsigAccount = new _LogicSigAccount(lsig.logic, lsig.args);
    lsigAccount.lsig = lsig;
    lsigAccount.sigkey = value.get("sigkey");
    return lsigAccount;
  }
  /**
   * Encode this object into msgpack.
   */
  toByte() {
    return encodeMsgpack(this);
  }
  /**
   * Decode a msgpack object into a LogicSigAccount.
   * @param encoded - The encoded LogicSigAccount.
   */
  static fromByte(encoded) {
    return decodeMsgpack(encoded, _LogicSigAccount);
  }
  /**
   * Check if this LogicSigAccount has been delegated to another account with a
   * signature.
   *
   * Note this function only checks for the presence of a delegation signature.
   * To verify the delegation signature, use `verify`.
   */
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig || this.lsig.lmsig);
  }
  /**
   * Verifies this LogicSig's program and signatures.
   * @returns true if and only if the LogicSig program and signatures are valid.
   */
  verify() {
    const addr = this.address();
    return this.lsig.verify(addr.publicKey);
  }
  /**
   * Get the address of this LogicSigAccount.
   *
   * If the LogicSig is delegated to another account, this will return the
   * address of that account.
   *
   * If the LogicSig is not delegated to another account, this will return an
   *  escrow address that is the hash of the LogicSig's program code.
   */
  address() {
    const sigCount = [this.lsig.sig, this.lsig.msig, this.lsig.lmsig].filter(Boolean).length;
    if (sigCount > 1) {
      throw new Error("LogicSig has too many signatures. At most one of sig, msig, or lmsig may be present");
    }
    if (this.lsig.sig) {
      if (!this.sigkey) {
        throw new Error("Signing key for delegated account is missing");
      }
      return new Address(this.sigkey);
    }
    const msig = this.lsig.lmsig || this.lsig.msig;
    if (msig) {
      const msigMetadata = {
        version: msig.v,
        threshold: msig.thr,
        pks: msig.subsig.map((subsig) => subsig.pk)
      };
      return addressFromMultisigPreImg(msigMetadata);
    }
    return this.lsig.address();
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. Use this function if the delegating account is a
   * multisig account.
   *
   * @param msig - The multisig delegating account
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account. Use `appendToMultisig` to add additional signatures
   *   from other members.
   */
  signMultisig(msig, secretKey) {
    this.lsig.sign(secretKey, msig);
  }
  /**
   * Adds an additional signature from a member of the delegating multisig
   * account.
   *
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account.
   */
  appendToMultisig(secretKey) {
    this.lsig.appendToMultisig(secretKey);
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. If the delegating account is a multisig account,
   * use `signMultisig` instead.
   *
   * @param secretKey - The secret key of the delegating account.
   */
  sign(secretKey) {
    this.lsig.sign(secretKey);
    this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
  }
};
LogicSigAccount.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "lsig",
    valueSchema: LogicSig.encodingSchema
  },
  {
    key: "sigkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  }
]));
function logicSigFromByte(encoded) {
  return decodeMsgpack(encoded, LogicSig);
}
var SIGN_PROGRAM_DATA_PREFIX = new TextEncoder().encode("ProgData");
function tealSign(sk, data, programHash) {
  const programAddr = typeof programHash === "string" ? Address.fromString(programHash) : programHash;
  const parts = concatArrays(programAddr.publicKey, data);
  const toBeSigned = concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts);
  return sign(toBeSigned, sk);
}
function verifyTealSign(data, programHash, sig, pk) {
  const programAddr = typeof programHash === "string" ? Address.fromString(programHash) : programHash;
  const parts = concatArrays(programAddr.publicKey, data);
  const toBeSigned = concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts);
  return verify(toBeSigned, sig, pk);
}
function tealSignFromProgram(sk, data, program) {
  const lsig = new LogicSig(program);
  const contractAddress = lsig.address();
  return tealSign(sk, data, contractAddress);
}

// node_modules/algosdk/dist/esm/signedTransaction.js
var SignedTransaction = class _SignedTransaction {
  constructor({ txn, sig, msig, lsig, sgnr }) {
    this.txn = txn;
    this.sig = sig;
    this.msig = msig;
    this.lsig = lsig;
    this.sgnr = sgnr;
    let numberOfSigs = 0;
    if (sig)
      numberOfSigs += 1;
    if (msig)
      numberOfSigs += 1;
    if (lsig)
      numberOfSigs += 1;
    if (numberOfSigs > 1) {
      throw new Error(`SignedTransaction must not have more than 1 signature. Got ${numberOfSigs}`);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SignedTransaction.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn", this.txn.toEncodingData()],
      ["sig", this.sig],
      [
        "msig",
        this.msig ? encodedMultiSigToEncodingData(this.msig) : void 0
      ],
      ["lsig", this.lsig ? this.lsig.toEncodingData() : void 0],
      ["sgnr", this.sgnr]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTransaction: ${data}`);
    }
    return new _SignedTransaction({
      txn: Transaction.fromEncodingData(data.get("txn")),
      sig: data.get("sig"),
      msig: data.get("msig") ? encodedMultiSigFromEncodingData(data.get("msig")) : void 0,
      lsig: data.get("lsig") ? LogicSig.fromEncodingData(data.get("lsig")) : void 0,
      sgnr: data.get("sgnr")
    });
  }
};
SignedTransaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "txn",
    valueSchema: Transaction.encodingSchema
  },
  {
    key: "sig",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  {
    key: "msig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  },
  {
    key: "lsig",
    valueSchema: new OptionalSchema(LogicSig.encodingSchema)
  },
  {
    key: "sgnr",
    valueSchema: new OptionalSchema(new AddressSchema())
  }
]));
function decodeSignedTransaction(transactionBuffer) {
  return decodeMsgpack(transactionBuffer, SignedTransaction);
}
function encodeUnsignedSimulateTransaction(txn) {
  const stxn = new SignedTransaction({ txn });
  return encodeMsgpack(stxn);
}

// node_modules/algosdk/dist/esm/types/block.js
var StateProofTrackingData = class _StateProofTrackingData {
  constructor(params) {
    this.stateProofVotersCommitment = params.stateProofVotersCommitment;
    this.stateProofOnlineTotalWeight = params.stateProofOnlineTotalWeight;
    this.stateProofNextRound = params.stateProofNextRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofTrackingData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["v", this.stateProofVotersCommitment],
      ["t", this.stateProofOnlineTotalWeight],
      ["n", this.stateProofNextRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofTrackingData: ${data}`);
    }
    return new _StateProofTrackingData({
      stateProofVotersCommitment: data.get("v"),
      stateProofOnlineTotalWeight: data.get("t"),
      stateProofNextRound: data.get("n")
    });
  }
};
StateProofTrackingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "v",
    // stateProofVotersCommitment
    valueSchema: new ByteArraySchema()
  },
  {
    key: "t",
    // stateProofOnlineTotalWeight
    valueSchema: new Uint64Schema()
  },
  {
    key: "n",
    // stateProofNextRound
    valueSchema: new Uint64Schema()
  }
]));
var TxnCommitments = class _TxnCommitments {
  constructor(params) {
    this.nativeSha512_256Commitment = params.nativeSha512_256Commitment;
    this.sha256Commitment = params.sha256Commitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TxnCommitments.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn", this.nativeSha512_256Commitment],
      ["txn256", this.sha256Commitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TxnCommitments: ${data}`);
    }
    return new _TxnCommitments({
      nativeSha512_256Commitment: data.get("txn"),
      sha256Commitment: data.get("txn256")
    });
  }
};
TxnCommitments.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "txn",
    // nativeSha512_256Commitment
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "txn256",
    // sha256Commitment
    valueSchema: new FixedLengthByteArraySchema(32)
  }
]));
var RewardState = class _RewardState {
  constructor(params) {
    this.feeSink = params.feeSink;
    this.rewardsPool = params.rewardsPool;
    this.rewardsLevel = params.rewardsLevel;
    this.rewardsRate = params.rewardsRate;
    this.rewardsResidue = params.rewardsResidue;
    this.rewardsRecalculationRound = params.rewardsRecalculationRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _RewardState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["fees", this.feeSink],
      ["rwd", this.rewardsPool],
      ["earn", this.rewardsLevel],
      ["rate", this.rewardsRate],
      ["frac", this.rewardsResidue],
      ["rwcalr", this.rewardsRecalculationRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded RewardState: ${data}`);
    }
    return new _RewardState({
      feeSink: data.get("fees"),
      rewardsPool: data.get("rwd"),
      rewardsLevel: data.get("earn"),
      rewardsRate: data.get("rate"),
      rewardsResidue: data.get("frac"),
      rewardsRecalculationRound: data.get("rwcalr")
    });
  }
};
RewardState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "fees",
    // feeSink
    valueSchema: new AddressSchema()
  },
  {
    key: "rwd",
    // rewardsPool
    valueSchema: new AddressSchema()
  },
  {
    key: "earn",
    // rewardsLevel
    valueSchema: new Uint64Schema()
  },
  {
    key: "rate",
    // rewardsRate
    valueSchema: new Uint64Schema()
  },
  {
    key: "frac",
    // rewardsResidue
    valueSchema: new Uint64Schema()
  },
  {
    key: "rwcalr",
    // rewardsRecalculationRound
    valueSchema: new Uint64Schema()
  }
]));
var UpgradeState = class _UpgradeState {
  constructor(params) {
    this.currentProtocol = params.currentProtocol;
    this.nextProtocol = params.nextProtocol;
    this.nextProtocolApprovals = params.nextProtocolApprovals;
    this.nextProtocolVoteBefore = params.nextProtocolVoteBefore;
    this.nextProtocolSwitchOn = params.nextProtocolSwitchOn;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _UpgradeState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["proto", this.currentProtocol],
      ["nextproto", this.nextProtocol],
      ["nextyes", this.nextProtocolApprovals],
      ["nextbefore", this.nextProtocolVoteBefore],
      ["nextswitch", this.nextProtocolSwitchOn]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded UpgradeState: ${data}`);
    }
    return new _UpgradeState({
      currentProtocol: data.get("proto"),
      nextProtocol: data.get("nextproto"),
      nextProtocolApprovals: data.get("nextyes"),
      nextProtocolVoteBefore: data.get("nextbefore"),
      nextProtocolSwitchOn: data.get("nextswitch")
    });
  }
};
UpgradeState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "proto",
    // currentProtocol
    valueSchema: new StringSchema()
  },
  {
    key: "nextproto",
    // nextProtocol
    valueSchema: new StringSchema()
  },
  {
    key: "nextyes",
    // nextProtocolApprovals
    valueSchema: new Uint64Schema()
  },
  {
    key: "nextbefore",
    // nextProtocolVoteBefore
    valueSchema: new Uint64Schema()
  },
  {
    key: "nextswitch",
    // nextProtocolSwitchOn
    valueSchema: new Uint64Schema()
  }
]));
var UpgradeVote = class _UpgradeVote {
  constructor(params) {
    this.upgradePropose = params.upgradePropose;
    this.upgradeDelay = params.upgradeDelay;
    this.upgradeApprove = params.upgradeApprove;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _UpgradeVote.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["upgradeprop", this.upgradePropose],
      ["upgradedelay", this.upgradeDelay],
      ["upgradeyes", this.upgradeApprove]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded UpgradeVote: ${data}`);
    }
    return new _UpgradeVote({
      upgradePropose: data.get("upgradeprop"),
      upgradeDelay: data.get("upgradedelay"),
      upgradeApprove: data.get("upgradeyes")
    });
  }
};
UpgradeVote.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "upgradeprop",
    // upgradePropose
    valueSchema: new StringSchema()
  },
  {
    key: "upgradedelay",
    // upgradeDelay
    valueSchema: new Uint64Schema()
  },
  {
    key: "upgradeyes",
    // upgradeApprove
    valueSchema: new BooleanSchema()
  }
]));
var ParticipationUpdates = class _ParticipationUpdates {
  constructor(params) {
    this.expiredParticipationAccounts = params.expiredParticipationAccounts;
    this.absentParticipationAccounts = params.absentParticipationAccounts;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ParticipationUpdates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["partupdrmv", this.expiredParticipationAccounts],
      ["partupdabs", this.absentParticipationAccounts]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
    }
    return new _ParticipationUpdates({
      expiredParticipationAccounts: data.get("partupdrmv"),
      absentParticipationAccounts: data.get("partupdabs")
    });
  }
};
ParticipationUpdates.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "partupdrmv",
    // expiredParticipationAccounts
    valueSchema: new ArraySchema(new AddressSchema())
  },
  {
    key: "partupdabs",
    // absentParticipationAccounts
    valueSchema: new ArraySchema(new AddressSchema())
  }
]));
var BlockHeader = class _BlockHeader {
  constructor(params) {
    this.round = params.round;
    this.branch = params.branch;
    this.seed = params.seed;
    this.txnCommitments = params.txnCommitments;
    this.timestamp = params.timestamp;
    this.genesisID = params.genesisID;
    this.genesisHash = params.genesisHash;
    this.proposer = params.proposer;
    this.feesCollected = params.feesCollected;
    this.bonus = params.bonus;
    this.proposerPayout = params.proposerPayout;
    this.rewardState = params.rewardState;
    this.upgradeState = params.upgradeState;
    this.upgradeVote = params.upgradeVote;
    this.txnCounter = params.txnCounter;
    this.stateproofTracking = params.stateproofTracking;
    this.participationUpdates = params.participationUpdates;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockHeader.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["rnd", this.round],
      ["prev", this.branch],
      ["seed", this.seed],
      ["ts", this.timestamp],
      ["gen", this.genesisID],
      ["gh", this.genesisHash],
      ["prp", this.proposer],
      ["fc", this.feesCollected],
      ["bi", this.bonus],
      ["pp", this.proposerPayout],
      ["tc", this.txnCounter],
      [
        "spt",
        convertMap(this.stateproofTracking, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ]
    ]);
    return combineMaps(data, this.txnCommitments.toEncodingData(), this.rewardState.toEncodingData(), this.upgradeState.toEncodingData(), this.upgradeVote.toEncodingData(), this.participationUpdates.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHeader: ${data}`);
    }
    return new _BlockHeader({
      round: data.get("rnd"),
      branch: data.get("prev"),
      seed: data.get("seed"),
      txnCommitments: TxnCommitments.fromEncodingData(data),
      timestamp: data.get("ts"),
      genesisID: data.get("gen"),
      genesisHash: data.get("gh"),
      proposer: data.get("prp"),
      feesCollected: data.get("fc"),
      bonus: data.get("bi"),
      proposerPayout: data.get("pp"),
      rewardState: RewardState.fromEncodingData(data),
      upgradeState: UpgradeState.fromEncodingData(data),
      upgradeVote: UpgradeVote.fromEncodingData(data),
      txnCounter: data.get("tc"),
      stateproofTracking: convertMap(data.get("spt"), (key, value) => [
        Number(key),
        StateProofTrackingData.fromEncodingData(value)
      ]),
      participationUpdates: ParticipationUpdates.fromEncodingData(data)
    });
  }
};
BlockHeader.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "rnd",
    // round
    valueSchema: new Uint64Schema()
  },
  {
    key: "prev",
    // branch
    valueSchema: new BlockHashSchema()
  },
  {
    key: "seed",
    // seed
    valueSchema: new ByteArraySchema()
  },
  {
    key: "",
    valueSchema: TxnCommitments.encodingSchema,
    embedded: true
  },
  {
    key: "ts",
    // timestamp
    valueSchema: new Uint64Schema()
  },
  {
    key: "gen",
    // genesisID
    valueSchema: new StringSchema()
  },
  {
    key: "gh",
    // genesisHash
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "prp",
    // proposer
    valueSchema: new AddressSchema()
  },
  {
    key: "fc",
    // feesCollected
    valueSchema: new Uint64Schema()
  },
  {
    key: "bi",
    // bonus
    valueSchema: new Uint64Schema()
  },
  {
    key: "pp",
    // proposerPayout
    valueSchema: new Uint64Schema()
  },
  {
    key: "",
    valueSchema: RewardState.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: UpgradeState.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: UpgradeVote.encodingSchema,
    embedded: true
  },
  {
    key: "tc",
    // txnCounter
    valueSchema: new Uint64Schema()
  },
  {
    key: "spt",
    // stateproofTracking
    valueSchema: new Uint64MapSchema(StateProofTrackingData.encodingSchema)
  },
  {
    key: "",
    valueSchema: ParticipationUpdates.encodingSchema,
    embedded: true
  }
]));
var ValueDelta = class _ValueDelta {
  constructor(params) {
    this.action = params.action;
    this.bytes = params.bytes;
    this.uint = params.uint;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ValueDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["at", this.action],
      ["bs", this.bytes],
      ["ui", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ValueDelta: ${data}`);
    }
    return new _ValueDelta({
      action: Number(data.get("at")),
      bytes: data.get("bs"),
      uint: data.get("ui")
    });
  }
};
ValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "at",
    // action
    valueSchema: new Uint64Schema()
  },
  {
    key: "bs",
    // bytes
    valueSchema: new SpecialCaseBinaryStringSchema()
  },
  {
    key: "ui",
    // uint
    valueSchema: new Uint64Schema()
  }
]));
var EvalDelta = class _EvalDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "gd",
          // globalDelta
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema))
        },
        {
          key: "ld",
          // localDeltas
          valueSchema: new OptionalSchema(new Uint64MapSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)))
        },
        {
          key: "sa",
          // sharedAccts
          valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
        },
        {
          key: "lg",
          // logs
          valueSchema: new OptionalSchema(new ArraySchema(new SpecialCaseBinaryStringSchema()))
        },
        {
          key: "itx",
          // innerTxns
          valueSchema: new OptionalSchema(
            // eslint-disable-next-line no-use-before-define
            new ArraySchema(SignedTxnWithAD.encodingSchema)
          )
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.globalDelta = params.globalDelta ?? /* @__PURE__ */ new Map();
    this.localDeltas = params.localDeltas ?? /* @__PURE__ */ new Map();
    this.sharedAccts = params.sharedAccts ?? [];
    this.logs = params.logs ?? [];
    this.innerTxns = params.innerTxns ?? [];
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "gd",
        convertMap(this.globalDelta, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ],
      [
        "ld",
        convertMap(this.localDeltas, (key, value) => [
          key,
          convertMap(value, (k, v) => [k, v.toEncodingData()])
        ])
      ],
      ["sa", this.sharedAccts],
      ["lg", this.logs],
      ["itx", this.innerTxns.map((t) => t.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDelta: ${data}`);
    }
    return new _EvalDelta({
      globalDelta: data.get("gd") ? convertMap(data.get("gd"), (key, value) => [key, ValueDelta.fromEncodingData(value)]) : void 0,
      localDeltas: data.get("ld") ? convertMap(data.get("ld"), (key, value) => [
        Number(key),
        convertMap(value, (k, v) => [k, ValueDelta.fromEncodingData(v)])
      ]) : void 0,
      sharedAccts: data.get("sa"),
      logs: data.get("lg"),
      // eslint-disable-next-line no-use-before-define
      innerTxns: (data.get("itx") ?? []).map(SignedTxnWithAD.fromEncodingData)
    });
  }
};
var ApplyData = class _ApplyData {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "ca",
          // closingAmount
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "aca",
          // assetClosingAmount
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rs",
          // senderRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rr",
          // receiverRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rc",
          // closeRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "dt",
          // evalDelta
          valueSchema: new OptionalSchema(EvalDelta.encodingSchema)
        },
        {
          key: "caid",
          // configAsset
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "apid",
          // applicationID
          valueSchema: new OptionalSchema(new Uint64Schema())
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.closingAmount = params.closingAmount;
    this.assetClosingAmount = params.assetClosingAmount;
    this.senderRewards = params.senderRewards;
    this.receiverRewards = params.receiverRewards;
    this.closeRewards = params.closeRewards;
    this.evalDelta = params.evalDelta;
    this.configAsset = params.configAsset;
    this.applicationID = params.applicationID;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplyData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["ca", this.closingAmount],
      ["aca", this.assetClosingAmount],
      ["rs", this.senderRewards],
      ["rr", this.receiverRewards],
      ["rc", this.closeRewards],
      ["dt", this.evalDelta ? this.evalDelta.toEncodingData() : void 0],
      ["caid", this.configAsset],
      ["apid", this.applicationID]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplyData: ${data}`);
    }
    return new _ApplyData({
      closingAmount: data.get("ca"),
      assetClosingAmount: data.get("aca"),
      senderRewards: data.get("rs"),
      receiverRewards: data.get("rr"),
      closeRewards: data.get("rc"),
      evalDelta: data.get("dt") ? EvalDelta.fromEncodingData(data.get("dt")) : void 0,
      configAsset: data.get("caid"),
      applicationID: data.get("apid")
    });
  }
};
var SignedTxnWithAD = class _SignedTxnWithAD {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "",
          valueSchema: SignedTransaction.encodingSchema,
          embedded: true
        },
        {
          key: "",
          valueSchema: ApplyData.encodingSchema,
          embedded: true
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.signedTxn = params.signedTxn;
    this.applyData = params.applyData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SignedTxnWithAD.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(this.signedTxn.toEncodingData(), this.applyData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTxnWithAD: ${data}`);
    }
    return new _SignedTxnWithAD({
      signedTxn: SignedTransaction.fromEncodingData(data),
      applyData: ApplyData.fromEncodingData(data)
    });
  }
};
var SignedTxnInBlock = class _SignedTxnInBlock {
  constructor(params) {
    this.signedTxn = params.signedTxn;
    this.hasGenesisID = params.hasGenesisID;
    this.hasGenesisHash = params.hasGenesisHash;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SignedTxnInBlock.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["hgi", this.hasGenesisID],
      ["hgh", this.hasGenesisHash]
    ]);
    return combineMaps(data, this.signedTxn.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTxnInBlock: ${data}`);
    }
    return new _SignedTxnInBlock({
      signedTxn: SignedTxnWithAD.fromEncodingData(data),
      hasGenesisID: data.get("hgi"),
      hasGenesisHash: data.get("hgh")
    });
  }
};
SignedTxnInBlock.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: SignedTxnWithAD.encodingSchema,
    embedded: true
  },
  {
    key: "hgi",
    // hasGenesisID
    valueSchema: new BooleanSchema()
  },
  {
    key: "hgh",
    // hasGenesisHash
    valueSchema: new BooleanSchema()
  }
]));
var Block = class _Block {
  constructor(params) {
    this.header = params.header;
    this.payset = params.payset;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Block.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["txns", this.payset.map((p) => p.toEncodingData())]
    ]);
    return combineMaps(data, this.header.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHeader: ${data}`);
    }
    return new _Block({
      header: BlockHeader.fromEncodingData(data),
      payset: data.get("txns").map(SignedTxnInBlock.fromEncodingData)
    });
  }
};
Block.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: BlockHeader.encodingSchema,
    embedded: true
  },
  {
    key: "txns",
    // payset
    valueSchema: new ArraySchema(SignedTxnInBlock.encodingSchema)
  }
]));

// node_modules/algosdk/dist/esm/client/v2/untypedmodel.js
var UntypedValue = class _UntypedValue {
  constructor(data) {
    this.data = data;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _UntypedValue.encodingSchema;
  }
  toEncodingData() {
    return this.data;
  }
  static fromEncodingData(data) {
    return new _UntypedValue(data);
  }
};
UntypedValue.encodingSchema = new UntypedSchema();

// node_modules/algosdk/dist/esm/types/statedelta.js
var TealValue = class _TealValue {
  constructor(params) {
    this.type = params.type;
    this.bytes = params.bytes;
    this.uint = params.uint;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["tt", this.type],
      ["tb", this.bytes],
      ["ui", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealValue: ${data}`);
    }
    return new _TealValue({
      type: Number(data.get("tt")),
      bytes: data.get("tb"),
      uint: data.get("ui")
    });
  }
};
TealValue.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "tt", valueSchema: new Uint64Schema() },
  // type
  {
    key: "tb",
    // bytes
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  { key: "ui", valueSchema: new OptionalSchema(new Uint64Schema()) }
  // uint
]));
var StateSchema = class _StateSchema {
  constructor(params) {
    this.numUints = params.numUints;
    this.numByteSlices = params.numByteSlices;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["nui", this.numUints],
      ["nbs", this.numByteSlices]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateSchema: ${data}`);
    }
    return new _StateSchema({
      numUints: Number(data.get("nui")),
      numByteSlices: Number(data.get("nbs"))
    });
  }
};
StateSchema.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "nui",
    // numUints
    valueSchema: new Uint64Schema()
  },
  {
    key: "nbs",
    // numByteSlices
    valueSchema: new Uint64Schema()
  }
]));
var AppParams = class _AppParams {
  constructor(params) {
    this.approvalProgram = params.approvalProgram;
    this.clearStateProgram = params.clearStateProgram;
    this.globalState = params.globalState;
    this.localStateSchema = params.localStateSchema;
    this.globalStateSchema = params.globalStateSchema;
    this.extraProgramPages = params.extraProgramPages;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approv", this.approvalProgram],
      ["clearp", this.clearStateProgram],
      ["gs", convertMap(this.globalState, (k, v) => [k, v.toEncodingData()])],
      ["lsch", this.localStateSchema.toEncodingData()],
      ["gsch", this.globalStateSchema.toEncodingData()],
      ["epp", this.extraProgramPages]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppParams: ${data}`);
    }
    return new _AppParams({
      approvalProgram: data.get("approv"),
      clearStateProgram: data.get("clearp"),
      globalState: convertMap(data.get("gs"), (k, v) => [k, TealValue.fromEncodingData(v)]),
      localStateSchema: StateSchema.fromEncodingData(data.get("lsch")),
      globalStateSchema: StateSchema.fromEncodingData(data.get("gsch")),
      extraProgramPages: Number(data.get("epp"))
    });
  }
};
AppParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "approv", valueSchema: new ByteArraySchema() },
  // approvalProgram
  { key: "clearp", valueSchema: new ByteArraySchema() },
  // alearStateProgram
  {
    key: "gs",
    valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
  },
  // globalState
  { key: "lsch", valueSchema: StateSchema.encodingSchema },
  // localStateSchema
  { key: "gsch", valueSchema: StateSchema.encodingSchema },
  // globalStateSchema
  { key: "epp", valueSchema: new Uint64Schema() }
  // extraProgramPages
]));
var AppLocalState = class _AppLocalState {
  constructor(params) {
    this.schema = params.schema;
    this.keyValue = params.keyValue;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppLocalState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hsch", this.schema.toEncodingData()],
      ["tkv", convertMap(this.keyValue, (k, v) => [k, v.toEncodingData()])]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppLocalState: ${data}`);
    }
    return new _AppLocalState({
      schema: StateSchema.fromEncodingData(data.get("hsch")),
      keyValue: convertMap(data.get("tkv"), (k, v) => [k, TealValue.fromEncodingData(v)])
    });
  }
};
AppLocalState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "hsch", valueSchema: StateSchema.encodingSchema },
  // schema
  {
    key: "tkv",
    // keyValue
    valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
  }
]));
var AppLocalStateDelta = class _AppLocalStateDelta {
  constructor(params) {
    this.localState = params.localState;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppLocalStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "LocalState",
        this.localState ? this.localState.toEncodingData() : void 0
      ],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppLocalStateDelta: ${data}`);
    }
    return new _AppLocalStateDelta({
      localState: data.get("LocalState") ? AppLocalState.fromEncodingData(data.get("LocalState")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AppLocalStateDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "LocalState",
    // localState
    valueSchema: new OptionalSchema(AppLocalState.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AppParamsDelta = class _AppParamsDelta {
  constructor(params) {
    this.params = params.params;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppParamsDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Params", this.params ? this.params.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppParamsDelta: ${data}`);
    }
    return new _AppParamsDelta({
      params: data.get("Params") ? AppParams.fromEncodingData(data.get("Params")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AppParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Params",
    // params
    valueSchema: new OptionalSchema(AppParams.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AppResourceRecord = class _AppResourceRecord {
  constructor(params) {
    this.id = params.id;
    this.address = params.address;
    this.params = params.params;
    this.state = params.state;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppResourceRecord.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Aidx", this.id],
      ["Addr", this.address],
      ["Params", this.params.toEncodingData()],
      ["State", this.state.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppResourceRecord: ${data}`);
    }
    return new _AppResourceRecord({
      id: data.get("Aidx"),
      address: data.get("Addr"),
      params: AppParamsDelta.fromEncodingData(data.get("Params")),
      state: AppLocalStateDelta.fromEncodingData(data.get("State"))
    });
  }
};
AppResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Aidx", valueSchema: new Uint64Schema() },
  // id
  { key: "Addr", valueSchema: new AddressSchema() },
  // address
  {
    key: "Params",
    // params
    valueSchema: AppParamsDelta.encodingSchema
  },
  {
    key: "State",
    // state
    valueSchema: AppLocalStateDelta.encodingSchema
  }
]));
var AssetHolding = class _AssetHolding {
  constructor(params) {
    this.amount = params.amount;
    this.frozen = params.frozen;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["a", this.amount],
      ["f", this.frozen]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHolding: ${data}`);
    }
    return new _AssetHolding({
      amount: data.get("a"),
      frozen: data.get("f")
    });
  }
};
AssetHolding.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "a", valueSchema: new Uint64Schema() },
  // amount
  { key: "f", valueSchema: new BooleanSchema() }
  // frozen
]));
var AssetHoldingDelta = class _AssetHoldingDelta {
  constructor(params) {
    this.holding = params.holding;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHoldingDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Holding", this.holding ? this.holding.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHoldingDelta: ${data}`);
    }
    return new _AssetHoldingDelta({
      holding: data.get("Holding") ? AssetHolding.fromEncodingData(data.get("Holding")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AssetHoldingDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Holding",
    // holding
    valueSchema: new OptionalSchema(AssetHolding.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AssetParams = class _AssetParams {
  constructor(params) {
    this.total = params.total;
    this.decimals = params.decimals;
    this.defaultFrozen = params.defaultFrozen;
    this.unitName = params.unitName;
    this.assetName = params.assetName;
    this.url = params.url;
    this.metadataHash = params.metadataHash;
    this.manager = params.manager;
    this.reserve = params.reserve;
    this.freeze = params.freeze;
    this.clawback = params.clawback;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["t", this.total],
      ["dc", this.decimals],
      ["df", this.defaultFrozen],
      ["un", this.unitName],
      ["an", this.assetName],
      ["au", this.url],
      ["am", this.metadataHash],
      ["m", this.manager],
      ["r", this.reserve],
      ["f", this.freeze],
      ["c", this.clawback]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParams: ${data}`);
    }
    return new _AssetParams({
      total: data.get("t"),
      decimals: data.get("dc"),
      defaultFrozen: data.get("df"),
      unitName: data.get("un"),
      assetName: data.get("an"),
      url: data.get("au"),
      metadataHash: data.get("am"),
      manager: data.get("m"),
      reserve: data.get("r"),
      freeze: data.get("f"),
      clawback: data.get("c")
    });
  }
};
AssetParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "t", valueSchema: new Uint64Schema() },
  // total
  { key: "dc", valueSchema: new Uint64Schema() },
  // decimals
  { key: "df", valueSchema: new BooleanSchema() },
  // defaultFrozen
  {
    key: "un",
    // unitName
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  {
    key: "an",
    // assetName
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  {
    key: "au",
    // url
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  { key: "am", valueSchema: new FixedLengthByteArraySchema(32) },
  // metadataHash
  { key: "m", valueSchema: new OptionalSchema(new AddressSchema()) },
  // manager
  { key: "r", valueSchema: new OptionalSchema(new AddressSchema()) },
  // reserve
  { key: "f", valueSchema: new OptionalSchema(new AddressSchema()) },
  // freeze
  { key: "c", valueSchema: new OptionalSchema(new AddressSchema()) }
  // clawback
]));
var AssetParamsDelta = class _AssetParamsDelta {
  constructor(params) {
    this.params = params.params;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParamsDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Params", this.params ? this.params.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParamsDelta: ${data}`);
    }
    return new _AssetParamsDelta({
      params: data.get("Params") ? AssetParams.fromEncodingData(data.get("Params")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AssetParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Params",
    // params
    valueSchema: new OptionalSchema(AssetParams.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AssetResourceRecord = class _AssetResourceRecord {
  constructor(params) {
    this.id = params.id;
    this.address = params.address;
    this.params = params.params;
    this.holding = params.holding;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetResourceRecord.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Aidx", this.id],
      ["Addr", this.address],
      ["Params", this.params.toEncodingData()],
      ["Holding", this.holding.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetResourceRecord: ${data}`);
    }
    return new _AssetResourceRecord({
      id: data.get("Aidx"),
      address: data.get("Addr"),
      params: AssetParamsDelta.fromEncodingData(data.get("Params")),
      holding: AssetHoldingDelta.fromEncodingData(data.get("Holding"))
    });
  }
};
AssetResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Aidx", valueSchema: new Uint64Schema() },
  // id
  { key: "Addr", valueSchema: new AddressSchema() },
  // address
  {
    key: "Params",
    // params
    valueSchema: AssetParamsDelta.encodingSchema
  },
  {
    key: "Holding",
    // holding
    valueSchema: AssetHoldingDelta.encodingSchema
  }
]));
var VotingData = class _VotingData {
  constructor(params) {
    this.voteID = params.voteID;
    this.selectionID = params.selectionID;
    this.stateProofID = params.stateProofID;
    this.voteFirstValid = params.voteFirstValid;
    this.voteLastValid = params.voteLastValid;
    this.voteKeyDilution = params.voteKeyDilution;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _VotingData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["VoteID", this.voteID],
      ["SelectionID", this.selectionID],
      ["StateProofID", this.stateProofID],
      ["VoteFirstValid", this.voteFirstValid],
      ["VoteLastValid", this.voteLastValid],
      ["VoteKeyDilution", this.voteKeyDilution]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded VotingData: ${data}`);
    }
    return new _VotingData({
      voteID: data.get("VoteID"),
      selectionID: data.get("SelectionID"),
      stateProofID: data.get("StateProofID"),
      voteFirstValid: data.get("VoteFirstValid"),
      voteLastValid: data.get("VoteLastValid"),
      voteKeyDilution: data.get("VoteKeyDilution")
    });
  }
};
VotingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "VoteID",
    // voteID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "SelectionID",
    // selectionID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "StateProofID",
    // stateProofID
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "VoteFirstValid",
    // voteFirstValid
    valueSchema: new Uint64Schema()
  },
  {
    key: "VoteLastValid",
    // voteLastValid
    valueSchema: new Uint64Schema()
  },
  {
    key: "VoteKeyDilution",
    // voteKeyDilution
    valueSchema: new Uint64Schema()
  }
]));
var AccountBaseData = class _AccountBaseData {
  constructor(params) {
    this.status = params.status;
    this.microAlgos = params.microAlgos;
    this.rewardsBase = params.rewardsBase;
    this.rewardedMicroAlgos = params.rewardedMicroAlgos;
    this.authAddr = params.authAddr;
    this.incentiveEligible = params.incentiveEligible;
    this.totalAppSchema = params.totalAppSchema;
    this.totalExtraAppPages = params.totalExtraAppPages;
    this.totalAppParams = params.totalAppParams;
    this.totalAppLocalStates = params.totalAppLocalStates;
    this.totalAssetParams = params.totalAssetParams;
    this.totalAssets = params.totalAssets;
    this.totalBoxes = params.totalBoxes;
    this.totalBoxBytes = params.totalBoxBytes;
    this.lastProposed = params.lastProposed;
    this.lastHeartbeat = params.lastHeartbeat;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountBaseData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Status", this.status],
      ["MicroAlgos", this.microAlgos],
      ["RewardsBase", this.rewardsBase],
      ["RewardedMicroAlgos", this.rewardedMicroAlgos],
      ["AuthAddr", this.authAddr],
      ["IncentiveEligible", this.incentiveEligible],
      ["TotalAppSchema", this.totalAppSchema.toEncodingData()],
      ["TotalExtraAppPages", this.totalExtraAppPages],
      ["TotalAppParams", this.totalAppParams],
      ["TotalAppLocalStates", this.totalAppLocalStates],
      ["TotalAssetParams", this.totalAssetParams],
      ["TotalAssets", this.totalAssets],
      ["TotalBoxes", this.totalBoxes],
      ["TotalBoxBytes", this.totalBoxBytes],
      ["LastProposed", this.lastProposed],
      ["LastHeartbeat", this.lastHeartbeat]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountBaseData: ${data}`);
    }
    return new _AccountBaseData({
      status: Number(data.get("Status")),
      microAlgos: data.get("MicroAlgos"),
      rewardsBase: data.get("RewardsBase"),
      rewardedMicroAlgos: data.get("RewardedMicroAlgos"),
      authAddr: data.get("AuthAddr"),
      incentiveEligible: data.get("IncentiveEligible"),
      totalAppSchema: StateSchema.fromEncodingData(data.get("TotalAppSchema")),
      totalExtraAppPages: Number(data.get("TotalExtraAppPages")),
      totalAppParams: data.get("TotalAppParams"),
      totalAppLocalStates: data.get("TotalAppLocalStates"),
      totalAssetParams: data.get("TotalAssetParams"),
      totalAssets: data.get("TotalAssets"),
      totalBoxes: data.get("TotalBoxes"),
      totalBoxBytes: data.get("TotalBoxBytes"),
      lastProposed: data.get("LastProposed"),
      lastHeartbeat: data.get("LastHeartbeat")
    });
  }
};
AccountBaseData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Status", valueSchema: new Uint64Schema() },
  // status
  { key: "MicroAlgos", valueSchema: new Uint64Schema() },
  // microAlgos
  { key: "RewardsBase", valueSchema: new Uint64Schema() },
  // rewardsBase
  {
    key: "RewardedMicroAlgos",
    // rewardedMicroAlgos
    valueSchema: new Uint64Schema()
  },
  { key: "AuthAddr", valueSchema: new AddressSchema() },
  // authAddr
  {
    key: "IncentiveEligible",
    // incentiveEligible
    valueSchema: new BooleanSchema()
  },
  {
    key: "TotalAppSchema",
    // totalAppSchema
    valueSchema: StateSchema.encodingSchema
  },
  {
    key: "TotalExtraAppPages",
    // totalExtraAppPages
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAppParams",
    // totalAppParams
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAppLocalStates",
    // totalAppLocalStates
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAssetParams",
    // totalAssetParams
    valueSchema: new Uint64Schema()
  },
  { key: "TotalAssets", valueSchema: new Uint64Schema() },
  // totalAssets
  { key: "TotalBoxes", valueSchema: new Uint64Schema() },
  // totalBoxes
  {
    key: "TotalBoxBytes",
    // totalBoxBytes
    valueSchema: new Uint64Schema()
  },
  { key: "LastProposed", valueSchema: new Uint64Schema() },
  // lastProposed
  {
    key: "LastHeartbeat",
    // lastHeartbeat
    valueSchema: new Uint64Schema()
  }
]));
var AccountData = class _AccountData {
  constructor(params) {
    this.accountBaseData = params.accountBaseData;
    this.votingData = params.votingData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountData.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(this.accountBaseData.toEncodingData(), this.votingData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountData: ${data}`);
    }
    return new _AccountData({
      accountBaseData: AccountBaseData.fromEncodingData(data),
      votingData: VotingData.fromEncodingData(data)
    });
  }
};
AccountData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: AccountBaseData.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: VotingData.encodingSchema,
    embedded: true
  }
]));
var BalanceRecord = class _BalanceRecord {
  constructor(params) {
    this.addr = params.addr;
    this.accountData = params.accountData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BalanceRecord.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(/* @__PURE__ */ new Map([["Addr", this.addr]]), this.accountData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BalanceRecord: ${data}`);
    }
    return new _BalanceRecord({
      addr: data.get("Addr"),
      accountData: AccountData.fromEncodingData(data)
    });
  }
};
BalanceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Addr",
    valueSchema: new AddressSchema()
  },
  {
    key: "",
    valueSchema: AccountData.encodingSchema,
    embedded: true
  }
]));
var AccountDeltas = class _AccountDeltas {
  constructor(params) {
    this.accounts = params.accounts;
    this.appResources = params.appResources;
    this.assetResources = params.assetResources;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountDeltas.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Accts", this.accounts.map((account) => account.toEncodingData())],
      [
        "AppResources",
        this.appResources.length === 0 ? void 0 : this.appResources.map((appResource) => appResource.toEncodingData())
      ],
      [
        "AssetResources",
        this.assetResources.length === 0 ? void 0 : this.assetResources.map((assetResource) => assetResource.toEncodingData())
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountDeltas: ${data}`);
    }
    return new _AccountDeltas({
      accounts: (data.get("Accts") ?? []).map(BalanceRecord.fromEncodingData),
      appResources: (data.get("AppResources") ?? []).map(AppResourceRecord.fromEncodingData),
      assetResources: (data.get("AssetResources") ?? []).map(AssetResourceRecord.fromEncodingData)
    });
  }
};
AccountDeltas.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Accts",
    // accounts
    valueSchema: new ArraySchema(BalanceRecord.encodingSchema)
  },
  {
    key: "AppResources",
    // appResources
    valueSchema: new OptionalSchema(new ArraySchema(AppResourceRecord.encodingSchema))
  },
  {
    key: "AssetResources",
    // assetResources
    valueSchema: new OptionalSchema(new ArraySchema(AssetResourceRecord.encodingSchema))
  }
]));
var KvValueDelta = class _KvValueDelta {
  constructor(params) {
    this.data = params.data;
    this.oldData = params.oldData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _KvValueDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Data", this.data],
      ["OldData", this.oldData]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded KvValueDelta: ${data}`);
    }
    return new _KvValueDelta({
      data: data.get("Data"),
      oldData: data.get("OldData")
    });
  }
};
KvValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Data",
    valueSchema: new OptionalSchema(new ByteArraySchema())
  },
  {
    key: "OldData",
    valueSchema: new OptionalSchema(new ByteArraySchema())
  }
]));
var IncludedTransactions = class _IncludedTransactions {
  constructor(params) {
    this.lastValid = params.lastValid;
    this.intra = params.intra;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _IncludedTransactions.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["LastValid", this.lastValid],
      ["Intra", this.intra]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded IncludedTransactions: ${data}`);
    }
    return new _IncludedTransactions({
      lastValid: data.get("LastValid"),
      intra: Number(data.get("Intra"))
    });
  }
};
IncludedTransactions.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "LastValid",
    valueSchema: new Uint64Schema()
  },
  {
    key: "Intra",
    valueSchema: new Uint64Schema()
  }
]));
var ModifiedCreatable = class _ModifiedCreatable {
  constructor(params) {
    this.creatableType = params.creatableType;
    this.created = params.created;
    this.creator = params.creator;
    this.ndeltas = params.ndeltas;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ModifiedCreatable.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Ctype", this.creatableType],
      ["Created", this.created],
      ["Creator", this.creator],
      ["Ndeltas", this.ndeltas]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ModifiedCreatable: ${data}`);
    }
    return new _ModifiedCreatable({
      creatableType: Number(data.get("Ctype")),
      created: data.get("Created"),
      creator: data.get("Creator"),
      ndeltas: Number(data.get("Ndeltas"))
    });
  }
};
ModifiedCreatable.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Ctype",
    // creatableType
    valueSchema: new Uint64Schema()
  },
  {
    key: "Created",
    // created
    valueSchema: new BooleanSchema()
  },
  {
    key: "Creator",
    // creator
    valueSchema: new AddressSchema()
  },
  {
    key: "Ndeltas",
    // ndeltas
    valueSchema: new Uint64Schema()
  }
]));
var AlgoCount = class _AlgoCount {
  constructor(params) {
    this.money = params.money;
    this.rewardUnits = params.rewardUnits;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AlgoCount.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["mon", this.money],
      ["rwd", this.rewardUnits]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AlgoCount: ${data}`);
    }
    return new _AlgoCount({
      money: data.get("mon"),
      rewardUnits: data.get("rwd")
    });
  }
};
AlgoCount.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "mon", valueSchema: new Uint64Schema() },
  // money
  { key: "rwd", valueSchema: new Uint64Schema() }
  // rewardUnits
]));
var AccountTotals = class _AccountTotals {
  constructor(params) {
    this.online = params.online;
    this.offline = params.offline;
    this.notParticipating = params.notParticipating;
    this.rewardsLevel = params.rewardsLevel;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountTotals.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["online", this.online.toEncodingData()],
      ["offline", this.offline.toEncodingData()],
      ["notpart", this.notParticipating.toEncodingData()],
      ["rwdlvl", this.rewardsLevel]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountTotals: ${data}`);
    }
    return new _AccountTotals({
      online: AlgoCount.fromEncodingData(data.get("online")),
      offline: AlgoCount.fromEncodingData(data.get("offline")),
      notParticipating: AlgoCount.fromEncodingData(data.get("notpart")),
      rewardsLevel: data.get("rwdlvl")
    });
  }
};
AccountTotals.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "online", valueSchema: AlgoCount.encodingSchema },
  // online
  { key: "offline", valueSchema: AlgoCount.encodingSchema },
  // offline
  { key: "notpart", valueSchema: AlgoCount.encodingSchema },
  // notParticipating
  { key: "rwdlvl", valueSchema: new Uint64Schema() }
  // rewardsLevel
]));
var LedgerStateDelta = class _LedgerStateDelta {
  constructor(params) {
    this.accounts = params.accounts;
    this.kvMods = params.kvMods;
    this.txids = params.txids;
    this.txleases = params.txleases;
    this.creatables = params.creatables;
    this.blockHeader = params.blockHeader;
    this.stateProofNext = params.stateProofNext;
    this.prevTimestamp = params.prevTimestamp;
    this.totals = params.totals;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LedgerStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Accts", this.accounts.toEncodingData()],
      [
        "KvMods",
        this.kvMods.size === 0 ? void 0 : convertMap(this.kvMods, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ],
      [
        "Txids",
        convertMap(this.txids, (key, value) => [key, value.toEncodingData()])
      ],
      ["Txleases", this.txleases.toEncodingData()],
      [
        "Creatables",
        this.creatables.size === 0 ? void 0 : convertMap(this.creatables, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ],
      ["Hdr", this.blockHeader.toEncodingData()],
      ["StateProofNext", this.stateProofNext],
      ["PrevTimestamp", this.prevTimestamp],
      ["Totals", this.totals.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LedgerStateDelta: ${data}`);
    }
    return new _LedgerStateDelta({
      accounts: AccountDeltas.fromEncodingData(data.get("Accts")),
      kvMods: convertMap(data.get("KvMods") ?? /* @__PURE__ */ new Map(), (key, value) => [key, KvValueDelta.fromEncodingData(value)]),
      txids: convertMap(data.get("Txids"), (key, value) => [key, IncludedTransactions.fromEncodingData(value)]),
      txleases: UntypedValue.fromEncodingData(data.get("Txleases")),
      creatables: convertMap(data.get("Creatables") ?? /* @__PURE__ */ new Map(), (key, value) => [key, ModifiedCreatable.fromEncodingData(value)]),
      blockHeader: BlockHeader.fromEncodingData(data.get("Hdr")),
      stateProofNext: data.get("StateProofNext"),
      prevTimestamp: data.get("PrevTimestamp"),
      totals: AccountTotals.fromEncodingData(data.get("Totals"))
    });
  }
};
LedgerStateDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Accts",
    // accounts
    valueSchema: AccountDeltas.encodingSchema
  },
  {
    key: "KvMods",
    // kvMods
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(KvValueDelta.encodingSchema))
  },
  {
    key: "Txids",
    // txids
    valueSchema: new ByteArrayMapSchema(IncludedTransactions.encodingSchema)
  },
  {
    key: "Txleases",
    // txleases
    // Note: because txleases is currently just an UntypedSchema and we are expected to decode
    // null values for this field, we use OptionalSchema to coerce null values to undefined so
    // that the values can be properly omitted during encoding.
    valueSchema: new OptionalSchema(new UntypedSchema())
  },
  {
    key: "Creatables",
    // creatables
    valueSchema: new OptionalSchema(new Uint64MapSchema(ModifiedCreatable.encodingSchema))
  },
  {
    key: "Hdr",
    // blockHeader
    valueSchema: BlockHeader.encodingSchema
  },
  {
    key: "StateProofNext",
    // stateProofNext
    valueSchema: new Uint64Schema()
  },
  {
    key: "PrevTimestamp",
    // prevTimestamp
    valueSchema: new Uint64Schema()
  },
  {
    key: "Totals",
    // totals
    valueSchema: AccountTotals.encodingSchema
  }
]));

// node_modules/algosdk/dist/esm/client/v2/algod/models/types.js
var Account = class _Account {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "amount-without-pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "min-balance",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "rewards", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "status", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "total-apps-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-assets-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-apps",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-assets",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "apps-local-state",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalState.encodingSchema)),
        omitEmpty: true
      }, {
        key: "apps-total-extra-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "apps-total-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
        omitEmpty: true
      }, {
        key: "assets",
        valueSchema: new OptionalSchema(new ArraySchema(AssetHolding2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "auth-addr",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "created-apps",
        valueSchema: new OptionalSchema(new ArraySchema(Application.encodingSchema)),
        omitEmpty: true
      }, {
        key: "created-assets",
        valueSchema: new OptionalSchema(new ArraySchema(Asset.encodingSchema)),
        omitEmpty: true
      }, {
        key: "incentive-eligible",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "last-heartbeat",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "last-proposed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "participation",
        valueSchema: new OptionalSchema(AccountParticipation.encodingSchema),
        omitEmpty: true
      }, {
        key: "reward-base",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-type",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "total-box-bytes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "total-boxes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param minBalance - MicroAlgo balance required by the account.
   * The requirement grows based on asset and application usage.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param createdApps - (appp) parameters of applications created by this account including app global
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param incentiveEligible - Whether or not the account can receive block incentives if its balance is in
   * range at proposal time.
   * @param lastHeartbeat - The round in which this account last went online, or explicitly renewed their
   * online status.
   * @param lastProposed - The round in which this account last proposed the block.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * @param totalBoxBytes - (tbxb) The total number of bytes used by this account's app's box keys and
   * values.
   * @param totalBoxes - (tbx) The number of existing boxes created by this account's app.
   */
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, incentiveEligible, lastHeartbeat, lastProposed, participation, rewardBase, sigType, totalBoxBytes, totalBoxes }) {
    this.address = address;
    this.amount = ensureBigInt(amount);
    this.amountWithoutPendingRewards = ensureBigInt(amountWithoutPendingRewards);
    this.minBalance = ensureBigInt(minBalance);
    this.pendingRewards = ensureBigInt(pendingRewards);
    this.rewards = ensureBigInt(rewards);
    this.round = ensureBigInt(round);
    this.status = status;
    this.totalAppsOptedIn = ensureSafeInteger(totalAppsOptedIn);
    this.totalAssetsOptedIn = ensureSafeInteger(totalAssetsOptedIn);
    this.totalCreatedApps = ensureSafeInteger(totalCreatedApps);
    this.totalCreatedAssets = ensureSafeInteger(totalCreatedAssets);
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = typeof appsTotalExtraPages === "undefined" ? void 0 : ensureSafeInteger(appsTotalExtraPages);
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.incentiveEligible = incentiveEligible;
    this.lastHeartbeat = typeof lastHeartbeat === "undefined" ? void 0 : ensureSafeInteger(lastHeartbeat);
    this.lastProposed = typeof lastProposed === "undefined" ? void 0 : ensureSafeInteger(lastProposed);
    this.participation = participation;
    this.rewardBase = typeof rewardBase === "undefined" ? void 0 : ensureBigInt(rewardBase);
    this.sigType = sigType;
    this.totalBoxBytes = typeof totalBoxBytes === "undefined" ? void 0 : ensureSafeInteger(totalBoxBytes);
    this.totalBoxes = typeof totalBoxes === "undefined" ? void 0 : ensureSafeInteger(totalBoxes);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Account.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["amount", this.amount],
      ["amount-without-pending-rewards", this.amountWithoutPendingRewards],
      ["min-balance", this.minBalance],
      ["pending-rewards", this.pendingRewards],
      ["rewards", this.rewards],
      ["round", this.round],
      ["status", this.status],
      ["total-apps-opted-in", this.totalAppsOptedIn],
      ["total-assets-opted-in", this.totalAssetsOptedIn],
      ["total-created-apps", this.totalCreatedApps],
      ["total-created-assets", this.totalCreatedAssets],
      [
        "apps-local-state",
        typeof this.appsLocalState !== "undefined" ? this.appsLocalState.map((v) => v.toEncodingData()) : void 0
      ],
      ["apps-total-extra-pages", this.appsTotalExtraPages],
      [
        "apps-total-schema",
        typeof this.appsTotalSchema !== "undefined" ? this.appsTotalSchema.toEncodingData() : void 0
      ],
      [
        "assets",
        typeof this.assets !== "undefined" ? this.assets.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "auth-addr",
        typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
      ],
      [
        "created-apps",
        typeof this.createdApps !== "undefined" ? this.createdApps.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "created-assets",
        typeof this.createdAssets !== "undefined" ? this.createdAssets.map((v) => v.toEncodingData()) : void 0
      ],
      ["incentive-eligible", this.incentiveEligible],
      ["last-heartbeat", this.lastHeartbeat],
      ["last-proposed", this.lastProposed],
      [
        "participation",
        typeof this.participation !== "undefined" ? this.participation.toEncodingData() : void 0
      ],
      ["reward-base", this.rewardBase],
      ["sig-type", this.sigType],
      ["total-box-bytes", this.totalBoxBytes],
      ["total-boxes", this.totalBoxes]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Account: ${data}`);
    }
    return new _Account({
      address: data.get("address"),
      amount: data.get("amount"),
      amountWithoutPendingRewards: data.get("amount-without-pending-rewards"),
      minBalance: data.get("min-balance"),
      pendingRewards: data.get("pending-rewards"),
      rewards: data.get("rewards"),
      round: data.get("round"),
      status: data.get("status"),
      totalAppsOptedIn: data.get("total-apps-opted-in"),
      totalAssetsOptedIn: data.get("total-assets-opted-in"),
      totalCreatedApps: data.get("total-created-apps"),
      totalCreatedAssets: data.get("total-created-assets"),
      appsLocalState: typeof data.get("apps-local-state") !== "undefined" ? data.get("apps-local-state").map((v) => ApplicationLocalState.fromEncodingData(v)) : void 0,
      appsTotalExtraPages: data.get("apps-total-extra-pages"),
      appsTotalSchema: typeof data.get("apps-total-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("apps-total-schema")) : void 0,
      assets: typeof data.get("assets") !== "undefined" ? data.get("assets").map((v) => AssetHolding2.fromEncodingData(v)) : void 0,
      authAddr: data.get("auth-addr"),
      createdApps: typeof data.get("created-apps") !== "undefined" ? data.get("created-apps").map((v) => Application.fromEncodingData(v)) : void 0,
      createdAssets: typeof data.get("created-assets") !== "undefined" ? data.get("created-assets").map((v) => Asset.fromEncodingData(v)) : void 0,
      incentiveEligible: data.get("incentive-eligible"),
      lastHeartbeat: data.get("last-heartbeat"),
      lastProposed: data.get("last-proposed"),
      participation: typeof data.get("participation") !== "undefined" ? AccountParticipation.fromEncodingData(data.get("participation")) : void 0,
      rewardBase: data.get("reward-base"),
      sigType: data.get("sig-type"),
      totalBoxBytes: data.get("total-box-bytes"),
      totalBoxes: data.get("total-boxes")
    });
  }
};
var AccountApplicationResponse = class _AccountApplicationResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "app-local-state",
        valueSchema: new OptionalSchema(ApplicationLocalState.encodingSchema),
        omitEmpty: true
      }, {
        key: "created-app",
        valueSchema: new OptionalSchema(ApplicationParams.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountApplicationResponse` object.
   * @param round - The round for which this information is relevant.
   * @param appLocalState - (appl) the application local data stored in this account.
   * The raw account uses `AppLocalState` for this type.
   * @param createdApp - (appp) parameters of the application created by this account including app
   * global data.
   * The raw account uses `AppParams` for this type.
   */
  constructor({ round, appLocalState, createdApp }) {
    this.round = ensureBigInt(round);
    this.appLocalState = appLocalState;
    this.createdApp = createdApp;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountApplicationResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["round", this.round],
      [
        "app-local-state",
        typeof this.appLocalState !== "undefined" ? this.appLocalState.toEncodingData() : void 0
      ],
      [
        "created-app",
        typeof this.createdApp !== "undefined" ? this.createdApp.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountApplicationResponse: ${data}`);
    }
    return new _AccountApplicationResponse({
      round: data.get("round"),
      appLocalState: typeof data.get("app-local-state") !== "undefined" ? ApplicationLocalState.fromEncodingData(data.get("app-local-state")) : void 0,
      createdApp: typeof data.get("created-app") !== "undefined" ? ApplicationParams.fromEncodingData(data.get("created-app")) : void 0
    });
  }
};
var AccountAssetHolding = class _AccountAssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "asset-holding",
        valueSchema: AssetHolding2.encodingSchema,
        omitEmpty: true
      }, {
        key: "asset-params",
        valueSchema: new OptionalSchema(AssetParams2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountAssetHolding` object.
   * @param assetHolding - (asset) Details about the asset held by this account.
   * The raw account uses `AssetHolding` for this type.
   * @param assetParams - (apar) parameters of the asset held by this account.
   * The raw account uses `AssetParams` for this type.
   */
  constructor({ assetHolding, assetParams }) {
    this.assetHolding = assetHolding;
    this.assetParams = assetParams;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountAssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["asset-holding", this.assetHolding.toEncodingData()],
      [
        "asset-params",
        typeof this.assetParams !== "undefined" ? this.assetParams.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountAssetHolding: ${data}`);
    }
    return new _AccountAssetHolding({
      assetHolding: AssetHolding2.fromEncodingData(data.get("asset-holding") ?? /* @__PURE__ */ new Map()),
      assetParams: typeof data.get("asset-params") !== "undefined" ? AssetParams2.fromEncodingData(data.get("asset-params")) : void 0
    });
  }
};
var AccountAssetResponse = class _AccountAssetResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "asset-holding",
        valueSchema: new OptionalSchema(AssetHolding2.encodingSchema),
        omitEmpty: true
      }, {
        key: "created-asset",
        valueSchema: new OptionalSchema(AssetParams2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountAssetResponse` object.
   * @param round - The round for which this information is relevant.
   * @param assetHolding - (asset) Details about the asset held by this account.
   * The raw account uses `AssetHolding` for this type.
   * @param createdAsset - (apar) parameters of the asset created by this account.
   * The raw account uses `AssetParams` for this type.
   */
  constructor({ round, assetHolding, createdAsset }) {
    this.round = ensureBigInt(round);
    this.assetHolding = assetHolding;
    this.createdAsset = createdAsset;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountAssetResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["round", this.round],
      [
        "asset-holding",
        typeof this.assetHolding !== "undefined" ? this.assetHolding.toEncodingData() : void 0
      ],
      [
        "created-asset",
        typeof this.createdAsset !== "undefined" ? this.createdAsset.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountAssetResponse: ${data}`);
    }
    return new _AccountAssetResponse({
      round: data.get("round"),
      assetHolding: typeof data.get("asset-holding") !== "undefined" ? AssetHolding2.fromEncodingData(data.get("asset-holding")) : void 0,
      createdAsset: typeof data.get("created-asset") !== "undefined" ? AssetParams2.fromEncodingData(data.get("created-asset")) : void 0
    });
  }
};
var AccountAssetsInformationResponse = class _AccountAssetsInformationResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "asset-holdings",
        valueSchema: new OptionalSchema(new ArraySchema(AccountAssetHolding.encodingSchema)),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountAssetsInformationResponse` object.
   * @param round - The round for which this information is relevant.
   * @param assetHoldings -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ round, assetHoldings, nextToken }) {
    this.round = ensureSafeInteger(round);
    this.assetHoldings = assetHoldings;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountAssetsInformationResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["round", this.round],
      [
        "asset-holdings",
        typeof this.assetHoldings !== "undefined" ? this.assetHoldings.map((v) => v.toEncodingData()) : void 0
      ],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountAssetsInformationResponse: ${data}`);
    }
    return new _AccountAssetsInformationResponse({
      round: data.get("round"),
      assetHoldings: typeof data.get("asset-holdings") !== "undefined" ? data.get("asset-holdings").map((v) => AccountAssetHolding.fromEncodingData(v)) : void 0,
      nextToken: data.get("next-token")
    });
  }
};
var AccountParticipation = class _AccountParticipation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "selection-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "vote-first-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-key-dilution",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-last-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "state-proof-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
    this.voteFirstValid = ensureBigInt(voteFirstValid);
    this.voteKeyDilution = ensureBigInt(voteKeyDilution);
    this.voteLastValid = ensureBigInt(voteLastValid);
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountParticipation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["selection-participation-key", this.selectionParticipationKey],
      ["vote-first-valid", this.voteFirstValid],
      ["vote-key-dilution", this.voteKeyDilution],
      ["vote-last-valid", this.voteLastValid],
      ["vote-participation-key", this.voteParticipationKey],
      ["state-proof-key", this.stateProofKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountParticipation: ${data}`);
    }
    return new _AccountParticipation({
      selectionParticipationKey: data.get("selection-participation-key"),
      voteFirstValid: data.get("vote-first-valid"),
      voteKeyDilution: data.get("vote-key-dilution"),
      voteLastValid: data.get("vote-last-valid"),
      voteParticipationKey: data.get("vote-participation-key"),
      stateProofKey: data.get("state-proof-key")
    });
  }
};
var AccountStateDelta = class _AccountStateDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "delta",
        valueSchema: new ArraySchema(EvalDeltaKeyValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    this.address = address;
    this.delta = delta;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["delta", this.delta.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountStateDelta: ${data}`);
    }
    return new _AccountStateDelta({
      address: data.get("address"),
      delta: (data.get("delta") ?? []).map((v) => EvalDeltaKeyValue.fromEncodingData(v))
    });
  }
};
var AppCallLogs = class _AppCallLogs {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-index",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new ArraySchema(new ByteArraySchema()),
        omitEmpty: true
      }, { key: "txId", valueSchema: new StringSchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AppCallLogs` object.
   * @param applicationIndex - The application from which the logs were generated
   * @param logs - An array of logs
   * @param txid - The transaction ID of the outer app call that lead to these logs
   */
  constructor({ applicationIndex, logs, txid }) {
    this.applicationIndex = ensureSafeInteger(applicationIndex);
    this.logs = logs;
    this.txid = txid;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppCallLogs.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-index", this.applicationIndex],
      ["logs", this.logs],
      ["txId", this.txid]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppCallLogs: ${data}`);
    }
    return new _AppCallLogs({
      applicationIndex: data.get("application-index"),
      logs: data.get("logs"),
      txid: data.get("txId")
    });
  }
};
var Application = class _Application {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: ApplicationParams.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   */
  constructor({ id, params }) {
    this.id = ensureBigInt(id);
    this.params = params;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Application.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["params", this.params.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Application: ${data}`);
    }
    return new _Application({
      id: data.get("id"),
      params: ApplicationParams.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map())
    });
  }
};
var ApplicationInitialStates = class _ApplicationInitialStates {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "app-boxes",
        valueSchema: new OptionalSchema(ApplicationKVStorage.encodingSchema),
        omitEmpty: true
      }, {
        key: "app-globals",
        valueSchema: new OptionalSchema(ApplicationKVStorage.encodingSchema),
        omitEmpty: true
      }, {
        key: "app-locals",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationKVStorage.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationInitialStates` object.
   * @param id - Application index.
   * @param appBoxes - An application's global/local/box state.
   * @param appGlobals - An application's global/local/box state.
   * @param appLocals - An application's initial local states tied to different accounts.
   */
  constructor({ id, appBoxes, appGlobals, appLocals }) {
    this.id = ensureBigInt(id);
    this.appBoxes = appBoxes;
    this.appGlobals = appGlobals;
    this.appLocals = appLocals;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationInitialStates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      [
        "app-boxes",
        typeof this.appBoxes !== "undefined" ? this.appBoxes.toEncodingData() : void 0
      ],
      [
        "app-globals",
        typeof this.appGlobals !== "undefined" ? this.appGlobals.toEncodingData() : void 0
      ],
      [
        "app-locals",
        typeof this.appLocals !== "undefined" ? this.appLocals.map((v) => v.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationInitialStates: ${data}`);
    }
    return new _ApplicationInitialStates({
      id: data.get("id"),
      appBoxes: typeof data.get("app-boxes") !== "undefined" ? ApplicationKVStorage.fromEncodingData(data.get("app-boxes")) : void 0,
      appGlobals: typeof data.get("app-globals") !== "undefined" ? ApplicationKVStorage.fromEncodingData(data.get("app-globals")) : void 0,
      appLocals: typeof data.get("app-locals") !== "undefined" ? data.get("app-locals").map((v) => ApplicationKVStorage.fromEncodingData(v)) : void 0
    });
  }
};
var ApplicationKVStorage = class _ApplicationKVStorage {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "kvs",
        valueSchema: new ArraySchema(AvmKeyValue.encodingSchema),
        omitEmpty: true
      }, {
        key: "account",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationKVStorage` object.
   * @param kvs - Key-Value pairs representing application states.
   * @param account - The address of the account associated with the local state.
   */
  constructor({ kvs, account }) {
    this.kvs = kvs;
    this.account = typeof account === "string" ? Address.fromString(account) : account;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationKVStorage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["kvs", this.kvs.map((v) => v.toEncodingData())],
      [
        "account",
        typeof this.account !== "undefined" ? this.account.toString() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationKVStorage: ${data}`);
    }
    return new _ApplicationKVStorage({
      kvs: (data.get("kvs") ?? []).map((v) => AvmKeyValue.fromEncodingData(v)),
      account: data.get("account")
    });
  }
};
var ApplicationLocalReference = class _ApplicationLocalReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "account", valueSchema: new StringSchema(), omitEmpty: true }, { key: "app", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalReference` object.
   * @param account - Address of the account with the local state.
   * @param app - Application ID of the local state application.
   */
  constructor({ account, app }) {
    this.account = typeof account === "string" ? Address.fromString(account) : account;
    this.app = ensureBigInt(app);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["account", this.account.toString()],
      ["app", this.app]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalReference: ${data}`);
    }
    return new _ApplicationLocalReference({
      account: data.get("account"),
      app: data.get("app")
    });
  }
};
var ApplicationLocalState = class _ApplicationLocalState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "schema",
        valueSchema: ApplicationStateSchema.encodingSchema,
        omitEmpty: true
      }, {
        key: "key-value",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param keyValue - (tkv) storage.
   */
  constructor({ id, schema, keyValue }) {
    this.id = ensureBigInt(id);
    this.schema = schema;
    this.keyValue = keyValue;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["schema", this.schema.toEncodingData()],
      [
        "key-value",
        typeof this.keyValue !== "undefined" ? this.keyValue.map((v) => v.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalState: ${data}`);
    }
    return new _ApplicationLocalState({
      id: data.get("id"),
      schema: ApplicationStateSchema.fromEncodingData(data.get("schema") ?? /* @__PURE__ */ new Map()),
      keyValue: typeof data.get("key-value") !== "undefined" ? data.get("key-value").map((v) => TealKeyValue.fromEncodingData(v)) : void 0
    });
  }
};
var ApplicationParams = class _ApplicationParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "approval-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "clear-state-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "extra-program-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-state",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "global-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
        omitEmpty: true
      }, {
        key: "local-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
        omitEmpty: true
      }, {
        key: "version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - (gs) global state
   * @param globalStateSchema - (gsch) global schema
   * @param localStateSchema - (lsch) local schema
   * @param version - (v) the number of updates to the application programs
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema, version }) {
    this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
    this.creator = typeof creator === "string" ? Address.fromString(creator) : creator;
    this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.version = typeof version === "undefined" ? void 0 : ensureSafeInteger(version);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approval-program", this.approvalProgram],
      ["clear-state-program", this.clearStateProgram],
      ["creator", this.creator.toString()],
      ["extra-program-pages", this.extraProgramPages],
      [
        "global-state",
        typeof this.globalState !== "undefined" ? this.globalState.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "global-state-schema",
        typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
      ],
      [
        "local-state-schema",
        typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
      ],
      ["version", this.version]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationParams: ${data}`);
    }
    return new _ApplicationParams({
      approvalProgram: data.get("approval-program"),
      clearStateProgram: data.get("clear-state-program"),
      creator: data.get("creator"),
      extraProgramPages: data.get("extra-program-pages"),
      globalState: typeof data.get("global-state") !== "undefined" ? data.get("global-state").map((v) => TealKeyValue.fromEncodingData(v)) : void 0,
      globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("global-state-schema")) : void 0,
      localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("local-state-schema")) : void 0,
      version: data.get("version")
    });
  }
};
var ApplicationStateOperation = class _ApplicationStateOperation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "app-state-type",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "operation", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "account",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "new-value",
        valueSchema: new OptionalSchema(AvmValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationStateOperation` object.
   * @param appStateType - Type of application state. Value `g` is **global state**, `l` is **local
   * state**, `b` is **boxes**.
   * @param key - The key (name) of the global/local/box state.
   * @param operation - Operation type. Value `w` is **write**, `d` is **delete**.
   * @param account - For local state changes, the address of the account associated with the local
   * state.
   * @param newValue - Represents an AVM value.
   */
  constructor({ appStateType, key, operation, account, newValue }) {
    this.appStateType = appStateType;
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.operation = operation;
    this.account = typeof account === "string" ? Address.fromString(account) : account;
    this.newValue = newValue;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationStateOperation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app-state-type", this.appStateType],
      ["key", this.key],
      ["operation", this.operation],
      [
        "account",
        typeof this.account !== "undefined" ? this.account.toString() : void 0
      ],
      [
        "new-value",
        typeof this.newValue !== "undefined" ? this.newValue.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationStateOperation: ${data}`);
    }
    return new _ApplicationStateOperation({
      appStateType: data.get("app-state-type"),
      key: data.get("key"),
      operation: data.get("operation"),
      account: data.get("account"),
      newValue: typeof data.get("new-value") !== "undefined" ? AvmValue.fromEncodingData(data.get("new-value")) : void 0
    });
  }
};
var ApplicationStateSchema = class _ApplicationStateSchema {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "num-byte-slice",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numByteSlice - (nbs) num of byte slices.
   * @param numUint - (nui) num of uints.
   */
  constructor({ numByteSlice, numUint }) {
    this.numByteSlice = ensureSafeInteger(numByteSlice);
    this.numUint = ensureSafeInteger(numUint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationStateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["num-byte-slice", this.numByteSlice],
      ["num-uint", this.numUint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationStateSchema: ${data}`);
    }
    return new _ApplicationStateSchema({
      numByteSlice: data.get("num-byte-slice"),
      numUint: data.get("num-uint")
    });
  }
};
var Asset = class _Asset {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: AssetParams2.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ index, params }) {
    this.index = ensureBigInt(index);
    this.params = params;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Asset.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["index", this.index],
      ["params", this.params.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Asset: ${data}`);
    }
    return new _Asset({
      index: data.get("index"),
      params: AssetParams2.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map())
    });
  }
};
var AssetHolding2 = class _AssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   */
  constructor({ amount, assetId, isFrozen }) {
    this.amount = ensureBigInt(amount);
    this.assetId = ensureBigInt(assetId);
    this.isFrozen = isFrozen;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["asset-id", this.assetId],
      ["is-frozen", this.isFrozen]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHolding: ${data}`);
    }
    return new _AssetHolding({
      amount: data.get("amount"),
      assetId: data.get("asset-id"),
      isFrozen: data.get("is-frozen")
    });
  }
};
var AssetHoldingReference = class _AssetHoldingReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "account", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHoldingReference` object.
   * @param account - Address of the account holding the asset.
   * @param asset - Asset ID of the holding.
   */
  constructor({ account, asset }) {
    this.account = typeof account === "string" ? Address.fromString(account) : account;
    this.asset = ensureBigInt(asset);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHoldingReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["account", this.account.toString()],
      ["asset", this.asset]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHoldingReference: ${data}`);
    }
    return new _AssetHoldingReference({
      account: data.get("account"),
      asset: data.get("asset")
    });
  }
};
var AssetParams2 = class _AssetParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, { key: "decimals", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "total", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "clawback",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "default-frozen",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "freeze",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "manager",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "metadata-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "reserve",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "url",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "url-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    this.creator = creator;
    this.decimals = ensureSafeInteger(decimals);
    this.total = ensureBigInt(total);
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? base64ToBytes(metadataHash) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? base64ToBytes(nameB64) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? base64ToBytes(unitNameB64) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? base64ToBytes(urlB64) : urlB64;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["creator", this.creator],
      ["decimals", this.decimals],
      ["total", this.total],
      ["clawback", this.clawback],
      ["default-frozen", this.defaultFrozen],
      ["freeze", this.freeze],
      ["manager", this.manager],
      ["metadata-hash", this.metadataHash],
      ["name", this.name],
      ["name-b64", this.nameB64],
      ["reserve", this.reserve],
      ["unit-name", this.unitName],
      ["unit-name-b64", this.unitNameB64],
      ["url", this.url],
      ["url-b64", this.urlB64]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParams: ${data}`);
    }
    return new _AssetParams({
      creator: data.get("creator"),
      decimals: data.get("decimals"),
      total: data.get("total"),
      clawback: data.get("clawback"),
      defaultFrozen: data.get("default-frozen"),
      freeze: data.get("freeze"),
      manager: data.get("manager"),
      metadataHash: data.get("metadata-hash"),
      name: data.get("name"),
      nameB64: data.get("name-b64"),
      reserve: data.get("reserve"),
      unitName: data.get("unit-name"),
      unitNameB64: data.get("unit-name-b64"),
      url: data.get("url"),
      urlB64: data.get("url-b64")
    });
  }
};
var AvmKeyValue = class _AvmKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: AvmValue.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AvmKeyValue` object.
   * @param key -
   * @param value - Represents an AVM value.
   */
  constructor({ key, value }) {
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AvmKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AvmKeyValue: ${data}`);
    }
    return new _AvmKeyValue({
      key: data.get("key"),
      value: AvmValue.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var AvmValue = class _AvmValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "bytes",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "uint",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AvmValue` object.
   * @param type - value type. Value `1` refers to **bytes**, value `2` refers to **uint64**
   * @param bytes - bytes value.
   * @param uint - uint value.
   */
  constructor({ type, bytes, uint }) {
    this.type = ensureSafeInteger(type);
    this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
    this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AvmValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["type", this.type],
      ["bytes", this.bytes],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AvmValue: ${data}`);
    }
    return new _AvmValue({
      type: data.get("type"),
      bytes: data.get("bytes"),
      uint: data.get("uint")
    });
  }
};
var BlockHashResponse = class _BlockHashResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "blockHash",
        valueSchema: new StringSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockHashResponse` object.
   * @param blockhash - Block header hash.
   */
  constructor({ blockhash }) {
    this.blockhash = blockhash;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockHashResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["blockHash", this.blockhash]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHashResponse: ${data}`);
    }
    return new _BlockHashResponse({
      blockhash: data.get("blockHash")
    });
  }
};
var BlockLogsResponse = class _BlockLogsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "logs",
        valueSchema: new ArraySchema(AppCallLogs.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockLogsResponse` object.
   * @param logs -
   */
  constructor({ logs }) {
    this.logs = logs;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockLogsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["logs", this.logs.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockLogsResponse: ${data}`);
    }
    return new _BlockLogsResponse({
      logs: (data.get("logs") ?? []).map((v) => AppCallLogs.fromEncodingData(v))
    });
  }
};
var BlockResponse = class _BlockResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "block", valueSchema: Block.encodingSchema, omitEmpty: true }, {
        key: "cert",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockResponse` object.
   * @param block - Block header data.
   * @param cert - Optional certificate object. This is only included when the format is set to
   * message pack.
   */
  constructor({ block, cert }) {
    this.block = block;
    this.cert = cert;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["block", this.block.toEncodingData()],
      [
        "cert",
        typeof this.cert !== "undefined" ? this.cert.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockResponse: ${data}`);
    }
    return new _BlockResponse({
      block: Block.fromEncodingData(data.get("block") ?? /* @__PURE__ */ new Map()),
      cert: typeof data.get("cert") !== "undefined" ? UntypedValue.fromEncodingData(data.get("cert")) : void 0
    });
  }
};
var BlockTxidsResponse = class _BlockTxidsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "blockTxids",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockTxidsResponse` object.
   * @param blocktxids - Block transaction IDs.
   */
  constructor({ blocktxids }) {
    this.blocktxids = blocktxids;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockTxidsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["blockTxids", this.blocktxids]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockTxidsResponse: ${data}`);
    }
    return new _BlockTxidsResponse({
      blocktxids: data.get("blockTxids")
    });
  }
};
var Box = class _Box {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "value", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Box` object.
   * @param name - The box name, base64 encoded
   * @param round - The round for which this information is relevant
   * @param value - The box value, base64 encoded.
   */
  constructor({ name, round, value }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
    this.round = ensureBigInt(round);
    this.value = typeof value === "string" ? base64ToBytes(value) : value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Box.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["name", this.name],
      ["round", this.round],
      ["value", this.value]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Box: ${data}`);
    }
    return new _Box({
      name: data.get("name"),
      round: data.get("round"),
      value: data.get("value")
    });
  }
};
var BoxDescriptor = class _BoxDescriptor {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "name",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxDescriptor.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["name", this.name]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxDescriptor: ${data}`);
    }
    return new _BoxDescriptor({
      name: data.get("name")
    });
  }
};
var BoxReference = class _BoxReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "app", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxReference` object.
   * @param app - Application ID which this box belongs to
   * @param name - Base64 encoded box name
   */
  constructor({ app, name }) {
    this.app = ensureBigInt(app);
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app", this.app],
      ["name", this.name]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxReference: ${data}`);
    }
    return new _BoxReference({
      app: data.get("app"),
      name: data.get("name")
    });
  }
};
var BoxesResponse = class _BoxesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "boxes",
        valueSchema: new ArraySchema(BoxDescriptor.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxesResponse` object.
   * @param boxes -
   */
  constructor({ boxes }) {
    this.boxes = boxes;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["boxes", this.boxes.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxesResponse: ${data}`);
    }
    return new _BoxesResponse({
      boxes: (data.get("boxes") ?? []).map((v) => BoxDescriptor.fromEncodingData(v))
    });
  }
};
var BuildVersion = class _BuildVersion {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "branch", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "build_number",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "channel", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "commit_hash",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "major", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "minor", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BuildVersion` object.
   * @param branch -
   * @param buildNumber -
   * @param channel -
   * @param commitHash -
   * @param major -
   * @param minor -
   */
  constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
    this.branch = branch;
    this.buildNumber = ensureSafeInteger(buildNumber);
    this.channel = channel;
    this.commitHash = commitHash;
    this.major = ensureSafeInteger(major);
    this.minor = ensureSafeInteger(minor);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BuildVersion.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["branch", this.branch],
      ["build_number", this.buildNumber],
      ["channel", this.channel],
      ["commit_hash", this.commitHash],
      ["major", this.major],
      ["minor", this.minor]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BuildVersion: ${data}`);
    }
    return new _BuildVersion({
      branch: data.get("branch"),
      buildNumber: data.get("build_number"),
      channel: data.get("channel"),
      commitHash: data.get("commit_hash"),
      major: data.get("major"),
      minor: data.get("minor")
    });
  }
};
var CompileResponse = class _CompileResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "hash", valueSchema: new StringSchema(), omitEmpty: true }, { key: "result", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "sourcemap",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `CompileResponse` object.
   * @param hash - base32 SHA512_256 of program bytes (Address style)
   * @param result - base64 encoded program bytes
   * @param sourcemap - JSON of the source map
   */
  constructor({ hash, result, sourcemap }) {
    this.hash = hash;
    this.result = result;
    this.sourcemap = sourcemap;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _CompileResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hash", this.hash],
      ["result", this.result],
      [
        "sourcemap",
        typeof this.sourcemap !== "undefined" ? this.sourcemap.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded CompileResponse: ${data}`);
    }
    return new _CompileResponse({
      hash: data.get("hash"),
      result: data.get("result"),
      sourcemap: typeof data.get("sourcemap") !== "undefined" ? UntypedValue.fromEncodingData(data.get("sourcemap")) : void 0
    });
  }
};
var DisassembleResponse = class _DisassembleResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "result",
        valueSchema: new StringSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DisassembleResponse` object.
   * @param result - disassembled Teal code
   */
  constructor({ result }) {
    this.result = result;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DisassembleResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["result", this.result]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DisassembleResponse: ${data}`);
    }
    return new _DisassembleResponse({
      result: data.get("result")
    });
  }
};
var DryrunRequest = class _DryrunRequest {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "accounts",
        valueSchema: new ArraySchema(Account.encodingSchema),
        omitEmpty: true
      }, {
        key: "apps",
        valueSchema: new ArraySchema(Application.encodingSchema),
        omitEmpty: true
      }, {
        key: "latest-timestamp",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "protocol-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "sources",
        valueSchema: new ArraySchema(DryrunSource.encodingSchema),
        omitEmpty: true
      }, {
        key: "txns",
        valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunRequest` object.
   * @param accounts -
   * @param apps -
   * @param latestTimestamp - LatestTimestamp is available to some TEAL scripts. Defaults to the latest
   * confirmed timestamp this algod is attached to.
   * @param protocolVersion - ProtocolVersion specifies a specific version string to operate under, otherwise
   * whatever the current protocol of the network this algod is running in.
   * @param round - Round is available to some TEAL scripts. Defaults to the current round on the
   * network this algod is attached to.
   * @param sources -
   * @param txns -
   */
  constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
    this.accounts = accounts;
    this.apps = apps;
    this.latestTimestamp = ensureSafeInteger(latestTimestamp);
    this.protocolVersion = protocolVersion;
    this.round = ensureBigInt(round);
    this.sources = sources;
    this.txns = txns;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunRequest.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["accounts", this.accounts.map((v) => v.toEncodingData())],
      ["apps", this.apps.map((v) => v.toEncodingData())],
      ["latest-timestamp", this.latestTimestamp],
      ["protocol-version", this.protocolVersion],
      ["round", this.round],
      ["sources", this.sources.map((v) => v.toEncodingData())],
      ["txns", this.txns.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunRequest: ${data}`);
    }
    return new _DryrunRequest({
      accounts: (data.get("accounts") ?? []).map((v) => Account.fromEncodingData(v)),
      apps: (data.get("apps") ?? []).map((v) => Application.fromEncodingData(v)),
      latestTimestamp: data.get("latest-timestamp"),
      protocolVersion: data.get("protocol-version"),
      round: data.get("round"),
      sources: (data.get("sources") ?? []).map((v) => DryrunSource.fromEncodingData(v)),
      txns: (data.get("txns") ?? []).map((v) => SignedTransaction.fromEncodingData(v))
    });
  }
};
var DryrunResponse = class _DryrunResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "error", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "protocol-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "txns",
        valueSchema: new ArraySchema(DryrunTxnResult.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunResponse` object.
   * @param error -
   * @param protocolVersion - Protocol version is the protocol version Dryrun was operated under.
   * @param txns -
   */
  constructor({ error, protocolVersion, txns }) {
    this.error = error;
    this.protocolVersion = protocolVersion;
    this.txns = txns;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["error", this.error],
      ["protocol-version", this.protocolVersion],
      ["txns", this.txns.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunResponse: ${data}`);
    }
    return new _DryrunResponse({
      error: data.get("error"),
      protocolVersion: data.get("protocol-version"),
      txns: (data.get("txns") ?? []).map((v) => DryrunTxnResult.fromEncodingData(v))
    });
  }
};
var DryrunSource = class _DryrunSource {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "app-index", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "field-name", valueSchema: new StringSchema(), omitEmpty: true }, { key: "source", valueSchema: new StringSchema(), omitEmpty: true }, { key: "txn-index", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunSource` object.
   * @param appIndex -
   * @param fieldName - FieldName is what kind of sources this is. If lsig then it goes into the
   * transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the
   * Approval Program or Clear State Program of application[this.AppIndex].
   * @param source -
   * @param txnIndex -
   */
  constructor({ appIndex, fieldName, source, txnIndex }) {
    this.appIndex = ensureBigInt(appIndex);
    this.fieldName = fieldName;
    this.source = source;
    this.txnIndex = ensureSafeInteger(txnIndex);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunSource.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app-index", this.appIndex],
      ["field-name", this.fieldName],
      ["source", this.source],
      ["txn-index", this.txnIndex]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunSource: ${data}`);
    }
    return new _DryrunSource({
      appIndex: data.get("app-index"),
      fieldName: data.get("field-name"),
      source: data.get("source"),
      txnIndex: data.get("txn-index")
    });
  }
};
var DryrunState = class _DryrunState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "line", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "pc", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "stack",
        valueSchema: new ArraySchema(TealValue2.encodingSchema),
        omitEmpty: true
      }, {
        key: "error",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "scratch",
        valueSchema: new OptionalSchema(new ArraySchema(TealValue2.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunState` object.
   * @param line - Line number
   * @param pc - Program counter
   * @param stack -
   * @param error - Evaluation error if any
   * @param scratch -
   */
  constructor({ line, pc, stack, error, scratch }) {
    this.line = ensureSafeInteger(line);
    this.pc = ensureSafeInteger(pc);
    this.stack = stack;
    this.error = error;
    this.scratch = scratch;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["line", this.line],
      ["pc", this.pc],
      ["stack", this.stack.map((v) => v.toEncodingData())],
      ["error", this.error],
      [
        "scratch",
        typeof this.scratch !== "undefined" ? this.scratch.map((v) => v.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunState: ${data}`);
    }
    return new _DryrunState({
      line: data.get("line"),
      pc: data.get("pc"),
      stack: (data.get("stack") ?? []).map((v) => TealValue2.fromEncodingData(v)),
      error: data.get("error"),
      scratch: typeof data.get("scratch") !== "undefined" ? data.get("scratch").map((v) => TealValue2.fromEncodingData(v)) : void 0
    });
  }
};
var DryrunTxnResult = class _DryrunTxnResult {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "disassembly",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "app-call-messages",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "app-call-trace",
        valueSchema: new OptionalSchema(new ArraySchema(DryrunState.encodingSchema)),
        omitEmpty: true
      }, {
        key: "budget-added",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-delta",
        valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "local-deltas",
        valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logic-sig-disassembly",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "logic-sig-messages",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "logic-sig-trace",
        valueSchema: new OptionalSchema(new ArraySchema(DryrunState.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunTxnResult` object.
   * @param disassembly - Disassembled program line by line.
   * @param appCallMessages -
   * @param appCallTrace -
   * @param budgetAdded - Budget added during execution of app call transaction.
   * @param budgetConsumed - Budget consumed during execution of app call transaction.
   * @param globalDelta - Application state delta.
   * @param localDeltas -
   * @param logicSigDisassembly - Disassembled lsig program line by line.
   * @param logicSigMessages -
   * @param logicSigTrace -
   * @param logs -
   */
  constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
    this.disassembly = disassembly;
    this.appCallMessages = appCallMessages;
    this.appCallTrace = appCallTrace;
    this.budgetAdded = typeof budgetAdded === "undefined" ? void 0 : ensureSafeInteger(budgetAdded);
    this.budgetConsumed = typeof budgetConsumed === "undefined" ? void 0 : ensureSafeInteger(budgetConsumed);
    this.globalDelta = globalDelta;
    this.localDeltas = localDeltas;
    this.logicSigDisassembly = logicSigDisassembly;
    this.logicSigMessages = logicSigMessages;
    this.logicSigTrace = logicSigTrace;
    this.logs = logs;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunTxnResult.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["disassembly", this.disassembly],
      ["app-call-messages", this.appCallMessages],
      [
        "app-call-trace",
        typeof this.appCallTrace !== "undefined" ? this.appCallTrace.map((v) => v.toEncodingData()) : void 0
      ],
      ["budget-added", this.budgetAdded],
      ["budget-consumed", this.budgetConsumed],
      [
        "global-delta",
        typeof this.globalDelta !== "undefined" ? this.globalDelta.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "local-deltas",
        typeof this.localDeltas !== "undefined" ? this.localDeltas.map((v) => v.toEncodingData()) : void 0
      ],
      ["logic-sig-disassembly", this.logicSigDisassembly],
      ["logic-sig-messages", this.logicSigMessages],
      [
        "logic-sig-trace",
        typeof this.logicSigTrace !== "undefined" ? this.logicSigTrace.map((v) => v.toEncodingData()) : void 0
      ],
      ["logs", this.logs]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunTxnResult: ${data}`);
    }
    return new _DryrunTxnResult({
      disassembly: data.get("disassembly"),
      appCallMessages: data.get("app-call-messages"),
      appCallTrace: typeof data.get("app-call-trace") !== "undefined" ? data.get("app-call-trace").map((v) => DryrunState.fromEncodingData(v)) : void 0,
      budgetAdded: data.get("budget-added"),
      budgetConsumed: data.get("budget-consumed"),
      globalDelta: typeof data.get("global-delta") !== "undefined" ? data.get("global-delta").map((v) => EvalDeltaKeyValue.fromEncodingData(v)) : void 0,
      localDeltas: typeof data.get("local-deltas") !== "undefined" ? data.get("local-deltas").map((v) => AccountStateDelta.fromEncodingData(v)) : void 0,
      logicSigDisassembly: data.get("logic-sig-disassembly"),
      logicSigMessages: data.get("logic-sig-messages"),
      logicSigTrace: typeof data.get("logic-sig-trace") !== "undefined" ? data.get("logic-sig-trace").map((v) => DryrunState.fromEncodingData(v)) : void 0,
      logs: data.get("logs")
    });
  }
};
var ErrorResponse = class _ErrorResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "message", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "data",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    this.message = message;
    this.data = data;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ErrorResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["message", this.message],
      [
        "data",
        typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ErrorResponse: ${data}`);
    }
    return new _ErrorResponse({
      message: data.get("message"),
      data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0
    });
  }
};
var EvalDelta2 = class _EvalDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "action", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "bytes",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "uint",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    this.action = ensureSafeInteger(action);
    this.bytes = bytes;
    this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["action", this.action],
      ["bytes", this.bytes],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDelta: ${data}`);
    }
    return new _EvalDelta({
      action: data.get("action"),
      bytes: data.get("bytes"),
      uint: data.get("uint")
    });
  }
};
var EvalDeltaKeyValue = class _EvalDeltaKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new StringSchema(), omitEmpty: true }, { key: "value", valueSchema: EvalDelta2.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    this.key = key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDeltaKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDeltaKeyValue: ${data}`);
    }
    return new _EvalDeltaKeyValue({
      key: data.get("key"),
      value: EvalDelta2.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var Genesis = class _Genesis {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "alloc",
        valueSchema: new ArraySchema(GenesisAllocation.encodingSchema),
        omitEmpty: true
      }, { key: "fees", valueSchema: new StringSchema(), omitEmpty: true }, { key: "id", valueSchema: new StringSchema(), omitEmpty: true }, { key: "network", valueSchema: new StringSchema(), omitEmpty: true }, { key: "proto", valueSchema: new StringSchema(), omitEmpty: true }, { key: "rwd", valueSchema: new StringSchema(), omitEmpty: true }, { key: "timestamp", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "comment",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "devmode",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Genesis` object.
   * @param alloc -
   * @param fees -
   * @param id -
   * @param network -
   * @param proto -
   * @param rwd -
   * @param timestamp -
   * @param comment -
   * @param devmode -
   */
  constructor({ alloc, fees, id, network, proto, rwd, timestamp, comment, devmode }) {
    this.alloc = alloc;
    this.fees = fees;
    this.id = id;
    this.network = network;
    this.proto = proto;
    this.rwd = rwd;
    this.timestamp = ensureSafeInteger(timestamp);
    this.comment = comment;
    this.devmode = devmode;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Genesis.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["alloc", this.alloc.map((v) => v.toEncodingData())],
      ["fees", this.fees],
      ["id", this.id],
      ["network", this.network],
      ["proto", this.proto],
      ["rwd", this.rwd],
      ["timestamp", this.timestamp],
      ["comment", this.comment],
      ["devmode", this.devmode]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Genesis: ${data}`);
    }
    return new _Genesis({
      alloc: (data.get("alloc") ?? []).map((v) => GenesisAllocation.fromEncodingData(v)),
      fees: data.get("fees"),
      id: data.get("id"),
      network: data.get("network"),
      proto: data.get("proto"),
      rwd: data.get("rwd"),
      timestamp: data.get("timestamp"),
      comment: data.get("comment"),
      devmode: data.get("devmode")
    });
  }
};
var GenesisAllocation = class _GenesisAllocation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "addr", valueSchema: new StringSchema(), omitEmpty: true }, { key: "comment", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "state",
        valueSchema: UntypedValue.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `GenesisAllocation` object.
   * @param addr -
   * @param comment -
   * @param state -
   */
  constructor({ addr, comment, state }) {
    this.addr = addr;
    this.comment = comment;
    this.state = state;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _GenesisAllocation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["addr", this.addr],
      ["comment", this.comment],
      ["state", this.state.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded GenesisAllocation: ${data}`);
    }
    return new _GenesisAllocation({
      addr: data.get("addr"),
      comment: data.get("comment"),
      state: UntypedValue.fromEncodingData(data.get("state") ?? /* @__PURE__ */ new Map())
    });
  }
};
var GetBlockTimeStampOffsetResponse = class _GetBlockTimeStampOffsetResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "offset",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `GetBlockTimeStampOffsetResponse` object.
   * @param offset - Timestamp offset in seconds.
   */
  constructor({ offset }) {
    this.offset = ensureSafeInteger(offset);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _GetBlockTimeStampOffsetResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["offset", this.offset]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded GetBlockTimeStampOffsetResponse: ${data}`);
    }
    return new _GetBlockTimeStampOffsetResponse({
      offset: data.get("offset")
    });
  }
};
var GetSyncRoundResponse = class _GetSyncRoundResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `GetSyncRoundResponse` object.
   * @param round - The minimum sync round for the ledger.
   */
  constructor({ round }) {
    this.round = ensureBigInt(round);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _GetSyncRoundResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["round", this.round]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded GetSyncRoundResponse: ${data}`);
    }
    return new _GetSyncRoundResponse({
      round: data.get("round")
    });
  }
};
var LedgerStateDeltaForTransactionGroup = class _LedgerStateDeltaForTransactionGroup {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "Delta",
        valueSchema: LedgerStateDelta.encodingSchema,
        omitEmpty: true
      }, {
        key: "Ids",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `LedgerStateDeltaForTransactionGroup` object.
   * @param delta - Ledger StateDelta object
   * @param ids -
   */
  constructor({ delta, ids }) {
    this.delta = delta;
    this.ids = ids;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LedgerStateDeltaForTransactionGroup.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Delta", this.delta.toEncodingData()],
      ["Ids", this.ids]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LedgerStateDeltaForTransactionGroup: ${data}`);
    }
    return new _LedgerStateDeltaForTransactionGroup({
      delta: LedgerStateDelta.fromEncodingData(data.get("Delta") ?? /* @__PURE__ */ new Map()),
      ids: data.get("Ids")
    });
  }
};
var LightBlockHeaderProof = class _LightBlockHeaderProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "proof", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "treedepth", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `LightBlockHeaderProof` object.
   * @param index - The index of the light block header in the vector commitment tree
   * @param proof - The encoded proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   */
  constructor({ index, proof, treedepth }) {
    this.index = ensureSafeInteger(index);
    this.proof = typeof proof === "string" ? base64ToBytes(proof) : proof;
    this.treedepth = ensureSafeInteger(treedepth);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LightBlockHeaderProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["index", this.index],
      ["proof", this.proof],
      ["treedepth", this.treedepth]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LightBlockHeaderProof: ${data}`);
    }
    return new _LightBlockHeaderProof({
      index: data.get("index"),
      proof: data.get("proof"),
      treedepth: data.get("treedepth")
    });
  }
};
var NodeStatusResponse = class _NodeStatusResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "catchup-time",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "last-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "next-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "next-version-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-version-supported",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, {
        key: "stopped-at-unsupported-round",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, {
        key: "time-since-last-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "catchpoint",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "catchpoint-acquired-blocks",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-processed-accounts",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-processed-kvs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-total-accounts",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-total-blocks",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-total-kvs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-verified-accounts",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-verified-kvs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "last-catchpoint",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "upgrade-delay",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-next-protocol-vote-before",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-no-votes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-node-vote",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "upgrade-vote-rounds",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-votes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-votes-required",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-yes-votes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `NodeStatusResponse` object.
   * @param catchupTime - CatchupTime in nanoseconds
   * @param lastRound - LastRound indicates the last round seen
   * @param lastVersion - LastVersion indicates the last consensus version supported
   * @param nextVersion - NextVersion of consensus protocol to use
   * @param nextVersionRound - NextVersionRound is the round at which the next consensus version will apply
   * @param nextVersionSupported - NextVersionSupported indicates whether the next consensus version is supported
   * by this node
   * @param stoppedAtUnsupportedRound - StoppedAtUnsupportedRound indicates that the node does not support the new
   * rounds and has stopped making progress
   * @param timeSinceLastRound - TimeSinceLastRound in nanoseconds
   * @param catchpoint - The current catchpoint that is being caught up to
   * @param catchpointAcquiredBlocks - The number of blocks that have already been obtained by the node as part of the
   * catchup
   * @param catchpointProcessedAccounts - The number of accounts from the current catchpoint that have been processed so
   * far as part of the catchup
   * @param catchpointProcessedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * processed so far as part of the catchup
   * @param catchpointTotalAccounts - The total number of accounts included in the current catchpoint
   * @param catchpointTotalBlocks - The total number of blocks that are required to complete the current catchpoint
   * catchup
   * @param catchpointTotalKvs - The total number of key-values (KVs) included in the current catchpoint
   * @param catchpointVerifiedAccounts - The number of accounts from the current catchpoint that have been verified so
   * far as part of the catchup
   * @param catchpointVerifiedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * verified so far as part of the catchup
   * @param lastCatchpoint - The last catchpoint seen by the node
   * @param upgradeDelay - Upgrade delay
   * @param upgradeNextProtocolVoteBefore - Next protocol round
   * @param upgradeNoVotes - No votes cast for consensus upgrade
   * @param upgradeNodeVote - This node's upgrade vote
   * @param upgradeVoteRounds - Total voting rounds for current upgrade
   * @param upgradeVotes - Total votes cast for consensus upgrade
   * @param upgradeVotesRequired - Yes votes required for consensus upgrade
   * @param upgradeYesVotes - Yes votes cast for consensus upgrade
   */
  constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointProcessedKvs, catchpointTotalAccounts, catchpointTotalBlocks, catchpointTotalKvs, catchpointVerifiedAccounts, catchpointVerifiedKvs, lastCatchpoint, upgradeDelay, upgradeNextProtocolVoteBefore, upgradeNoVotes, upgradeNodeVote, upgradeVoteRounds, upgradeVotes, upgradeVotesRequired, upgradeYesVotes }) {
    this.catchupTime = ensureBigInt(catchupTime);
    this.lastRound = ensureBigInt(lastRound);
    this.lastVersion = lastVersion;
    this.nextVersion = nextVersion;
    this.nextVersionRound = ensureBigInt(nextVersionRound);
    this.nextVersionSupported = nextVersionSupported;
    this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
    this.timeSinceLastRound = ensureBigInt(timeSinceLastRound);
    this.catchpoint = catchpoint;
    this.catchpointAcquiredBlocks = typeof catchpointAcquiredBlocks === "undefined" ? void 0 : ensureSafeInteger(catchpointAcquiredBlocks);
    this.catchpointProcessedAccounts = typeof catchpointProcessedAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointProcessedAccounts);
    this.catchpointProcessedKvs = typeof catchpointProcessedKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointProcessedKvs);
    this.catchpointTotalAccounts = typeof catchpointTotalAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalAccounts);
    this.catchpointTotalBlocks = typeof catchpointTotalBlocks === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalBlocks);
    this.catchpointTotalKvs = typeof catchpointTotalKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalKvs);
    this.catchpointVerifiedAccounts = typeof catchpointVerifiedAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointVerifiedAccounts);
    this.catchpointVerifiedKvs = typeof catchpointVerifiedKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointVerifiedKvs);
    this.lastCatchpoint = lastCatchpoint;
    this.upgradeDelay = typeof upgradeDelay === "undefined" ? void 0 : ensureBigInt(upgradeDelay);
    this.upgradeNextProtocolVoteBefore = typeof upgradeNextProtocolVoteBefore === "undefined" ? void 0 : ensureBigInt(upgradeNextProtocolVoteBefore);
    this.upgradeNoVotes = typeof upgradeNoVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeNoVotes);
    this.upgradeNodeVote = upgradeNodeVote;
    this.upgradeVoteRounds = typeof upgradeVoteRounds === "undefined" ? void 0 : ensureSafeInteger(upgradeVoteRounds);
    this.upgradeVotes = typeof upgradeVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeVotes);
    this.upgradeVotesRequired = typeof upgradeVotesRequired === "undefined" ? void 0 : ensureSafeInteger(upgradeVotesRequired);
    this.upgradeYesVotes = typeof upgradeYesVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeYesVotes);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _NodeStatusResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["catchup-time", this.catchupTime],
      ["last-round", this.lastRound],
      ["last-version", this.lastVersion],
      ["next-version", this.nextVersion],
      ["next-version-round", this.nextVersionRound],
      ["next-version-supported", this.nextVersionSupported],
      ["stopped-at-unsupported-round", this.stoppedAtUnsupportedRound],
      ["time-since-last-round", this.timeSinceLastRound],
      ["catchpoint", this.catchpoint],
      ["catchpoint-acquired-blocks", this.catchpointAcquiredBlocks],
      ["catchpoint-processed-accounts", this.catchpointProcessedAccounts],
      ["catchpoint-processed-kvs", this.catchpointProcessedKvs],
      ["catchpoint-total-accounts", this.catchpointTotalAccounts],
      ["catchpoint-total-blocks", this.catchpointTotalBlocks],
      ["catchpoint-total-kvs", this.catchpointTotalKvs],
      ["catchpoint-verified-accounts", this.catchpointVerifiedAccounts],
      ["catchpoint-verified-kvs", this.catchpointVerifiedKvs],
      ["last-catchpoint", this.lastCatchpoint],
      ["upgrade-delay", this.upgradeDelay],
      ["upgrade-next-protocol-vote-before", this.upgradeNextProtocolVoteBefore],
      ["upgrade-no-votes", this.upgradeNoVotes],
      ["upgrade-node-vote", this.upgradeNodeVote],
      ["upgrade-vote-rounds", this.upgradeVoteRounds],
      ["upgrade-votes", this.upgradeVotes],
      ["upgrade-votes-required", this.upgradeVotesRequired],
      ["upgrade-yes-votes", this.upgradeYesVotes]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded NodeStatusResponse: ${data}`);
    }
    return new _NodeStatusResponse({
      catchupTime: data.get("catchup-time"),
      lastRound: data.get("last-round"),
      lastVersion: data.get("last-version"),
      nextVersion: data.get("next-version"),
      nextVersionRound: data.get("next-version-round"),
      nextVersionSupported: data.get("next-version-supported"),
      stoppedAtUnsupportedRound: data.get("stopped-at-unsupported-round"),
      timeSinceLastRound: data.get("time-since-last-round"),
      catchpoint: data.get("catchpoint"),
      catchpointAcquiredBlocks: data.get("catchpoint-acquired-blocks"),
      catchpointProcessedAccounts: data.get("catchpoint-processed-accounts"),
      catchpointProcessedKvs: data.get("catchpoint-processed-kvs"),
      catchpointTotalAccounts: data.get("catchpoint-total-accounts"),
      catchpointTotalBlocks: data.get("catchpoint-total-blocks"),
      catchpointTotalKvs: data.get("catchpoint-total-kvs"),
      catchpointVerifiedAccounts: data.get("catchpoint-verified-accounts"),
      catchpointVerifiedKvs: data.get("catchpoint-verified-kvs"),
      lastCatchpoint: data.get("last-catchpoint"),
      upgradeDelay: data.get("upgrade-delay"),
      upgradeNextProtocolVoteBefore: data.get("upgrade-next-protocol-vote-before"),
      upgradeNoVotes: data.get("upgrade-no-votes"),
      upgradeNodeVote: data.get("upgrade-node-vote"),
      upgradeVoteRounds: data.get("upgrade-vote-rounds"),
      upgradeVotes: data.get("upgrade-votes"),
      upgradeVotesRequired: data.get("upgrade-votes-required"),
      upgradeYesVotes: data.get("upgrade-yes-votes")
    });
  }
};
var PendingTransactionResponse = class _PendingTransactionResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "pool-error", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "txn",
        valueSchema: SignedTransaction.encodingSchema,
        omitEmpty: true
      }, {
        key: "application-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "asset-closing-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "asset-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "close-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "closing-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "confirmed-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "inner-txns",
        valueSchema: new OptionalSchema(new ArraySchema(_PendingTransactionResponse.encodingSchema)),
        omitEmpty: true
      }, {
        key: "local-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "receiver-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sender-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `PendingTransactionResponse` object.
   * @param poolError - Indicates that the transaction was kicked out of this node's transaction pool
   * (and specifies why that happened). An empty string indicates the transaction
   * wasn't kicked out of this node's txpool due to an error.
   * @param txn - The raw signed transaction.
   * @param applicationIndex - The application index if the transaction was found and it created an
   * application.
   * @param assetClosingAmount - The number of the asset's unit that were transferred to the close-to address.
   * @param assetIndex - The asset index if the transaction was found and it created an asset.
   * @param closeRewards - Rewards in microalgos applied to the close remainder to account.
   * @param closingAmount - Closing amount for the transaction.
   * @param confirmedRound - The round where this transaction was confirmed, if present.
   * @param globalStateDelta - Global state key/value changes for the application being executed by this
   * transaction.
   * @param innerTxns - Inner transactions produced by application execution.
   * @param localStateDelta - Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - Logs for the application being executed by this transaction.
   * @param receiverRewards - Rewards in microalgos applied to the receiver account.
   * @param senderRewards - Rewards in microalgos applied to the sender account.
   */
  constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
    this.poolError = poolError;
    this.txn = txn;
    this.applicationIndex = typeof applicationIndex === "undefined" ? void 0 : ensureBigInt(applicationIndex);
    this.assetClosingAmount = typeof assetClosingAmount === "undefined" ? void 0 : ensureBigInt(assetClosingAmount);
    this.assetIndex = typeof assetIndex === "undefined" ? void 0 : ensureBigInt(assetIndex);
    this.closeRewards = typeof closeRewards === "undefined" ? void 0 : ensureBigInt(closeRewards);
    this.closingAmount = typeof closingAmount === "undefined" ? void 0 : ensureBigInt(closingAmount);
    this.confirmedRound = typeof confirmedRound === "undefined" ? void 0 : ensureBigInt(confirmedRound);
    this.globalStateDelta = globalStateDelta;
    this.innerTxns = innerTxns;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.receiverRewards = typeof receiverRewards === "undefined" ? void 0 : ensureBigInt(receiverRewards);
    this.senderRewards = typeof senderRewards === "undefined" ? void 0 : ensureBigInt(senderRewards);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _PendingTransactionResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["pool-error", this.poolError],
      ["txn", this.txn.toEncodingData()],
      ["application-index", this.applicationIndex],
      ["asset-closing-amount", this.assetClosingAmount],
      ["asset-index", this.assetIndex],
      ["close-rewards", this.closeRewards],
      ["closing-amount", this.closingAmount],
      ["confirmed-round", this.confirmedRound],
      [
        "global-state-delta",
        typeof this.globalStateDelta !== "undefined" ? this.globalStateDelta.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "inner-txns",
        typeof this.innerTxns !== "undefined" ? this.innerTxns.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "local-state-delta",
        typeof this.localStateDelta !== "undefined" ? this.localStateDelta.map((v) => v.toEncodingData()) : void 0
      ],
      ["logs", this.logs],
      ["receiver-rewards", this.receiverRewards],
      ["sender-rewards", this.senderRewards]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded PendingTransactionResponse: ${data}`);
    }
    return new _PendingTransactionResponse({
      poolError: data.get("pool-error"),
      txn: SignedTransaction.fromEncodingData(data.get("txn") ?? /* @__PURE__ */ new Map()),
      applicationIndex: data.get("application-index"),
      assetClosingAmount: data.get("asset-closing-amount"),
      assetIndex: data.get("asset-index"),
      closeRewards: data.get("close-rewards"),
      closingAmount: data.get("closing-amount"),
      confirmedRound: data.get("confirmed-round"),
      globalStateDelta: typeof data.get("global-state-delta") !== "undefined" ? data.get("global-state-delta").map((v) => EvalDeltaKeyValue.fromEncodingData(v)) : void 0,
      innerTxns: typeof data.get("inner-txns") !== "undefined" ? data.get("inner-txns").map((v) => _PendingTransactionResponse.fromEncodingData(v)) : void 0,
      localStateDelta: typeof data.get("local-state-delta") !== "undefined" ? data.get("local-state-delta").map((v) => AccountStateDelta.fromEncodingData(v)) : void 0,
      logs: data.get("logs"),
      receiverRewards: data.get("receiver-rewards"),
      senderRewards: data.get("sender-rewards")
    });
  }
};
var PendingTransactionsResponse = class _PendingTransactionsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "top-transactions",
        valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
        omitEmpty: true
      }, {
        key: "total-transactions",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `PendingTransactionsResponse` object.
   * @param topTransactions - An array of signed transaction objects.
   * @param totalTransactions - Total number of transactions in the pool.
   */
  constructor({ topTransactions, totalTransactions }) {
    this.topTransactions = topTransactions;
    this.totalTransactions = ensureSafeInteger(totalTransactions);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _PendingTransactionsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["top-transactions", this.topTransactions.map((v) => v.toEncodingData())],
      ["total-transactions", this.totalTransactions]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded PendingTransactionsResponse: ${data}`);
    }
    return new _PendingTransactionsResponse({
      topTransactions: (data.get("top-transactions") ?? []).map((v) => SignedTransaction.fromEncodingData(v)),
      totalTransactions: data.get("total-transactions")
    });
  }
};
var PostTransactionsResponse = class _PostTransactionsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txId",
        valueSchema: new StringSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `PostTransactionsResponse` object.
   * @param txid - encoding of the transaction hash.
   */
  constructor({ txid }) {
    this.txid = txid;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _PostTransactionsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["txId", this.txid]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded PostTransactionsResponse: ${data}`);
    }
    return new _PostTransactionsResponse({
      txid: data.get("txId")
    });
  }
};
var ScratchChange = class _ScratchChange {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "new-value",
        valueSchema: AvmValue.encodingSchema,
        omitEmpty: true
      }, { key: "slot", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ScratchChange` object.
   * @param newValue - Represents an AVM value.
   * @param slot - The scratch slot written.
   */
  constructor({ newValue, slot }) {
    this.newValue = newValue;
    this.slot = ensureSafeInteger(slot);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ScratchChange.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["new-value", this.newValue.toEncodingData()],
      ["slot", this.slot]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ScratchChange: ${data}`);
    }
    return new _ScratchChange({
      newValue: AvmValue.fromEncodingData(data.get("new-value") ?? /* @__PURE__ */ new Map()),
      slot: data.get("slot")
    });
  }
};
var SimulateInitialStates = class _SimulateInitialStates {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "app-initial-states",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationInitialStates.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateInitialStates` object.
   * @param appInitialStates - The initial states of accessed application before simulation. The order of this
   * array is arbitrary.
   */
  constructor({ appInitialStates }) {
    this.appInitialStates = appInitialStates;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateInitialStates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "app-initial-states",
        typeof this.appInitialStates !== "undefined" ? this.appInitialStates.map((v) => v.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateInitialStates: ${data}`);
    }
    return new _SimulateInitialStates({
      appInitialStates: typeof data.get("app-initial-states") !== "undefined" ? data.get("app-initial-states").map((v) => ApplicationInitialStates.fromEncodingData(v)) : void 0
    });
  }
};
var SimulateRequest = class _SimulateRequest {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txn-groups",
        valueSchema: new ArraySchema(SimulateRequestTransactionGroup.encodingSchema),
        omitEmpty: true
      }, {
        key: "allow-empty-signatures",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "allow-more-logging",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "allow-unnamed-resources",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "exec-trace-config",
        valueSchema: new OptionalSchema(SimulateTraceConfig.encodingSchema),
        omitEmpty: true
      }, {
        key: "extra-opcode-budget",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "fix-signers",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateRequest` object.
   * @param txnGroups - The transaction groups to simulate.
   * @param allowEmptySignatures - Allows transactions without signatures to be simulated as if they had correct
   * signatures.
   * @param allowMoreLogging - Lifts limits on log opcode usage during simulation.
   * @param allowUnnamedResources - Allows access to unnamed resources during simulation.
   * @param execTraceConfig - An object that configures simulation execution trace.
   * @param extraOpcodeBudget - Applies extra opcode budget during simulation for each transaction group.
   * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
   * during evaluation.
   * @param round - If provided, specifies the round preceding the simulation. State changes through
   * this round will be used to run this simulation. Usually only the 4 most recent
   * rounds will be available (controlled by the node config value MaxAcctLookback).
   * If not specified, defaults to the latest available round.
   */
  constructor({ txnGroups, allowEmptySignatures, allowMoreLogging, allowUnnamedResources, execTraceConfig, extraOpcodeBudget, fixSigners, round }) {
    this.txnGroups = txnGroups;
    this.allowEmptySignatures = allowEmptySignatures;
    this.allowMoreLogging = allowMoreLogging;
    this.allowUnnamedResources = allowUnnamedResources;
    this.execTraceConfig = execTraceConfig;
    this.extraOpcodeBudget = typeof extraOpcodeBudget === "undefined" ? void 0 : ensureSafeInteger(extraOpcodeBudget);
    this.fixSigners = fixSigners;
    this.round = typeof round === "undefined" ? void 0 : ensureBigInt(round);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateRequest.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn-groups", this.txnGroups.map((v) => v.toEncodingData())],
      ["allow-empty-signatures", this.allowEmptySignatures],
      ["allow-more-logging", this.allowMoreLogging],
      ["allow-unnamed-resources", this.allowUnnamedResources],
      [
        "exec-trace-config",
        typeof this.execTraceConfig !== "undefined" ? this.execTraceConfig.toEncodingData() : void 0
      ],
      ["extra-opcode-budget", this.extraOpcodeBudget],
      ["fix-signers", this.fixSigners],
      ["round", this.round]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateRequest: ${data}`);
    }
    return new _SimulateRequest({
      txnGroups: (data.get("txn-groups") ?? []).map((v) => SimulateRequestTransactionGroup.fromEncodingData(v)),
      allowEmptySignatures: data.get("allow-empty-signatures"),
      allowMoreLogging: data.get("allow-more-logging"),
      allowUnnamedResources: data.get("allow-unnamed-resources"),
      execTraceConfig: typeof data.get("exec-trace-config") !== "undefined" ? SimulateTraceConfig.fromEncodingData(data.get("exec-trace-config")) : void 0,
      extraOpcodeBudget: data.get("extra-opcode-budget"),
      fixSigners: data.get("fix-signers"),
      round: data.get("round")
    });
  }
};
var SimulateRequestTransactionGroup = class _SimulateRequestTransactionGroup {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txns",
        valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateRequestTransactionGroup` object.
   * @param txns - An atomic transaction group.
   */
  constructor({ txns }) {
    this.txns = txns;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateRequestTransactionGroup.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txns", this.txns.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateRequestTransactionGroup: ${data}`);
    }
    return new _SimulateRequestTransactionGroup({
      txns: (data.get("txns") ?? []).map((v) => SignedTransaction.fromEncodingData(v))
    });
  }
};
var SimulateResponse = class _SimulateResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "txn-groups",
        valueSchema: new ArraySchema(SimulateTransactionGroupResult.encodingSchema),
        omitEmpty: true
      }, { key: "version", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "eval-overrides",
        valueSchema: new OptionalSchema(SimulationEvalOverrides.encodingSchema),
        omitEmpty: true
      }, {
        key: "exec-trace-config",
        valueSchema: new OptionalSchema(SimulateTraceConfig.encodingSchema),
        omitEmpty: true
      }, {
        key: "initial-states",
        valueSchema: new OptionalSchema(SimulateInitialStates.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateResponse` object.
   * @param lastRound - The round immediately preceding this simulation. State changes through this
   * round were used to run this simulation.
   * @param txnGroups - A result object for each transaction group that was simulated.
   * @param version - The version of this response object.
   * @param evalOverrides - The set of parameters and limits override during simulation. If this set of
   * parameters is present, then evaluation parameters may differ from standard
   * evaluation in certain ways.
   * @param execTraceConfig - An object that configures simulation execution trace.
   * @param initialStates - Initial states of resources that were accessed during simulation.
   */
  constructor({ lastRound, txnGroups, version, evalOverrides, execTraceConfig, initialStates }) {
    this.lastRound = ensureBigInt(lastRound);
    this.txnGroups = txnGroups;
    this.version = ensureSafeInteger(version);
    this.evalOverrides = evalOverrides;
    this.execTraceConfig = execTraceConfig;
    this.initialStates = initialStates;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["last-round", this.lastRound],
      ["txn-groups", this.txnGroups.map((v) => v.toEncodingData())],
      ["version", this.version],
      [
        "eval-overrides",
        typeof this.evalOverrides !== "undefined" ? this.evalOverrides.toEncodingData() : void 0
      ],
      [
        "exec-trace-config",
        typeof this.execTraceConfig !== "undefined" ? this.execTraceConfig.toEncodingData() : void 0
      ],
      [
        "initial-states",
        typeof this.initialStates !== "undefined" ? this.initialStates.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateResponse: ${data}`);
    }
    return new _SimulateResponse({
      lastRound: data.get("last-round"),
      txnGroups: (data.get("txn-groups") ?? []).map((v) => SimulateTransactionGroupResult.fromEncodingData(v)),
      version: data.get("version"),
      evalOverrides: typeof data.get("eval-overrides") !== "undefined" ? SimulationEvalOverrides.fromEncodingData(data.get("eval-overrides")) : void 0,
      execTraceConfig: typeof data.get("exec-trace-config") !== "undefined" ? SimulateTraceConfig.fromEncodingData(data.get("exec-trace-config")) : void 0,
      initialStates: typeof data.get("initial-states") !== "undefined" ? SimulateInitialStates.fromEncodingData(data.get("initial-states")) : void 0
    });
  }
};
var SimulateTraceConfig = class _SimulateTraceConfig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "enable",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "scratch-change",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "stack-change",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "state-change",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateTraceConfig` object.
   * @param enable - A boolean option for opting in execution trace features simulation endpoint.
   * @param scratchChange - A boolean option enabling returning scratch slot changes together with execution
   * trace during simulation.
   * @param stackChange - A boolean option enabling returning stack changes together with execution trace
   * during simulation.
   * @param stateChange - A boolean option enabling returning application state changes (global, local,
   * and box changes) with the execution trace during simulation.
   */
  constructor({ enable, scratchChange, stackChange, stateChange }) {
    this.enable = enable;
    this.scratchChange = scratchChange;
    this.stackChange = stackChange;
    this.stateChange = stateChange;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateTraceConfig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["enable", this.enable],
      ["scratch-change", this.scratchChange],
      ["stack-change", this.stackChange],
      ["state-change", this.stateChange]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateTraceConfig: ${data}`);
    }
    return new _SimulateTraceConfig({
      enable: data.get("enable"),
      scratchChange: data.get("scratch-change"),
      stackChange: data.get("stack-change"),
      stateChange: data.get("state-change")
    });
  }
};
var SimulateTransactionGroupResult = class _SimulateTransactionGroupResult {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txn-results",
        valueSchema: new ArraySchema(SimulateTransactionResult.encodingSchema),
        omitEmpty: true
      }, {
        key: "app-budget-added",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "app-budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "failed-at",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "failure-message",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unnamed-resources-accessed",
        valueSchema: new OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateTransactionGroupResult` object.
   * @param txnResults - Simulation result for individual transactions
   * @param appBudgetAdded - Total budget added during execution of app calls in the transaction group.
   * @param appBudgetConsumed - Total budget consumed during execution of app calls in the transaction group.
   * @param failedAt - If present, indicates which transaction in this group caused the failure. This
   * array represents the path to the failing transaction. Indexes are zero based,
   * the first element indicates the top-level transaction, and successive elements
   * indicate deeper inner transactions.
   * @param failureMessage - If present, indicates that the transaction group failed and specifies why that
   * happened
   * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
   * caused failure, but were allowed in simulation. Depending on where this object
   * is in the response, the unnamed resources it contains may or may not qualify for
   * group resource sharing. If this is a field in SimulateTransactionGroupResult,
   * the resources do qualify, but if this is a field in SimulateTransactionResult,
   * they do not qualify. In order to make this group valid for actual submission,
   * resources that qualify for group sharing can be made available by any
   * transaction of the group; otherwise, resources must be placed in the same
   * transaction which accessed them.
   */
  constructor({ txnResults, appBudgetAdded, appBudgetConsumed, failedAt, failureMessage, unnamedResourcesAccessed }) {
    this.txnResults = txnResults;
    this.appBudgetAdded = typeof appBudgetAdded === "undefined" ? void 0 : ensureSafeInteger(appBudgetAdded);
    this.appBudgetConsumed = typeof appBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(appBudgetConsumed);
    this.failedAt = typeof failedAt === "undefined" ? void 0 : failedAt.map(ensureSafeInteger);
    this.failureMessage = failureMessage;
    this.unnamedResourcesAccessed = unnamedResourcesAccessed;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateTransactionGroupResult.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn-results", this.txnResults.map((v) => v.toEncodingData())],
      ["app-budget-added", this.appBudgetAdded],
      ["app-budget-consumed", this.appBudgetConsumed],
      ["failed-at", this.failedAt],
      ["failure-message", this.failureMessage],
      [
        "unnamed-resources-accessed",
        typeof this.unnamedResourcesAccessed !== "undefined" ? this.unnamedResourcesAccessed.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateTransactionGroupResult: ${data}`);
    }
    return new _SimulateTransactionGroupResult({
      txnResults: (data.get("txn-results") ?? []).map((v) => SimulateTransactionResult.fromEncodingData(v)),
      appBudgetAdded: data.get("app-budget-added"),
      appBudgetConsumed: data.get("app-budget-consumed"),
      failedAt: data.get("failed-at"),
      failureMessage: data.get("failure-message"),
      unnamedResourcesAccessed: typeof data.get("unnamed-resources-accessed") !== "undefined" ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get("unnamed-resources-accessed")) : void 0
    });
  }
};
var SimulateTransactionResult = class _SimulateTransactionResult {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txn-result",
        valueSchema: PendingTransactionResponse.encodingSchema,
        omitEmpty: true
      }, {
        key: "app-budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "exec-trace",
        valueSchema: new OptionalSchema(SimulationTransactionExecTrace.encodingSchema),
        omitEmpty: true
      }, {
        key: "fixed-signer",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "logic-sig-budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "unnamed-resources-accessed",
        valueSchema: new OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateTransactionResult` object.
   * @param txnResult - Details about a pending transaction. If the transaction was recently confirmed,
   * includes confirmation details like the round and reward details.
   * @param appBudgetConsumed - Budget used during execution of an app call transaction. This value includes
   * budged used by inner app calls spawned by this transaction.
   * @param execTrace - The execution trace of calling an app or a logic sig, containing the inner app
   * call trace in a recursive way.
   * @param fixedSigner - The account that needed to sign this transaction when no signature was provided
   * and the provided signer was incorrect.
   * @param logicSigBudgetConsumed - Budget used during execution of a logic sig transaction.
   * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
   * caused failure, but were allowed in simulation. Depending on where this object
   * is in the response, the unnamed resources it contains may or may not qualify for
   * group resource sharing. If this is a field in SimulateTransactionGroupResult,
   * the resources do qualify, but if this is a field in SimulateTransactionResult,
   * they do not qualify. In order to make this group valid for actual submission,
   * resources that qualify for group sharing can be made available by any
   * transaction of the group; otherwise, resources must be placed in the same
   * transaction which accessed them.
   */
  constructor({ txnResult, appBudgetConsumed, execTrace, fixedSigner, logicSigBudgetConsumed, unnamedResourcesAccessed }) {
    this.txnResult = txnResult;
    this.appBudgetConsumed = typeof appBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(appBudgetConsumed);
    this.execTrace = execTrace;
    this.fixedSigner = typeof fixedSigner === "string" ? Address.fromString(fixedSigner) : fixedSigner;
    this.logicSigBudgetConsumed = typeof logicSigBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(logicSigBudgetConsumed);
    this.unnamedResourcesAccessed = unnamedResourcesAccessed;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateTransactionResult.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn-result", this.txnResult.toEncodingData()],
      ["app-budget-consumed", this.appBudgetConsumed],
      [
        "exec-trace",
        typeof this.execTrace !== "undefined" ? this.execTrace.toEncodingData() : void 0
      ],
      [
        "fixed-signer",
        typeof this.fixedSigner !== "undefined" ? this.fixedSigner.toString() : void 0
      ],
      ["logic-sig-budget-consumed", this.logicSigBudgetConsumed],
      [
        "unnamed-resources-accessed",
        typeof this.unnamedResourcesAccessed !== "undefined" ? this.unnamedResourcesAccessed.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateTransactionResult: ${data}`);
    }
    return new _SimulateTransactionResult({
      txnResult: PendingTransactionResponse.fromEncodingData(data.get("txn-result") ?? /* @__PURE__ */ new Map()),
      appBudgetConsumed: data.get("app-budget-consumed"),
      execTrace: typeof data.get("exec-trace") !== "undefined" ? SimulationTransactionExecTrace.fromEncodingData(data.get("exec-trace")) : void 0,
      fixedSigner: data.get("fixed-signer"),
      logicSigBudgetConsumed: data.get("logic-sig-budget-consumed"),
      unnamedResourcesAccessed: typeof data.get("unnamed-resources-accessed") !== "undefined" ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get("unnamed-resources-accessed")) : void 0
    });
  }
};
var SimulateUnnamedResourcesAccessed = class _SimulateUnnamedResourcesAccessed {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "app-locals",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalReference.encodingSchema)),
        omitEmpty: true
      }, {
        key: "apps",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "asset-holdings",
        valueSchema: new OptionalSchema(new ArraySchema(AssetHoldingReference.encodingSchema)),
        omitEmpty: true
      }, {
        key: "assets",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "boxes",
        valueSchema: new OptionalSchema(new ArraySchema(BoxReference.encodingSchema)),
        omitEmpty: true
      }, {
        key: "extra-box-refs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateUnnamedResourcesAccessed` object.
   * @param accounts - The unnamed accounts that were referenced. The order of this array is arbitrary.
   * @param appLocals - The unnamed application local states that were referenced. The order of this
   * array is arbitrary.
   * @param apps - The unnamed applications that were referenced. The order of this array is
   * arbitrary.
   * @param assetHoldings - The unnamed asset holdings that were referenced. The order of this array is
   * arbitrary.
   * @param assets - The unnamed assets that were referenced. The order of this array is arbitrary.
   * @param boxes - The unnamed boxes that were referenced. The order of this array is arbitrary.
   * @param extraBoxRefs - The number of extra box references used to increase the IO budget. This is in
   * addition to the references defined in the input transaction group and any
   * referenced to unnamed boxes.
   */
  constructor({ accounts, appLocals, apps, assetHoldings, assets, boxes, extraBoxRefs }) {
    this.accounts = typeof accounts !== "undefined" ? accounts.map((addr) => typeof addr === "string" ? Address.fromString(addr) : addr) : void 0;
    this.appLocals = appLocals;
    this.apps = typeof apps === "undefined" ? void 0 : apps.map(ensureBigInt);
    this.assetHoldings = assetHoldings;
    this.assets = typeof assets === "undefined" ? void 0 : assets.map(ensureBigInt);
    this.boxes = boxes;
    this.extraBoxRefs = typeof extraBoxRefs === "undefined" ? void 0 : ensureSafeInteger(extraBoxRefs);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateUnnamedResourcesAccessed.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "accounts",
        typeof this.accounts !== "undefined" ? this.accounts.map((v) => v.toString()) : void 0
      ],
      [
        "app-locals",
        typeof this.appLocals !== "undefined" ? this.appLocals.map((v) => v.toEncodingData()) : void 0
      ],
      ["apps", this.apps],
      [
        "asset-holdings",
        typeof this.assetHoldings !== "undefined" ? this.assetHoldings.map((v) => v.toEncodingData()) : void 0
      ],
      ["assets", this.assets],
      [
        "boxes",
        typeof this.boxes !== "undefined" ? this.boxes.map((v) => v.toEncodingData()) : void 0
      ],
      ["extra-box-refs", this.extraBoxRefs]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateUnnamedResourcesAccessed: ${data}`);
    }
    return new _SimulateUnnamedResourcesAccessed({
      accounts: data.get("accounts"),
      appLocals: typeof data.get("app-locals") !== "undefined" ? data.get("app-locals").map((v) => ApplicationLocalReference.fromEncodingData(v)) : void 0,
      apps: data.get("apps"),
      assetHoldings: typeof data.get("asset-holdings") !== "undefined" ? data.get("asset-holdings").map((v) => AssetHoldingReference.fromEncodingData(v)) : void 0,
      assets: data.get("assets"),
      boxes: typeof data.get("boxes") !== "undefined" ? data.get("boxes").map((v) => BoxReference.fromEncodingData(v)) : void 0,
      extraBoxRefs: data.get("extra-box-refs")
    });
  }
};
var SimulationEvalOverrides = class _SimulationEvalOverrides {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "allow-empty-signatures",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "allow-unnamed-resources",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "extra-opcode-budget",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "fix-signers",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "max-log-calls",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "max-log-size",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulationEvalOverrides` object.
   * @param allowEmptySignatures - If true, transactions without signatures are allowed and simulated as if they
   * were properly signed.
   * @param allowUnnamedResources - If true, allows access to unnamed resources during simulation.
   * @param extraOpcodeBudget - The extra opcode budget added to each transaction group during simulation
   * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
   * during evaluation.
   * @param maxLogCalls - The maximum log calls one can make during simulation
   * @param maxLogSize - The maximum byte number to log during simulation
   */
  constructor({ allowEmptySignatures, allowUnnamedResources, extraOpcodeBudget, fixSigners, maxLogCalls, maxLogSize }) {
    this.allowEmptySignatures = allowEmptySignatures;
    this.allowUnnamedResources = allowUnnamedResources;
    this.extraOpcodeBudget = typeof extraOpcodeBudget === "undefined" ? void 0 : ensureSafeInteger(extraOpcodeBudget);
    this.fixSigners = fixSigners;
    this.maxLogCalls = typeof maxLogCalls === "undefined" ? void 0 : ensureSafeInteger(maxLogCalls);
    this.maxLogSize = typeof maxLogSize === "undefined" ? void 0 : ensureSafeInteger(maxLogSize);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulationEvalOverrides.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["allow-empty-signatures", this.allowEmptySignatures],
      ["allow-unnamed-resources", this.allowUnnamedResources],
      ["extra-opcode-budget", this.extraOpcodeBudget],
      ["fix-signers", this.fixSigners],
      ["max-log-calls", this.maxLogCalls],
      ["max-log-size", this.maxLogSize]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulationEvalOverrides: ${data}`);
    }
    return new _SimulationEvalOverrides({
      allowEmptySignatures: data.get("allow-empty-signatures"),
      allowUnnamedResources: data.get("allow-unnamed-resources"),
      extraOpcodeBudget: data.get("extra-opcode-budget"),
      fixSigners: data.get("fix-signers"),
      maxLogCalls: data.get("max-log-calls"),
      maxLogSize: data.get("max-log-size")
    });
  }
};
var SimulationOpcodeTraceUnit = class _SimulationOpcodeTraceUnit {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "pc", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "scratch-changes",
        valueSchema: new OptionalSchema(new ArraySchema(ScratchChange.encodingSchema)),
        omitEmpty: true
      }, {
        key: "spawned-inners",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "stack-additions",
        valueSchema: new OptionalSchema(new ArraySchema(AvmValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "stack-pop-count",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "state-changes",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationStateOperation.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulationOpcodeTraceUnit` object.
   * @param pc - The program counter of the current opcode being evaluated.
   * @param scratchChanges - The writes into scratch slots.
   * @param spawnedInners - The indexes of the traces for inner transactions spawned by this opcode, if any.
   * @param stackAdditions - The values added by this opcode to the stack.
   * @param stackPopCount - The number of deleted stack values by this opcode.
   * @param stateChanges - The operations against the current application's states.
   */
  constructor({ pc, scratchChanges, spawnedInners, stackAdditions, stackPopCount, stateChanges }) {
    this.pc = ensureSafeInteger(pc);
    this.scratchChanges = scratchChanges;
    this.spawnedInners = typeof spawnedInners === "undefined" ? void 0 : spawnedInners.map(ensureSafeInteger);
    this.stackAdditions = stackAdditions;
    this.stackPopCount = typeof stackPopCount === "undefined" ? void 0 : ensureSafeInteger(stackPopCount);
    this.stateChanges = stateChanges;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulationOpcodeTraceUnit.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["pc", this.pc],
      [
        "scratch-changes",
        typeof this.scratchChanges !== "undefined" ? this.scratchChanges.map((v) => v.toEncodingData()) : void 0
      ],
      ["spawned-inners", this.spawnedInners],
      [
        "stack-additions",
        typeof this.stackAdditions !== "undefined" ? this.stackAdditions.map((v) => v.toEncodingData()) : void 0
      ],
      ["stack-pop-count", this.stackPopCount],
      [
        "state-changes",
        typeof this.stateChanges !== "undefined" ? this.stateChanges.map((v) => v.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulationOpcodeTraceUnit: ${data}`);
    }
    return new _SimulationOpcodeTraceUnit({
      pc: data.get("pc"),
      scratchChanges: typeof data.get("scratch-changes") !== "undefined" ? data.get("scratch-changes").map((v) => ScratchChange.fromEncodingData(v)) : void 0,
      spawnedInners: data.get("spawned-inners"),
      stackAdditions: typeof data.get("stack-additions") !== "undefined" ? data.get("stack-additions").map((v) => AvmValue.fromEncodingData(v)) : void 0,
      stackPopCount: data.get("stack-pop-count"),
      stateChanges: typeof data.get("state-changes") !== "undefined" ? data.get("state-changes").map((v) => ApplicationStateOperation.fromEncodingData(v)) : void 0
    });
  }
};
var SimulationTransactionExecTrace = class _SimulationTransactionExecTrace {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "approval-program-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "approval-program-trace",
        valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
        omitEmpty: true
      }, {
        key: "clear-state-program-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "clear-state-program-trace",
        valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
        omitEmpty: true
      }, {
        key: "clear-state-rollback",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "clear-state-rollback-error",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "inner-trace",
        valueSchema: new OptionalSchema(new ArraySchema(_SimulationTransactionExecTrace.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logic-sig-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "logic-sig-trace",
        valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulationTransactionExecTrace` object.
   * @param approvalProgramHash - SHA512_256 hash digest of the approval program executed in transaction.
   * @param approvalProgramTrace - Program trace that contains a trace of opcode effects in an approval program.
   * @param clearStateProgramHash - SHA512_256 hash digest of the clear state program executed in transaction.
   * @param clearStateProgramTrace - Program trace that contains a trace of opcode effects in a clear state program.
   * @param clearStateRollback - If true, indicates that the clear state program failed and any persistent state
   * changes it produced should be reverted once the program exits.
   * @param clearStateRollbackError - The error message explaining why the clear state program failed. This field will
   * only be populated if clear-state-rollback is true and the failure was due to an
   * execution error.
   * @param innerTrace - An array of SimulationTransactionExecTrace representing the execution trace of
   * any inner transactions executed.
   * @param logicSigHash - SHA512_256 hash digest of the logic sig executed in transaction.
   * @param logicSigTrace - Program trace that contains a trace of opcode effects in a logic sig.
   */
  constructor({ approvalProgramHash, approvalProgramTrace, clearStateProgramHash, clearStateProgramTrace, clearStateRollback, clearStateRollbackError, innerTrace, logicSigHash, logicSigTrace }) {
    this.approvalProgramHash = typeof approvalProgramHash === "string" ? base64ToBytes(approvalProgramHash) : approvalProgramHash;
    this.approvalProgramTrace = approvalProgramTrace;
    this.clearStateProgramHash = typeof clearStateProgramHash === "string" ? base64ToBytes(clearStateProgramHash) : clearStateProgramHash;
    this.clearStateProgramTrace = clearStateProgramTrace;
    this.clearStateRollback = clearStateRollback;
    this.clearStateRollbackError = clearStateRollbackError;
    this.innerTrace = innerTrace;
    this.logicSigHash = typeof logicSigHash === "string" ? base64ToBytes(logicSigHash) : logicSigHash;
    this.logicSigTrace = logicSigTrace;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulationTransactionExecTrace.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approval-program-hash", this.approvalProgramHash],
      [
        "approval-program-trace",
        typeof this.approvalProgramTrace !== "undefined" ? this.approvalProgramTrace.map((v) => v.toEncodingData()) : void 0
      ],
      ["clear-state-program-hash", this.clearStateProgramHash],
      [
        "clear-state-program-trace",
        typeof this.clearStateProgramTrace !== "undefined" ? this.clearStateProgramTrace.map((v) => v.toEncodingData()) : void 0
      ],
      ["clear-state-rollback", this.clearStateRollback],
      ["clear-state-rollback-error", this.clearStateRollbackError],
      [
        "inner-trace",
        typeof this.innerTrace !== "undefined" ? this.innerTrace.map((v) => v.toEncodingData()) : void 0
      ],
      ["logic-sig-hash", this.logicSigHash],
      [
        "logic-sig-trace",
        typeof this.logicSigTrace !== "undefined" ? this.logicSigTrace.map((v) => v.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulationTransactionExecTrace: ${data}`);
    }
    return new _SimulationTransactionExecTrace({
      approvalProgramHash: data.get("approval-program-hash"),
      approvalProgramTrace: typeof data.get("approval-program-trace") !== "undefined" ? data.get("approval-program-trace").map((v) => SimulationOpcodeTraceUnit.fromEncodingData(v)) : void 0,
      clearStateProgramHash: data.get("clear-state-program-hash"),
      clearStateProgramTrace: typeof data.get("clear-state-program-trace") !== "undefined" ? data.get("clear-state-program-trace").map((v) => SimulationOpcodeTraceUnit.fromEncodingData(v)) : void 0,
      clearStateRollback: data.get("clear-state-rollback"),
      clearStateRollbackError: data.get("clear-state-rollback-error"),
      innerTrace: typeof data.get("inner-trace") !== "undefined" ? data.get("inner-trace").map((v) => _SimulationTransactionExecTrace.fromEncodingData(v)) : void 0,
      logicSigHash: data.get("logic-sig-hash"),
      logicSigTrace: typeof data.get("logic-sig-trace") !== "undefined" ? data.get("logic-sig-trace").map((v) => SimulationOpcodeTraceUnit.fromEncodingData(v)) : void 0
    });
  }
};
var StateProof2 = class _StateProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "Message",
        valueSchema: StateProofMessage2.encodingSchema,
        omitEmpty: true
      }, {
        key: "StateProof",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProof` object.
   * @param message - Represents the message that the state proofs are attesting to.
   * @param stateproof - The encoded StateProof for the message.
   */
  constructor({ message, stateproof }) {
    this.message = message;
    this.stateproof = typeof stateproof === "string" ? base64ToBytes(stateproof) : stateproof;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Message", this.message.toEncodingData()],
      ["StateProof", this.stateproof]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProof: ${data}`);
    }
    return new _StateProof({
      message: StateProofMessage2.fromEncodingData(data.get("Message") ?? /* @__PURE__ */ new Map()),
      stateproof: data.get("StateProof")
    });
  }
};
var StateProofMessage2 = class _StateProofMessage {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "BlockHeadersCommitment",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "FirstAttestedRound",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "LastAttestedRound",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "LnProvenWeight",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "VotersCommitment",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofMessage` object.
   * @param blockheaderscommitment - The vector commitment root on all light block headers within a state proof
   * interval.
   * @param firstattestedround - The first round the message attests to.
   * @param lastattestedround - The last round the message attests to.
   * @param lnprovenweight - An integer value representing the natural log of the proven weight with 16 bits
   * of precision. This value would be used to verify the next state proof.
   * @param voterscommitment - The vector commitment root of the top N accounts to sign the next StateProof.
   */
  constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment }) {
    this.blockheaderscommitment = typeof blockheaderscommitment === "string" ? base64ToBytes(blockheaderscommitment) : blockheaderscommitment;
    this.firstattestedround = ensureBigInt(firstattestedround);
    this.lastattestedround = ensureBigInt(lastattestedround);
    this.lnprovenweight = ensureBigInt(lnprovenweight);
    this.voterscommitment = typeof voterscommitment === "string" ? base64ToBytes(voterscommitment) : voterscommitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofMessage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["BlockHeadersCommitment", this.blockheaderscommitment],
      ["FirstAttestedRound", this.firstattestedround],
      ["LastAttestedRound", this.lastattestedround],
      ["LnProvenWeight", this.lnprovenweight],
      ["VotersCommitment", this.voterscommitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofMessage: ${data}`);
    }
    return new _StateProofMessage({
      blockheaderscommitment: data.get("BlockHeadersCommitment"),
      firstattestedround: data.get("FirstAttestedRound"),
      lastattestedround: data.get("LastAttestedRound"),
      lnprovenweight: data.get("LnProvenWeight"),
      voterscommitment: data.get("VotersCommitment")
    });
  }
};
var SupplyResponse = class _SupplyResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current_round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "online-money",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "total-money", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SupplyResponse` object.
   * @param currentRound - Round
   * @param onlineMoney - OnlineMoney
   * @param totalMoney - TotalMoney
   */
  constructor({ currentRound, onlineMoney, totalMoney }) {
    this.currentRound = ensureBigInt(currentRound);
    this.onlineMoney = ensureBigInt(onlineMoney);
    this.totalMoney = ensureBigInt(totalMoney);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SupplyResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current_round", this.currentRound],
      ["online-money", this.onlineMoney],
      ["total-money", this.totalMoney]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SupplyResponse: ${data}`);
    }
    return new _SupplyResponse({
      currentRound: data.get("current_round"),
      onlineMoney: data.get("online-money"),
      totalMoney: data.get("total-money")
    });
  }
};
var TealKeyValue = class _TealKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: TealValue2.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealKeyValue: ${data}`);
    }
    return new _TealKeyValue({
      key: data.get("key"),
      value: TealValue2.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var TealValue2 = class _TealValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "bytes", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealValue` object.
   * @param bytes - (tb) bytes value.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param uint - (ui) uint value.
   */
  constructor({ bytes, type, uint }) {
    this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
    this.type = ensureSafeInteger(type);
    this.uint = ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["bytes", this.bytes],
      ["type", this.type],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealValue: ${data}`);
    }
    return new _TealValue({
      bytes: data.get("bytes"),
      type: data.get("type"),
      uint: data.get("uint")
    });
  }
};
var TransactionGroupLedgerStateDeltasForRoundResponse = class _TransactionGroupLedgerStateDeltasForRoundResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "Deltas",
        valueSchema: new ArraySchema(LedgerStateDeltaForTransactionGroup.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionGroupLedgerStateDeltasForRoundResponse` object.
   * @param deltas -
   */
  constructor({ deltas }) {
    this.deltas = deltas;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionGroupLedgerStateDeltasForRoundResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Deltas", this.deltas.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionGroupLedgerStateDeltasForRoundResponse: ${data}`);
    }
    return new _TransactionGroupLedgerStateDeltasForRoundResponse({
      deltas: (data.get("Deltas") ?? []).map((v) => LedgerStateDeltaForTransactionGroup.fromEncodingData(v))
    });
  }
};
var TransactionParametersResponse = class _TransactionParametersResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "consensus-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "fee", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "genesis-hash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "genesis-id", valueSchema: new StringSchema(), omitEmpty: true }, { key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "min-fee", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionParametersResponse` object.
   * @param consensusVersion - ConsensusVersion indicates the consensus protocol version
   * as of LastRound.
   * @param fee - Fee is the suggested transaction fee
   * Fee is in units of micro-Algos per byte.
   * Fee may fall to zero but transactions must still have a fee of
   * at least MinTxnFee for the current network protocol.
   * @param genesisHash - GenesisHash is the hash of the genesis block.
   * @param genesisId - GenesisID is an ID listed in the genesis block.
   * @param lastRound - LastRound indicates the last round seen
   * @param minFee - The minimum transaction fee (not per byte) required for the
   * txn to validate for the current network protocol.
   */
  constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
    this.consensusVersion = consensusVersion;
    this.fee = ensureBigInt(fee);
    this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
    this.genesisId = genesisId;
    this.lastRound = ensureBigInt(lastRound);
    this.minFee = ensureBigInt(minFee);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionParametersResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["consensus-version", this.consensusVersion],
      ["fee", this.fee],
      ["genesis-hash", this.genesisHash],
      ["genesis-id", this.genesisId],
      ["last-round", this.lastRound],
      ["min-fee", this.minFee]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionParametersResponse: ${data}`);
    }
    return new _TransactionParametersResponse({
      consensusVersion: data.get("consensus-version"),
      fee: data.get("fee"),
      genesisHash: data.get("genesis-hash"),
      genesisId: data.get("genesis-id"),
      lastRound: data.get("last-round"),
      minFee: data.get("min-fee")
    });
  }
};
var TransactionProof = class _TransactionProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "idx", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "proof", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
        key: "stibhash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "treedepth", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "hashtype",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionProof` object.
   * @param idx - Index of the transaction in the block's payset.
   * @param proof - Proof of transaction membership.
   * @param stibhash - Hash of SignedTxnInBlock for verifying proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   * @param hashtype - The type of hash function used to create the proof, must be one of:
   * * sha512_256
   * * sha256
   */
  constructor({ idx, proof, stibhash, treedepth, hashtype }) {
    this.idx = ensureSafeInteger(idx);
    this.proof = typeof proof === "string" ? base64ToBytes(proof) : proof;
    this.stibhash = typeof stibhash === "string" ? base64ToBytes(stibhash) : stibhash;
    this.treedepth = ensureSafeInteger(treedepth);
    this.hashtype = hashtype;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["idx", this.idx],
      ["proof", this.proof],
      ["stibhash", this.stibhash],
      ["treedepth", this.treedepth],
      ["hashtype", this.hashtype]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionProof: ${data}`);
    }
    return new _TransactionProof({
      idx: data.get("idx"),
      proof: data.get("proof"),
      stibhash: data.get("stibhash"),
      treedepth: data.get("treedepth"),
      hashtype: data.get("hashtype")
    });
  }
};
var Version = class _Version {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "build",
        valueSchema: BuildVersion.encodingSchema,
        omitEmpty: true
      }, {
        key: "genesis_hash_b64",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "genesis_id", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "versions",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Version` object.
   * @param build -
   * @param genesisHashB64 -
   * @param genesisId -
   * @param versions -
   */
  constructor({ build, genesisHashB64, genesisId, versions }) {
    this.build = build;
    this.genesisHashB64 = typeof genesisHashB64 === "string" ? base64ToBytes(genesisHashB64) : genesisHashB64;
    this.genesisId = genesisId;
    this.versions = versions;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Version.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["build", this.build.toEncodingData()],
      ["genesis_hash_b64", this.genesisHashB64],
      ["genesis_id", this.genesisId],
      ["versions", this.versions]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Version: ${data}`);
    }
    return new _Version({
      build: BuildVersion.fromEncodingData(data.get("build") ?? /* @__PURE__ */ new Map()),
      genesisHashB64: data.get("genesis_hash_b64"),
      genesisId: data.get("genesis_id"),
      versions: data.get("versions")
    });
  }
};

// node_modules/algosdk/dist/esm/client/v2/jsonrequest.js
var JSONRequest = class {
  /**
   * @param client - HTTPClient object.
   */
  constructor(client) {
    this.c = client;
    this.query = {};
  }
  /**
   * Execute the request
   */
  executeRequest(headers, customOptions) {
    return this.c.get({
      relativePath: this.path(),
      query: this.query,
      requestHeaders: headers,
      customOptions
    });
  }
  /**
   * Execute the request and decode the response.
   * @param headers - Additional headers to send in the request. Optional.
   * @param customOptions - Additional options to pass to the underlying BaseHTTPClient. For
   *   {@link URLTokenBaseHTTPClient}, which is the default client, this will be treated as
   *   additional options to pass to the network `fetch` method.
   * @returns A promise which resolves to the parsed response object.
   * @category JSONRequest
   */
  async do(headers, customOptions) {
    const res = await this.executeRequest(headers, customOptions);
    return this.prepare(res);
  }
  /**
   * Execute the request, but do not process the response data in any way.
   * @param headers - Additional headers to send in the request. Optional.
   * @param customOptions - Additional options to pass to the underlying BaseHTTPClient. For
   *   {@link URLTokenBaseHTTPClient}, which is the default client, this will be treated as
   *   additional options to pass to the network `fetch` method.
   * @returns A promise which resolves to the raw response data, exactly as returned by the server.
   * @category JSONRequest
   */
  async doRaw(headers, customOptions) {
    const res = await this.executeRequest(headers, customOptions);
    return res.body;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/accountInformation.js
var AccountInformation = class extends JSONRequest {
  constructor(c, account) {
    super(c);
    this.account = account.toString();
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Exclude assets and application data from results
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address)
   *        .exclude('all')
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Account);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/accountAssetInformation.js
var AccountAssetInformation = class extends JSONRequest {
  constructor(c, account, assetID) {
    super(c);
    this.account = account.toString();
    this.assetID = BigInt(assetID);
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountAssetResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/accountApplicationInformation.js
var AccountApplicationInformation = class extends JSONRequest {
  constructor(c, account, applicationID) {
    super(c);
    this.account = account.toString();
    this.applicationID = BigInt(applicationID);
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountApplicationResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/block.js
var Block2 = class extends JSONRequest {
  constructor(c, roundNumber) {
    super(c);
    this.round = BigInt(roundNumber);
    this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  /**
   * If true, only the block header (exclusive of payset or certificate) may be included in response.
   *
   * #### Example
   * ```typescript
   *
   * const roundNumber = 41000000;
   *
   * const blockResponse = await algodClient
   *        .block(roundNumber)
   *        .headerOnly(true)
   *        .do();
   * ```
   *
   * @param headerOnly - the flag indicating whether exclusively return header in response
   * @category query
   */
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, BlockResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/compile.js
function setHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
var Compile = class extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/compile`;
  }
  sourcemap(map = true) {
    this.query.sourcemap = map;
    return this;
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: coerceToBytes(this.source),
      query: this.query,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), CompileResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/dryrun.js
var Dryrun = class extends JSONRequest {
  constructor(c, dr) {
    super(c);
    this.blob = encodeMsgpack(dr);
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/teal/dryrun";
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: this.blob,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), DryrunResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/genesis.js
var Genesis2 = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/genesis";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return response.getJSONText();
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getAssetByID.js
var GetAssetByID = class extends JSONRequest {
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Asset);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getApplicationByID.js
var GetApplicationByID = class extends JSONRequest {
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Application);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getBlockHash.js
var GetBlockHash = class extends JSONRequest {
  constructor(c, roundNumber) {
    super(c);
    this.round = BigInt(roundNumber);
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BlockHashResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getBlockTxids.js
var GetBlockTxids = class extends JSONRequest {
  constructor(c, roundNumber) {
    super(c);
    this.round = BigInt(roundNumber);
  }
  path() {
    return `/v2/blocks/${this.round}/txids`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BlockTxidsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxByName.js
var GetApplicationBoxByName = class extends JSONRequest {
  constructor(c, index, name) {
    super(c);
    this.index = BigInt(index);
    const encodedName = bytesToBase64(name);
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Box);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxes.js
var GetApplicationBoxes = class extends JSONRequest {
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
    this.query.max = 0;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResult = await algodClient
   *        .GetApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  max(max) {
    this.query.max = max;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BoxesResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/healthCheck.js
var HealthCheck = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionInformation.js
var PendingTransactionInformation = class extends JSONRequest {
  constructor(c, txid) {
    super(c);
    this.txid = txid;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, PendingTransactionResponse);
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactions.js
var PendingTransactions = class extends JSONRequest {
  constructor(c) {
    super(c);
    this.query.format = "msgpack";
  }
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/pending";
  }
  prepare(response) {
    return decodeMsgpack(response.body, PendingTransactionsResponse);
  }
  /* eslint-enable class-methods-use-this */
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionsByAddress.js
var PendingTransactionsByAddress = class extends JSONRequest {
  constructor(c, address) {
    super(c);
    this.address = address.toString();
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, PendingTransactionsResponse);
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getTransactionProof.js
var GetTransactionProof = class extends JSONRequest {
  constructor(c, round, txID) {
    super(c);
    this.txID = txID;
    this.round = BigInt(round);
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  /**
   * Exclude assets and application data from results
   * The type of hash function used to create the proof, must be one of: "sha512_256", "sha256"
   *
   * #### Example
   * ```typescript
   * const hashType = "sha256";
   * const round = 123456;
   * const txId = "abc123;
   * const txProof = await algodClient.getTransactionProof(round, txId)
   *        .hashType(hashType)
   *        .do();
   * ```
   *
   * @param hashType
   * @category query
   */
  hashType(hashType) {
    this.query.hashtype = hashType;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionProof);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/sendRawTransaction.js
function setSendTransactionHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/x-binary";
  }
  return hdrs;
}
function isByteArray(array) {
  return array && array.byteLength !== void 0;
}
var SendRawTransaction = class extends JSONRequest {
  constructor(c, stxOrStxs) {
    super(c);
    let forPosting = stxOrStxs;
    if (Array.isArray(stxOrStxs)) {
      if (!stxOrStxs.every(isByteArray)) {
        throw new TypeError("Array elements must be byte arrays");
      }
      forPosting = concatArrays(...stxOrStxs);
    } else if (!isByteArray(forPosting)) {
      throw new TypeError("Argument must be byte array");
    }
    this.txnBytesToPost = forPosting;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setSendTransactionHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: this.txnBytesToPost,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), PostTransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/status.js
var Status = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/status";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), NodeStatusResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/statusAfterBlock.js
var StatusAfterBlock = class extends JSONRequest {
  constructor(c, round) {
    super(c);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), NodeStatusResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/suggestedParams.js
var SuggestedParamsRequest = class extends JSONRequest {
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/params";
  }
  prepare(response) {
    const params = decodeJSON(response.getJSONText(), TransactionParametersResponse);
    return {
      flatFee: false,
      fee: params.fee,
      firstValid: params.lastRound,
      lastValid: params.lastRound + BigInt(1e3),
      genesisID: params.genesisId,
      genesisHash: params.genesisHash,
      minFee: params.minFee,
      consensusVersion: params.consensusVersion
    };
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/supply.js
var Supply = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/ledger/supply";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), SupplyResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/versions.js
var Versions = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/versions";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Version);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/lightBlockHeaderProof.js
var LightBlockHeaderProof2 = class extends JSONRequest {
  constructor(c, round) {
    super(c);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), LightBlockHeaderProof);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/stateproof.js
var StateProof3 = class extends JSONRequest {
  constructor(c, round) {
    super(c);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), StateProof2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/setSyncRound.js
var SetSyncRound = class extends JSONRequest {
  constructor(c, round) {
    super(c);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/ledger/sync/${this.round}`;
  }
  executeRequest(headers, customOptions) {
    return this.c.post({
      relativePath: this.path(),
      data: null,
      requestHeaders: headers,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getSyncRound.js
var GetSyncRound = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/ledger/sync`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), GetSyncRoundResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/setBlockOffsetTimestamp.js
var SetBlockOffsetTimestamp = class extends JSONRequest {
  constructor(c, offset) {
    super(c);
    this.offset = BigInt(offset);
  }
  path() {
    return `/v2/devmode/blocks/offset/${this.offset}`;
  }
  executeRequest(headers, customOptions) {
    return this.c.post({
      relativePath: this.path(),
      data: null,
      requestHeaders: headers,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getBlockOffsetTimestamp.js
var GetBlockOffsetTimestamp = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/devmode/blocks/offset`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), GetBlockTimeStampOffsetResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/disassemble.js
function setHeaders2(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
var Disassemble = class extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/disassemble`;
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setHeaders2(headers);
    return this.c.post({
      relativePath: this.path(),
      data: coerceToBytes(this.source),
      query: this.query,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), DisassembleResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/simulateTransaction.js
function setSimulateTransactionsHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/msgpack";
  }
  return hdrs;
}
var SimulateRawTransactions = class extends JSONRequest {
  constructor(c, request) {
    super(c);
    this.query.format = "msgpack";
    this.requestBytes = encodeMsgpack(request);
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions/simulate";
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setSimulateTransactionsHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: this.requestBytes,
      query: this.query,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, SimulateResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/ready.js
var Ready = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/ready`;
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/unsetSyncRound.js
var UnsetSyncRound = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/ledger/sync`;
  }
  executeRequest(headers, customOptions) {
    return this.c.delete({
      relativePath: this.path(),
      data: void 0,
      requestHeaders: headers,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDeltaForTransactionGroup.js
var GetLedgerStateDeltaForTransactionGroup = class extends JSONRequest {
  constructor(c, id) {
    super(c);
    this.id = id;
    this.query = { format: "msgpack" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/txn/group/${this.id}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, LedgerStateDelta);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDelta.js
var GetLedgerStateDelta = class extends JSONRequest {
  constructor(c, round) {
    super(c);
    this.round = BigInt(round);
    this.query = { format: "msgpack" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, LedgerStateDelta);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getTransactionGroupLedgerStateDeltasForRound.js
var GetTransactionGroupLedgerStateDeltasForRound = class extends JSONRequest {
  constructor(c, round) {
    super(c);
    this.round = BigInt(round);
    this.query = { format: "msgpack" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/${this.round}/txn/group`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, TransactionGroupLedgerStateDeltasForRoundResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/algod.js
var AlgodClient = class extends ServiceClient {
  /**
   * Create an AlgodClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
   * const server = "http://localhost";
   * const port   = 4001;
   * const algodClient = new algosdk.Algodv2(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The algod token from the Algorand node you are interacting with
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer, port, headers = {}) {
    super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns OK if healthy.
   *
   * #### Example
   * ```typescript
   * await algodClient.healthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-health)
   * @category GET
   */
  healthCheck() {
    return new HealthCheck(this.c);
  }
  /**
   * Retrieves the supported API versions, binary build versions, and genesis information.
   *
   * #### Example
   * ```typescript
   * const versionsDetails = await algodClient.versionsCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-versions)
   * @category GET
   */
  versionsCheck() {
    return new Versions(this.c);
  }
  /**
   * Broadcasts a raw transaction to the network.
   *
   * #### Example
   * ```typescript
   * const { txid } = await algodClient.sendRawTransaction(signedTxns).do();
   * const result = await waitForConfirmation(algodClient, txid, 3);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactions)
   *
   * @remarks
   * Often used with {@linkcode waitForConfirmation}
   * @param stxOrStxs - Signed transactions
   * @category POST
   */
  sendRawTransaction(stxOrStxs) {
    return new SendRawTransaction(this.c, stxOrStxs);
  }
  /**
   * Returns the given account's status, balance and spendable amounts.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @category GET
   */
  accountInformation(account) {
    return new AccountInformation(this.c, account);
  }
  /**
   * Returns the given account's asset information for a specific asset.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountAssetInfo = await algodClient.accountAssetInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The asset ID to look up.
   * @category GET
   */
  accountAssetInformation(account, index) {
    return new AccountAssetInformation(this.c, account, index);
  }
  /**
   * Returns the given account's application information for a specific application.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountInfo = await algodClient.accountApplicationInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The application ID to look up.
   * @category GET
   */
  accountApplicationInformation(account, index) {
    return new AccountApplicationInformation(this.c, account, index);
  }
  /**
   * Gets the block info for the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.block(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksround)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  block(roundNumber) {
    return new Block2(this.c, roundNumber);
  }
  /**
   * Get the block hash for the block on the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.getBlockHash(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundhash)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  getBlockHash(roundNumber) {
    return new GetBlockHash(this.c, roundNumber);
  }
  /**
   * Get the top level transaction IDs for the block on the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.getBlockTxids(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundtxids)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  getBlockTxids(roundNumber) {
    return new GetBlockTxids(this.c, roundNumber);
  }
  /**
   * Returns the transaction information for a specific pending transaction.
   *
   * #### Example
   * ```typescript
   * const txId = "DRJS6R745A7GFVMXEXWP4TGVDGKW7VILFTA7HC2BR2GRLHNY5CTA";
   * const pending = await algodClient.pendingTransactionInformation(txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspendingtxid)
   *
   * @remarks
   * <br><br>
   * There are several cases when this might succeed:
   * - transaction committed (committed round > 0)
   * - transaction still in the pool (committed round = 0, pool error = "")
   * - transaction removed from pool due to error (committed round = 0, pool error != "")
   *
   * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
   *
   * @param txid - The TxID string of the pending transaction to look up.
   * @category GET
   */
  pendingTransactionInformation(txid) {
    return new PendingTransactionInformation(this.c, txid);
  }
  /**
   * Returns the list of pending transactions in the pool, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const pendingTxns = await algodClient.pendingTransactionsInformation().do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const pendingTxns = await algodClient
   *     .pendingTransactionsInformation()
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspending)
   * @category GET
   */
  pendingTransactionsInformation() {
    return new PendingTransactions(this.c);
  }
  /**
   * Returns the list of pending transactions sent by the address, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxnsByAddr = await algodClient.pendingTransactionByAddress(address).do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxns = await algodClient
   *     .pendingTransactionByAddress(address)
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddresstransactionspending)
   * @param address - The address of the sender.
   * @category GET
   */
  pendingTransactionByAddress(address) {
    return new PendingTransactionsByAddress(this.c, address);
  }
  /**
   * Retrieves the StatusResponse from the running node.
   *
   * #### Example
   * ```typescript
   * const status = await algodClient.status().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2status)
   * @category GET
   */
  status() {
    return new Status(this.c);
  }
  /**
   * Waits for a specific round to occur then returns the `StatusResponse` for that round.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const statusAfterBlock = await algodClient.statusAfterBlock(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2statuswait-for-block-afterround)
   * @param round - The number of the round to wait for.
   * @category GET
   */
  statusAfterBlock(round) {
    return new StatusAfterBlock(this.c, round);
  }
  /**
   * Returns the common needed parameters for a new transaction.
   *
   * #### Example
   * ```typescript
   * const suggestedParams = await algodClient.getTransactionParams().do();
   * const amountInMicroAlgos = algosdk.algosToMicroalgos(2); // 2 Algos
   * const unsignedTxn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
   *   sender: senderAddress,
   *   receiver: receiverAddress,
   *   amount: amountInMicroAlgos,
   *   suggestedParams: suggestedParams,
   * });
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionsparams)
   *
   * @remarks
   * Often used with
   * {@linkcode makePaymentTxnWithSuggestedParamsFromObject}, {@linkcode algosToMicroalgos}
   * @category GET
   */
  getTransactionParams() {
    return new SuggestedParamsRequest(this.c);
  }
  /**
   * Returns the supply details for the specified node's ledger.
   *
   * #### Example
   * ```typescript
   * const supplyDetails = await algodClient.supply().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersupply)
   * @category GET
   */
  supply() {
    return new Supply(this.c);
  }
  /**
   * Compiles TEAL source code to binary, returns base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style).
   *
   * #### Example
   * ```typescript
   * const source = "TEAL SOURCE CODE";
   * const compiledSmartContract = await algodClient.compile(source).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealcompile)
   * @remarks
   * This endpoint is only enabled when a node's configuration file sets `EnableDeveloperAPI` to true.
   * @param source
   * @category POST
   */
  compile(source) {
    return new Compile(this.c, source);
  }
  /**
   * Given the program bytes, return the TEAL source code in plain text.
   *
   * #### Example
   * ```typescript
   * const bytecode = "TEAL bytecode";
   * const disassembledSource = await algodClient.disassemble(bytecode).do();
   * ```
   *
   * @remarks This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
   * @param source
   */
  disassemble(source) {
    return new Disassemble(this.c, source);
  }
  /**
   * Provides debugging information for a transaction (or group).
   *
   * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configureation file sets `EnableDeveloperAPI` to true.
   *
   * #### Example
   * ```typescript
   * const dryRunResult = await algodClient.dryrun(dr).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealdryrun)
   * @param dr
   * @category POST
   */
  dryrun(dr) {
    return new Dryrun(this.c, dr);
  }
  /**
   * Given an asset ID, return asset information including creator, name, total supply and
   * special addresses.
   *
   * #### Example
   * ```typescript
   * const asset_id = 163650;
   * const asset = await algodClient.getAssetByID(asset_id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   * @category GET
   */
  getAssetByID(index) {
    return new GetAssetByID(this.c, index);
  }
  /**
   * Given an application ID, return the application information including creator, approval
   * and clear programs, global and local schemas, and global state.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const app = await algodClient.getApplicationByID(index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-id)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationByID(index) {
    return new GetApplicationByID(this.c, index);
  }
  /**
   * Given an application ID and the box name (key), return the value stored in the box.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxName = Buffer.from("foo");
   * const boxResponse = await algodClient.getApplicationBoxByName(index, boxName).do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idbox)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxByName(index, boxName) {
    return new GetApplicationBoxByName(this.c, index, boxName);
  }
  /**
   * Given an application ID, return all the box names associated with the app.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxesResponse = await algodClient.getApplicationBoxes(index).max(3).do();
   * const boxNames = boxesResponse.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idboxes)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxes(index) {
    return new GetApplicationBoxes(this.c, index);
  }
  /**
   * Returns the entire genesis file.
   *
   * #### Example
   * ```typescript
   * const genesis = await algodClient.genesis().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-genesis)
   * @category GET
   */
  genesis() {
    return new Genesis2(this.c);
  }
  /**
   * Returns a Merkle proof for a given transaction in a block.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const proof = await algodClient.getTransactionProof(round, txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundtransactionstxidproof)
   * @param round - The round in which the transaction appears.
   * @param txID - The transaction ID for which to generate a proof.
   * @category GET
   */
  getTransactionProof(round, txID) {
    return new GetTransactionProof(this.c, round, txID);
  }
  /**
   * Gets a proof for a given light block header inside a state proof commitment.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const lightBlockHeaderProof = await algodClient.getLightBlockHeaderProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2blocksroundlightheaderproof)
   * @param round
   */
  getLightBlockHeaderProof(round) {
    return new LightBlockHeaderProof2(this.c, round);
  }
  /**
   * Gets a state proof that covers a given round.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const stateProof = await algodClient.getStateProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2stateproofsround)
   * @param round
   */
  getStateProof(round) {
    return new StateProof3(this.c, round);
  }
  /**
   * Simulate a list of a signed transaction objects being sent to the network.
   *
   * #### Example
   * ```typescript
   * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
   * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
   * const txgroup = algosdk.assignGroupID([txn1, txn2]);
   *
   * // Actually sign the first transaction
   * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
   * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
   * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
   *
   * const resp = await client.simulateRawTransactions([signedTxn1, signedTxn2]).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
   * @param stxOrStxs
   * @category POST
   */
  simulateRawTransactions(stxOrStxs) {
    const txnObjects = [];
    if (Array.isArray(stxOrStxs)) {
      for (const stxn of stxOrStxs) {
        txnObjects.push(decodeMsgpack(stxn, SignedTransaction));
      }
    } else {
      txnObjects.push(decodeMsgpack(stxOrStxs, SignedTransaction));
    }
    const request = new SimulateRequest({
      txnGroups: [
        new SimulateRequestTransactionGroup({
          txns: txnObjects
        })
      ]
    });
    return this.simulateTransactions(request);
  }
  /**
   * Simulate transactions being sent to the network.
   *
   * #### Example
   * ```typescript
   * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
   * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
   * const txgroup = algosdk.assignGroupID([txn1, txn2]);
   *
   * // Actually sign the first transaction
   * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
   * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
   * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
   *
   * const request = new modelsv2.SimulateRequest({
   *  txnGroups: [
   *    new modelsv2.SimulateRequestTransactionGroup({
   *       // Must decode the signed txn bytes into an object
   *       txns: [algosdk.decodeObj(signedTxn1), algosdk.decodeObj(signedTxn2)]
   *     }),
   *   ],
   * });
   * const resp = await client.simulateRawTransactions(request).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
   * @param request
   * @category POST
   */
  simulateTransactions(request) {
    return new SimulateRawTransactions(this.c, request);
  }
  /**
   * Set the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
   *
   *  #### Example
   *  ```typesecript
   *  const offset = 60
   *  await client.setBlockOffsetTimestamp(offset).do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2devmodeblocksoffsetoffset)
   * @param offset
   * @category POST
   */
  setBlockOffsetTimestamp(offset) {
    return new SetBlockOffsetTimestamp(this.c, offset);
  }
  /**
   * Get the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
   *
   *  #### Example
   *  ```typesecript
   *  const currentOffset = await client.getBlockOffsetTimestamp().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2devmodeblocksoffset)
   * @category GET
   */
  getBlockOffsetTimestamp() {
    return new GetBlockOffsetTimestamp(this.c);
  }
  /**
   * Set the sync round on the ledger (algod must have EnableFollowMode: true), restricting catchup.
   *
   *  #### Example
   *  ```typesecript
   *  const round = 10000
   *  await client.setSyncRound(round).do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2ledgersyncround)
   * @param round
   * @category POST
   */
  setSyncRound(round) {
    return new SetSyncRound(this.c, round);
  }
  /**
   * Un-Set the sync round on the ledger (algod must have EnableFollowMode: true), removing the restriction on catchup.
   *
   *  #### Example
   *  ```typesecript
   *  await client.unsetSyncRound().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#delete-v2ledgersync)
   * @category DELETE
   */
  unsetSyncRound() {
    return new UnsetSyncRound(this.c);
  }
  /**
   * Get the current sync round on the ledger (algod must have EnableFollowMode: true).
   *
   *  #### Example
   *  ```typesecript
   *  const currentSyncRound = await client.getSyncRound().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersync)
   * @category GET
   */
  getSyncRound() {
    return new GetSyncRound(this.c);
  }
  /**
   * Ready check which returns 200 OK if algod is healthy and caught up
   *
   *  #### Example
   *  ```typesecript
   *  await client.ready().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-ready)
   * @category GET
   */
  ready() {
    return new Ready(this.c);
  }
  /**
   * GetLedgerStateDeltaForTransactionGroup returns the ledger delta for the txn group identified by id
   *
   * #### Example
   * ```typescript
   * const id = "ABC123";
   * await client.getLedgerStateDeltaForTransactionGroup(id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltastxngroupid)
   * @param id txn ID or group ID to be searched for
   * @category GET
   */
  getLedgerStateDeltaForTransactionGroup(id) {
    return new GetLedgerStateDeltaForTransactionGroup(this.c, id);
  }
  /**
   * GetLedgerStateDelta returns the ledger delta for the entire round
   *
   * #### Example
   * ```typescript
   * const round = 12345;
   * await client.getLedgerStateDelta(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasround)
   * @param round the round number to be searched for
   * @category GET
   */
  getLedgerStateDelta(round) {
    return new GetLedgerStateDelta(this.c, round);
  }
  /**
   * GetTransactionGroupLedgerStateDeltasForRound returns all ledger deltas for txn groups in the provided round
   *
   * #### Example
   * ```typescript
   * const round = 12345;
   * await client.getTransactionGroupLedgerStateDeltasForRound(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasroundtxngroup)
   * @param round the round number to be searched for
   * @category GET
   */
  getTransactionGroupLedgerStateDeltasForRound(round) {
    return new GetTransactionGroupLedgerStateDeltasForRound(this.c, round);
  }
};

// node_modules/algosdk/dist/esm/client/kmd.js
var KmdClient = class extends ServiceClient {
  constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
    super("X-KMD-API-Token", token, baseServer, port, headers);
  }
  async get(relativePath) {
    const res = await this.c.get({
      relativePath
    });
    return res.parseBodyAsJSON({
      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
      intDecoding: intDecoding_default.SAFE
    });
  }
  async delete(relativePath, data) {
    const res = await this.c.delete({
      relativePath,
      data
    });
    return res.parseBodyAsJSON({
      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
      intDecoding: intDecoding_default.SAFE
    });
  }
  async post(relativePath, data) {
    const res = await this.c.post({
      relativePath,
      data
    });
    return res.parseBodyAsJSON({
      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
      intDecoding: intDecoding_default.SAFE
    });
  }
  /**
   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
   */
  async versions() {
    return this.get("/versions");
  }
  /**
   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
   */
  async listWallets() {
    return this.get("/v1/wallets");
  }
  /**
   * createWallet creates a wallet with the specified name, password, driver,
   * and master derivation key. If the master derivation key is blank, one is
   * generated internally to kmd. CreateWallet returns a CreateWalletResponse
   * containing information about the new wallet.
   * @param walletName
   * @param walletPassword
   * @param walletDriverName
   * @param walletMDK
   */
  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = "sqlite") {
    const req = {
      wallet_name: walletName,
      wallet_driver_name: walletDriverName,
      wallet_password: walletPassword,
      master_derivation_key: bytesToBase64(walletMDK)
    };
    return this.post("/v1/wallet", req);
  }
  /**
   * initWalletHandle accepts a wallet ID and a wallet password, and returns an
   * initWalletHandleResponse containing a wallet handle token. This wallet
   * handle token can be used for subsequent operations on this wallet, like key
   * generation, transaction signing, etc.. WalletHandleTokens expire after a
   * configurable number of seconds, and must be renewed periodically with
   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
   * you're done interacting with this wallet.
   * @param walletID
   * @param walletPassword
   */
  async initWalletHandle(walletID, walletPassword) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword
    };
    return this.post("/v1/wallet/init", req);
  }
  /**
   * releaseWalletHandle invalidates the passed wallet handle token, making
   * it unusuable for subsequent wallet operations.
   * @param walletHandle
   */
  async releaseWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/wallet/release", req);
  }
  /**
   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
   * the expiration time to some number of seconds in the future. It returns a
   * RenewWalletHandleResponse containing the walletHandle and the number of
   * seconds until expiration
   * @param walletHandle
   */
  async renewWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/wallet/renew", req);
  }
  /**
   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
   * and renames the underlying wallet.
   * @param walletID
   * @param walletPassword
   * @param newWalletName
   */
  async renameWallet(walletID, walletPassword, newWalletName) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword,
      wallet_name: newWalletName
    };
    return this.post("/v1/wallet/rename", req);
  }
  /**
   * getWallet accepts a wallet handle and returns high level information about
   * this wallet in a GetWalletResponse.
   * @param walletHandle
   */
  async getWallet(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/wallet/info", req);
  }
  /**
   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
   * returns an ExportMasterDerivationKeyResponse containing the master
   * derivation key. This key can be used as an argument to CreateWallet in
   * order to recover the keys generated by this wallet. The master derivation
   * key can be encoded as a sequence of words using the mnemonic library, and
   * @param walletHandle
   * @param walletPassword
   */
  async exportMasterDerivationKey(walletHandle, walletPassword) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword
    };
    const res = await this.post("/v1/master-key/export", req);
    return {
      master_derivation_key: base64ToBytes(res.master_derivation_key)
    };
  }
  /**
   * importKey accepts a wallet handle and an ed25519 private key, and imports
   * the key into the wallet. It returns an ImportKeyResponse containing the
   * address corresponding to this private key.
   * @param walletHandle
   * @param secretKey
   */
  async importKey(walletHandle, secretKey) {
    const req = {
      wallet_handle_token: walletHandle,
      private_key: bytesToBase64(secretKey)
    };
    return this.post("/v1/key/import", req);
  }
  /**
   * exportKey accepts a wallet handle, wallet password, and address, and returns
   * an ExportKeyResponse containing the ed25519 private key corresponding to the
   * address stored in the wallet.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.post("/v1/key/export", req);
    return { private_key: base64ToBytes(res.private_key) };
  }
  /**
   * generateKey accepts a wallet handle, and then generates the next key in the
   * wallet using its internal master derivation key. Two wallets with the same
   * master derivation key will generate the same sequence of keys.
   * @param walletHandle
   */
  async generateKey(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle,
      display_mnemonic: false
    };
    return this.post("/v1/key", req);
  }
  /**
   * deleteKey accepts a wallet handle, wallet password, and address, and deletes
   * the information about this address from the wallet (including address and
   * secret key). If DeleteKey is called on a key generated using GenerateKey,
   * the same key will not be generated again. However, if a wallet is recovered
   * using the master derivation key, a key generated in this way can be
   * recovered.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    return this.delete("/v1/key", req);
  }
  /**
   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
   * all of the addresses for which this wallet contains secret keys.
   * @param walletHandle
   */
  async listKeys(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/key/list", req);
  }
  /**
   * signTransaction accepts a wallet handle, wallet password, and a transaction,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * Sender field.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   */
  async signTransaction(walletHandle, walletPassword, transaction) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: bytesToBase64(transaction.toByte())
    };
    const res = await this.post("/v1/transaction/sign", req);
    return base64ToBytes(res.signed_transaction);
  }
  /**
   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * publicKey arg.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)
   */
  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
    const pk = coerceToBytes(publicKey);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: bytesToBase64(transaction.toByte()),
      public_key: bytesToBase64(pk)
    };
    const res = await this.post("/v1/transaction/sign", req);
    return base64ToBytes(res.signed_transaction);
  }
  /**
   * listMultisig accepts a wallet handle and returns a ListMultisigResponse
   * containing the multisig addresses whose preimages are stored in this wallet.
   * A preimage is the information needed to reconstruct this multisig address,
   * including multisig version information, threshold information, and a list
   * of public keys.
   * @param walletHandle
   */
  async listMultisig(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/multisig/list", req);
  }
  /**
   * importMultisig accepts a wallet handle and the information required to
   * generate a multisig address. It derives this address, and stores all of the
   * information within the wallet. It returns a ImportMultisigResponse with the
   * derived address.
   * @param walletHandle
   * @param version
   * @param threshold
   * @param pks
   */
  async importMultisig(walletHandle, version, threshold, pks) {
    const req = {
      wallet_handle_token: walletHandle,
      multisig_version: version,
      threshold,
      pks
    };
    return this.post("/v1/multisig/import", req);
  }
  /**
   * exportMultisig accepts a wallet handle, wallet password, and multisig
   * address, and returns an ExportMultisigResponse containing the stored
   * multisig preimage. The preimage contains all of the information necessary
   * to derive the multisig address, including version, threshold, and a list of
   * public keys.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportMultisig(walletHandle, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr
    };
    return this.post("/v1/multisig/export", req);
  }
  /**
   * signMultisigTransaction accepts a wallet handle, wallet password,
   * transaction, public key (*not* an address), and an optional partial
   * MultisigSig. It looks up the secret key corresponding to the public key, and
   * returns a SignMultisigTransactionResponse containing a MultisigSig with a
   * signature by the secret key included.
   * @param walletHandle
   * @param pw
   * @param tx
   * @param pk
   * @param partial
   */
  async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
    const pubkey = coerceToBytes(pk);
    const req = {
      wallet_handle_token: walletHandle,
      transaction: bytesToBase64(transaction.toByte()),
      public_key: bytesToBase64(pubkey),
      partial_multisig: partial,
      wallet_password: pw
    };
    return this.post("/v1/multisig/sign", req);
  }
  /**
   * deleteMultisig accepts a wallet handle, wallet password, and multisig
   * address, and deletes the information about this multisig address from the
   * wallet (including address and secret key).
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteMultisig(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    return this.delete("/v1/multisig", req);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/models/types.js
var types_exports2 = {};
__export(types_exports2, {
  Account: () => Account2,
  AccountParticipation: () => AccountParticipation2,
  AccountResponse: () => AccountResponse,
  AccountStateDelta: () => AccountStateDelta2,
  AccountsResponse: () => AccountsResponse,
  Application: () => Application2,
  ApplicationLocalState: () => ApplicationLocalState2,
  ApplicationLocalStatesResponse: () => ApplicationLocalStatesResponse,
  ApplicationLogData: () => ApplicationLogData,
  ApplicationLogsResponse: () => ApplicationLogsResponse,
  ApplicationParams: () => ApplicationParams2,
  ApplicationResponse: () => ApplicationResponse,
  ApplicationStateSchema: () => ApplicationStateSchema2,
  ApplicationsResponse: () => ApplicationsResponse,
  Asset: () => Asset2,
  AssetBalancesResponse: () => AssetBalancesResponse,
  AssetHolding: () => AssetHolding3,
  AssetHoldingsResponse: () => AssetHoldingsResponse,
  AssetParams: () => AssetParams3,
  AssetResponse: () => AssetResponse,
  AssetsResponse: () => AssetsResponse,
  Block: () => Block3,
  BlockHeadersResponse: () => BlockHeadersResponse,
  BlockRewards: () => BlockRewards,
  BlockUpgradeState: () => BlockUpgradeState,
  BlockUpgradeVote: () => BlockUpgradeVote,
  Box: () => Box2,
  BoxDescriptor: () => BoxDescriptor2,
  BoxReference: () => BoxReference2,
  BoxesResponse: () => BoxesResponse2,
  ErrorResponse: () => ErrorResponse2,
  EvalDelta: () => EvalDelta3,
  EvalDeltaKeyValue: () => EvalDeltaKeyValue2,
  HashFactory: () => HashFactory2,
  HbProofFields: () => HbProofFields,
  HealthCheck: () => HealthCheck2,
  HoldingRef: () => HoldingRef,
  IndexerStateProofMessage: () => IndexerStateProofMessage,
  LocalsRef: () => LocalsRef,
  MerkleArrayProof: () => MerkleArrayProof2,
  MiniAssetHolding: () => MiniAssetHolding,
  ParticipationUpdates: () => ParticipationUpdates2,
  ResourceRef: () => ResourceRef,
  StateProofFields: () => StateProofFields,
  StateProofParticipant: () => StateProofParticipant,
  StateProofReveal: () => StateProofReveal,
  StateProofSigSlot: () => StateProofSigSlot,
  StateProofSignature: () => StateProofSignature,
  StateProofTracking: () => StateProofTracking,
  StateProofVerifier: () => StateProofVerifier,
  StateSchema: () => StateSchema2,
  TealKeyValue: () => TealKeyValue2,
  TealValue: () => TealValue3,
  Transaction: () => Transaction2,
  TransactionApplication: () => TransactionApplication,
  TransactionAssetConfig: () => TransactionAssetConfig,
  TransactionAssetFreeze: () => TransactionAssetFreeze,
  TransactionAssetTransfer: () => TransactionAssetTransfer,
  TransactionHeartbeat: () => TransactionHeartbeat,
  TransactionKeyreg: () => TransactionKeyreg,
  TransactionPayment: () => TransactionPayment,
  TransactionResponse: () => TransactionResponse,
  TransactionSignature: () => TransactionSignature,
  TransactionSignatureLogicsig: () => TransactionSignatureLogicsig,
  TransactionSignatureMultisig: () => TransactionSignatureMultisig,
  TransactionSignatureMultisigSubsignature: () => TransactionSignatureMultisigSubsignature,
  TransactionStateProof: () => TransactionStateProof,
  TransactionsResponse: () => TransactionsResponse
});
var Account2 = class _Account {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "amount-without-pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "min-balance",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "rewards", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "status", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "total-apps-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-assets-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-box-bytes",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-boxes",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-apps",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-assets",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "apps-local-state",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalState2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "apps-total-extra-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "apps-total-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "assets",
        valueSchema: new OptionalSchema(new ArraySchema(AssetHolding3.encodingSchema)),
        omitEmpty: true
      }, {
        key: "auth-addr",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "closed-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "created-apps",
        valueSchema: new OptionalSchema(new ArraySchema(Application2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "created-assets",
        valueSchema: new OptionalSchema(new ArraySchema(Asset2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "created-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "incentive-eligible",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "last-heartbeat",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "last-proposed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "participation",
        valueSchema: new OptionalSchema(AccountParticipation2.encodingSchema),
        omitEmpty: true
      }, {
        key: "reward-base",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-type",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param minBalance - MicroAlgo balance required by the account.
   * The requirement grows based on asset and application usage.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - total rewards of MicroAlgos the account has received, including pending rewards.
   * @param round - The round for which this information is relevant.
   * @param status - voting status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalBoxBytes - For app-accounts only. The total number of bytes allocated for the keys and
   * values of boxes which belong to the associated application.
   * @param totalBoxes - For app-accounts only. The total number of boxes which belong to the associated
   * application.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - application local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - the sum of all extra application program pages for this account.
   * @param appsTotalSchema - the sum of all of the local schemas and global schemas in this account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - The address against which signing should be checked. If empty, the address of
   * the current account is used. This field can be updated in any transaction by
   * setting the RekeyTo field.
   * @param closedAtRound - Round during which this account was most recently closed.
   * @param createdApps - parameters of applications created by this account including app global data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param createdAtRound - Round during which this account first appeared in a transaction.
   * @param deleted - Whether or not this account is currently closed.
   * @param incentiveEligible - can the account receive block incentives if its balance is in range at proposal
   * time.
   * @param lastHeartbeat - The round in which this account last went online, or explicitly renewed their
   * online status.
   * @param lastProposed - The round in which this account last proposed the block.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - used as part of the rewards computation. Only applicable to accounts which are
   * participating.
   * @param sigType - the type of signature used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * * or null if unknown
   */
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalBoxBytes, totalBoxes, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, closedAtRound, createdApps, createdAssets, createdAtRound, deleted, incentiveEligible, lastHeartbeat, lastProposed, participation, rewardBase, sigType }) {
    this.address = address;
    this.amount = ensureBigInt(amount);
    this.amountWithoutPendingRewards = ensureBigInt(amountWithoutPendingRewards);
    this.minBalance = ensureSafeInteger(minBalance);
    this.pendingRewards = ensureBigInt(pendingRewards);
    this.rewards = ensureBigInt(rewards);
    this.round = ensureBigInt(round);
    this.status = status;
    this.totalAppsOptedIn = ensureSafeInteger(totalAppsOptedIn);
    this.totalAssetsOptedIn = ensureSafeInteger(totalAssetsOptedIn);
    this.totalBoxBytes = ensureSafeInteger(totalBoxBytes);
    this.totalBoxes = ensureSafeInteger(totalBoxes);
    this.totalCreatedApps = ensureSafeInteger(totalCreatedApps);
    this.totalCreatedAssets = ensureSafeInteger(totalCreatedAssets);
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = typeof appsTotalExtraPages === "undefined" ? void 0 : ensureSafeInteger(appsTotalExtraPages);
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
    this.closedAtRound = typeof closedAtRound === "undefined" ? void 0 : ensureBigInt(closedAtRound);
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
    this.deleted = deleted;
    this.incentiveEligible = incentiveEligible;
    this.lastHeartbeat = typeof lastHeartbeat === "undefined" ? void 0 : ensureSafeInteger(lastHeartbeat);
    this.lastProposed = typeof lastProposed === "undefined" ? void 0 : ensureSafeInteger(lastProposed);
    this.participation = participation;
    this.rewardBase = typeof rewardBase === "undefined" ? void 0 : ensureBigInt(rewardBase);
    this.sigType = sigType;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Account.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["amount", this.amount],
      ["amount-without-pending-rewards", this.amountWithoutPendingRewards],
      ["min-balance", this.minBalance],
      ["pending-rewards", this.pendingRewards],
      ["rewards", this.rewards],
      ["round", this.round],
      ["status", this.status],
      ["total-apps-opted-in", this.totalAppsOptedIn],
      ["total-assets-opted-in", this.totalAssetsOptedIn],
      ["total-box-bytes", this.totalBoxBytes],
      ["total-boxes", this.totalBoxes],
      ["total-created-apps", this.totalCreatedApps],
      ["total-created-assets", this.totalCreatedAssets],
      [
        "apps-local-state",
        typeof this.appsLocalState !== "undefined" ? this.appsLocalState.map((v) => v.toEncodingData()) : void 0
      ],
      ["apps-total-extra-pages", this.appsTotalExtraPages],
      [
        "apps-total-schema",
        typeof this.appsTotalSchema !== "undefined" ? this.appsTotalSchema.toEncodingData() : void 0
      ],
      [
        "assets",
        typeof this.assets !== "undefined" ? this.assets.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "auth-addr",
        typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
      ],
      ["closed-at-round", this.closedAtRound],
      [
        "created-apps",
        typeof this.createdApps !== "undefined" ? this.createdApps.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "created-assets",
        typeof this.createdAssets !== "undefined" ? this.createdAssets.map((v) => v.toEncodingData()) : void 0
      ],
      ["created-at-round", this.createdAtRound],
      ["deleted", this.deleted],
      ["incentive-eligible", this.incentiveEligible],
      ["last-heartbeat", this.lastHeartbeat],
      ["last-proposed", this.lastProposed],
      [
        "participation",
        typeof this.participation !== "undefined" ? this.participation.toEncodingData() : void 0
      ],
      ["reward-base", this.rewardBase],
      ["sig-type", this.sigType]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Account: ${data}`);
    }
    return new _Account({
      address: data.get("address"),
      amount: data.get("amount"),
      amountWithoutPendingRewards: data.get("amount-without-pending-rewards"),
      minBalance: data.get("min-balance"),
      pendingRewards: data.get("pending-rewards"),
      rewards: data.get("rewards"),
      round: data.get("round"),
      status: data.get("status"),
      totalAppsOptedIn: data.get("total-apps-opted-in"),
      totalAssetsOptedIn: data.get("total-assets-opted-in"),
      totalBoxBytes: data.get("total-box-bytes"),
      totalBoxes: data.get("total-boxes"),
      totalCreatedApps: data.get("total-created-apps"),
      totalCreatedAssets: data.get("total-created-assets"),
      appsLocalState: typeof data.get("apps-local-state") !== "undefined" ? data.get("apps-local-state").map((v) => ApplicationLocalState2.fromEncodingData(v)) : void 0,
      appsTotalExtraPages: data.get("apps-total-extra-pages"),
      appsTotalSchema: typeof data.get("apps-total-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("apps-total-schema")) : void 0,
      assets: typeof data.get("assets") !== "undefined" ? data.get("assets").map((v) => AssetHolding3.fromEncodingData(v)) : void 0,
      authAddr: data.get("auth-addr"),
      closedAtRound: data.get("closed-at-round"),
      createdApps: typeof data.get("created-apps") !== "undefined" ? data.get("created-apps").map((v) => Application2.fromEncodingData(v)) : void 0,
      createdAssets: typeof data.get("created-assets") !== "undefined" ? data.get("created-assets").map((v) => Asset2.fromEncodingData(v)) : void 0,
      createdAtRound: data.get("created-at-round"),
      deleted: data.get("deleted"),
      incentiveEligible: data.get("incentive-eligible"),
      lastHeartbeat: data.get("last-heartbeat"),
      lastProposed: data.get("last-proposed"),
      participation: typeof data.get("participation") !== "undefined" ? AccountParticipation2.fromEncodingData(data.get("participation")) : void 0,
      rewardBase: data.get("reward-base"),
      sigType: data.get("sig-type")
    });
  }
};
var AccountParticipation2 = class _AccountParticipation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "selection-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "vote-first-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-key-dilution",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-last-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "state-proof-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - First round for which this participation is valid.
   * @param voteKeyDilution - Number of subkeys in each batch of participation keys.
   * @param voteLastValid - Last round for which this participation is valid.
   * @param voteParticipationKey - root participation public key (if any) currently registered for this round.
   * @param stateProofKey - Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
    this.voteFirstValid = ensureBigInt(voteFirstValid);
    this.voteKeyDilution = ensureBigInt(voteKeyDilution);
    this.voteLastValid = ensureBigInt(voteLastValid);
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountParticipation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["selection-participation-key", this.selectionParticipationKey],
      ["vote-first-valid", this.voteFirstValid],
      ["vote-key-dilution", this.voteKeyDilution],
      ["vote-last-valid", this.voteLastValid],
      ["vote-participation-key", this.voteParticipationKey],
      ["state-proof-key", this.stateProofKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountParticipation: ${data}`);
    }
    return new _AccountParticipation({
      selectionParticipationKey: data.get("selection-participation-key"),
      voteFirstValid: data.get("vote-first-valid"),
      voteKeyDilution: data.get("vote-key-dilution"),
      voteLastValid: data.get("vote-last-valid"),
      voteParticipationKey: data.get("vote-participation-key"),
      stateProofKey: data.get("state-proof-key")
    });
  }
};
var AccountResponse = class _AccountResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "account",
        valueSchema: Account2.encodingSchema,
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountResponse` object.
   * @param account - Account information at a given round.
   * Definition:
   * data/basics/userBalance.go : AccountData
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ account, currentRound }) {
    this.account = account;
    this.currentRound = ensureBigInt(currentRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["account", this.account.toEncodingData()],
      ["current-round", this.currentRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountResponse: ${data}`);
    }
    return new _AccountResponse({
      account: Account2.fromEncodingData(data.get("account") ?? /* @__PURE__ */ new Map()),
      currentRound: data.get("current-round")
    });
  }
};
var AccountStateDelta2 = class _AccountStateDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "delta",
        valueSchema: new ArraySchema(EvalDeltaKeyValue2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    this.address = address;
    this.delta = delta;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["delta", this.delta.map((v) => v.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountStateDelta: ${data}`);
    }
    return new _AccountStateDelta({
      address: data.get("address"),
      delta: (data.get("delta") ?? []).map((v) => EvalDeltaKeyValue2.fromEncodingData(v))
    });
  }
};
var AccountsResponse = class _AccountsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "accounts",
        valueSchema: new ArraySchema(Account2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountsResponse` object.
   * @param accounts -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ accounts, currentRound, nextToken }) {
    this.accounts = accounts;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["accounts", this.accounts.map((v) => v.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountsResponse: ${data}`);
    }
    return new _AccountsResponse({
      accounts: (data.get("accounts") ?? []).map((v) => Account2.fromEncodingData(v)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var Application2 = class _Application {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: ApplicationParams2.encodingSchema,
        omitEmpty: true
      }, {
        key: "created-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "deleted-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Application` object.
   * @param id - application index.
   * @param params - application parameters.
   * @param createdAtRound - Round when this application was created.
   * @param deleted - Whether or not this application is currently deleted.
   * @param deletedAtRound - Round when this application was deleted.
   */
  constructor({ id, params, createdAtRound, deleted, deletedAtRound }) {
    this.id = ensureBigInt(id);
    this.params = params;
    this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
    this.deleted = deleted;
    this.deletedAtRound = typeof deletedAtRound === "undefined" ? void 0 : ensureBigInt(deletedAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Application.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["params", this.params.toEncodingData()],
      ["created-at-round", this.createdAtRound],
      ["deleted", this.deleted],
      ["deleted-at-round", this.deletedAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Application: ${data}`);
    }
    return new _Application({
      id: data.get("id"),
      params: ApplicationParams2.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map()),
      createdAtRound: data.get("created-at-round"),
      deleted: data.get("deleted"),
      deletedAtRound: data.get("deleted-at-round")
    });
  }
};
var ApplicationLocalState2 = class _ApplicationLocalState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "schema",
        valueSchema: ApplicationStateSchema2.encodingSchema,
        omitEmpty: true
      }, {
        key: "closed-out-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "key-value",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "opted-in-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - schema.
   * @param closedOutAtRound - Round when account closed out of the application.
   * @param deleted - Whether or not the application local state is currently deleted from its
   * account.
   * @param keyValue - storage.
   * @param optedInAtRound - Round when the account opted into the application.
   */
  constructor({ id, schema, closedOutAtRound, deleted, keyValue, optedInAtRound }) {
    this.id = ensureBigInt(id);
    this.schema = schema;
    this.closedOutAtRound = typeof closedOutAtRound === "undefined" ? void 0 : ensureBigInt(closedOutAtRound);
    this.deleted = deleted;
    this.keyValue = keyValue;
    this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["schema", this.schema.toEncodingData()],
      ["closed-out-at-round", this.closedOutAtRound],
      ["deleted", this.deleted],
      [
        "key-value",
        typeof this.keyValue !== "undefined" ? this.keyValue.map((v) => v.toEncodingData()) : void 0
      ],
      ["opted-in-at-round", this.optedInAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalState: ${data}`);
    }
    return new _ApplicationLocalState({
      id: data.get("id"),
      schema: ApplicationStateSchema2.fromEncodingData(data.get("schema") ?? /* @__PURE__ */ new Map()),
      closedOutAtRound: data.get("closed-out-at-round"),
      deleted: data.get("deleted"),
      keyValue: typeof data.get("key-value") !== "undefined" ? data.get("key-value").map((v) => TealKeyValue2.fromEncodingData(v)) : void 0,
      optedInAtRound: data.get("opted-in-at-round")
    });
  }
};
var ApplicationLocalStatesResponse = class _ApplicationLocalStatesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "apps-local-states",
        valueSchema: new ArraySchema(ApplicationLocalState2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalStatesResponse` object.
   * @param appsLocalStates -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ appsLocalStates, currentRound, nextToken }) {
    this.appsLocalStates = appsLocalStates;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalStatesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "apps-local-states",
        this.appsLocalStates.map((v) => v.toEncodingData())
      ],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalStatesResponse: ${data}`);
    }
    return new _ApplicationLocalStatesResponse({
      appsLocalStates: (data.get("apps-local-states") ?? []).map((v) => ApplicationLocalState2.fromEncodingData(v)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var ApplicationLogData = class _ApplicationLogData {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "logs",
        valueSchema: new ArraySchema(new ByteArraySchema()),
        omitEmpty: true
      }, { key: "txid", valueSchema: new StringSchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLogData` object.
   * @param logs - Logs for the application being executed by the transaction.
   * @param txid - Transaction ID
   */
  constructor({ logs, txid }) {
    this.logs = logs;
    this.txid = txid;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLogData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["logs", this.logs],
      ["txid", this.txid]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLogData: ${data}`);
    }
    return new _ApplicationLogData({
      logs: data.get("logs"),
      txid: data.get("txid")
    });
  }
};
var ApplicationLogsResponse = class _ApplicationLogsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-id",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "log-data",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLogData.encodingSchema)),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLogsResponse` object.
   * @param applicationId - (appidx) application index.
   * @param currentRound - Round at which the results were computed.
   * @param logData -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, currentRound, logData, nextToken }) {
    this.applicationId = ensureBigInt(applicationId);
    this.currentRound = ensureBigInt(currentRound);
    this.logData = logData;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLogsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-id", this.applicationId],
      ["current-round", this.currentRound],
      [
        "log-data",
        typeof this.logData !== "undefined" ? this.logData.map((v) => v.toEncodingData()) : void 0
      ],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLogsResponse: ${data}`);
    }
    return new _ApplicationLogsResponse({
      applicationId: data.get("application-id"),
      currentRound: data.get("current-round"),
      logData: typeof data.get("log-data") !== "undefined" ? data.get("log-data").map((v) => ApplicationLogData.fromEncodingData(v)) : void 0,
      nextToken: data.get("next-token")
    });
  }
};
var ApplicationParams2 = class _ApplicationParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "approval-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "clear-state-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "creator",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "extra-program-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-state",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "global-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "local-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - approval program.
   * @param clearStateProgram - clear state program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - the number of extra program pages available to this app.
   * @param globalState - global state
   * @param globalStateSchema - global schema
   * @param localStateSchema - local schema
   * @param version - the number of updates to the application programs
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema, version }) {
    this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
    this.creator = typeof creator === "string" ? Address.fromString(creator) : creator;
    this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.version = typeof version === "undefined" ? void 0 : ensureSafeInteger(version);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approval-program", this.approvalProgram],
      ["clear-state-program", this.clearStateProgram],
      [
        "creator",
        typeof this.creator !== "undefined" ? this.creator.toString() : void 0
      ],
      ["extra-program-pages", this.extraProgramPages],
      [
        "global-state",
        typeof this.globalState !== "undefined" ? this.globalState.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "global-state-schema",
        typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
      ],
      [
        "local-state-schema",
        typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
      ],
      ["version", this.version]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationParams: ${data}`);
    }
    return new _ApplicationParams({
      approvalProgram: data.get("approval-program"),
      clearStateProgram: data.get("clear-state-program"),
      creator: data.get("creator"),
      extraProgramPages: data.get("extra-program-pages"),
      globalState: typeof data.get("global-state") !== "undefined" ? data.get("global-state").map((v) => TealKeyValue2.fromEncodingData(v)) : void 0,
      globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("global-state-schema")) : void 0,
      localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("local-state-schema")) : void 0,
      version: data.get("version")
    });
  }
};
var ApplicationResponse = class _ApplicationResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "application",
        valueSchema: new OptionalSchema(Application2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param application - Application index and its parameters
   */
  constructor({ currentRound, application }) {
    this.currentRound = ensureBigInt(currentRound);
    this.application = application;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-round", this.currentRound],
      [
        "application",
        typeof this.application !== "undefined" ? this.application.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationResponse: ${data}`);
    }
    return new _ApplicationResponse({
      currentRound: data.get("current-round"),
      application: typeof data.get("application") !== "undefined" ? Application2.fromEncodingData(data.get("application")) : void 0
    });
  }
};
var ApplicationStateSchema2 = class _ApplicationStateSchema {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "num-byte-slice",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numByteSlice - number of byte slices.
   * @param numUint - number of uints.
   */
  constructor({ numByteSlice, numUint }) {
    this.numByteSlice = ensureSafeInteger(numByteSlice);
    this.numUint = ensureSafeInteger(numUint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationStateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["num-byte-slice", this.numByteSlice],
      ["num-uint", this.numUint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationStateSchema: ${data}`);
    }
    return new _ApplicationStateSchema({
      numByteSlice: data.get("num-byte-slice"),
      numUint: data.get("num-uint")
    });
  }
};
var ApplicationsResponse = class _ApplicationsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "applications",
        valueSchema: new ArraySchema(Application2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationsResponse` object.
   * @param applications -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applications, currentRound, nextToken }) {
    this.applications = applications;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["applications", this.applications.map((v) => v.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationsResponse: ${data}`);
    }
    return new _ApplicationsResponse({
      applications: (data.get("applications") ?? []).map((v) => Application2.fromEncodingData(v)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var Asset2 = class _Asset {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: AssetParams3.encodingSchema,
        omitEmpty: true
      }, {
        key: "created-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "destroyed-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   * @param createdAtRound - Round during which this asset was created.
   * @param deleted - Whether or not this asset is currently deleted.
   * @param destroyedAtRound - Round during which this asset was destroyed.
   */
  constructor({ index, params, createdAtRound, deleted, destroyedAtRound }) {
    this.index = ensureBigInt(index);
    this.params = params;
    this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
    this.deleted = deleted;
    this.destroyedAtRound = typeof destroyedAtRound === "undefined" ? void 0 : ensureBigInt(destroyedAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Asset.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["index", this.index],
      ["params", this.params.toEncodingData()],
      ["created-at-round", this.createdAtRound],
      ["deleted", this.deleted],
      ["destroyed-at-round", this.destroyedAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Asset: ${data}`);
    }
    return new _Asset({
      index: data.get("index"),
      params: AssetParams3.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map()),
      createdAtRound: data.get("created-at-round"),
      deleted: data.get("deleted"),
      destroyedAtRound: data.get("destroyed-at-round")
    });
  }
};
var AssetBalancesResponse = class _AssetBalancesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "balances",
        valueSchema: new ArraySchema(MiniAssetHolding.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetBalancesResponse` object.
   * @param balances -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ balances, currentRound, nextToken }) {
    this.balances = balances;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetBalancesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["balances", this.balances.map((v) => v.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetBalancesResponse: ${data}`);
    }
    return new _AssetBalancesResponse({
      balances: (data.get("balances") ?? []).map((v) => MiniAssetHolding.fromEncodingData(v)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var AssetHolding3 = class _AssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "opted-in-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "opted-out-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - whether or not the holding is frozen.
   * @param deleted - Whether or not the asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into this asset holding.
   * @param optedOutAtRound - Round during which the account opted out of this asset holding.
   */
  constructor({ amount, assetId, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    this.amount = ensureBigInt(amount);
    this.assetId = ensureBigInt(assetId);
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
    this.optedOutAtRound = typeof optedOutAtRound === "undefined" ? void 0 : ensureBigInt(optedOutAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["asset-id", this.assetId],
      ["is-frozen", this.isFrozen],
      ["deleted", this.deleted],
      ["opted-in-at-round", this.optedInAtRound],
      ["opted-out-at-round", this.optedOutAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHolding: ${data}`);
    }
    return new _AssetHolding({
      amount: data.get("amount"),
      assetId: data.get("asset-id"),
      isFrozen: data.get("is-frozen"),
      deleted: data.get("deleted"),
      optedInAtRound: data.get("opted-in-at-round"),
      optedOutAtRound: data.get("opted-out-at-round")
    });
  }
};
var AssetHoldingsResponse = class _AssetHoldingsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "assets",
        valueSchema: new ArraySchema(AssetHolding3.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHoldingsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    this.assets = assets;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHoldingsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["assets", this.assets.map((v) => v.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHoldingsResponse: ${data}`);
    }
    return new _AssetHoldingsResponse({
      assets: (data.get("assets") ?? []).map((v) => AssetHolding3.fromEncodingData(v)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var AssetParams3 = class _AssetParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, { key: "decimals", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "total", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "clawback",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "default-frozen",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "freeze",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "manager",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "metadata-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "reserve",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "url",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "url-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - The number of digits to use after the decimal point when displaying this asset.
   * If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths.
   * If 2, the base unit of the asset is in hundredths, and so on. This value must be
   * between 0 and 19 (inclusive).
   * @param total - The total number of units of this asset.
   * @param clawback - Address of account used to clawback holdings of this asset. If empty, clawback
   * is not permitted.
   * @param defaultFrozen - Whether holdings of this asset are frozen by default.
   * @param freeze - Address of account used to freeze holdings of this asset. If empty, freezing is
   * not permitted.
   * @param manager - Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - A commitment to some unspecified asset metadata. The format of this metadata is
   * up to the application.
   * @param name - Name of this asset, as supplied by the creator. Included only when the asset
   * name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - Name of a unit of this asset, as supplied by the creator. Included only when the
   * name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - URL where more information about the asset can be retrieved. Included only when
   * the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    this.creator = creator;
    this.decimals = ensureSafeInteger(decimals);
    this.total = ensureBigInt(total);
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? base64ToBytes(metadataHash) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? base64ToBytes(nameB64) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? base64ToBytes(unitNameB64) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? base64ToBytes(urlB64) : urlB64;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["creator", this.creator],
      ["decimals", this.decimals],
      ["total", this.total],
      ["clawback", this.clawback],
      ["default-frozen", this.defaultFrozen],
      ["freeze", this.freeze],
      ["manager", this.manager],
      ["metadata-hash", this.metadataHash],
      ["name", this.name],
      ["name-b64", this.nameB64],
      ["reserve", this.reserve],
      ["unit-name", this.unitName],
      ["unit-name-b64", this.unitNameB64],
      ["url", this.url],
      ["url-b64", this.urlB64]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParams: ${data}`);
    }
    return new _AssetParams({
      creator: data.get("creator"),
      decimals: data.get("decimals"),
      total: data.get("total"),
      clawback: data.get("clawback"),
      defaultFrozen: data.get("default-frozen"),
      freeze: data.get("freeze"),
      manager: data.get("manager"),
      metadataHash: data.get("metadata-hash"),
      name: data.get("name"),
      nameB64: data.get("name-b64"),
      reserve: data.get("reserve"),
      unitName: data.get("unit-name"),
      unitNameB64: data.get("unit-name-b64"),
      url: data.get("url"),
      urlB64: data.get("url-b64")
    });
  }
};
var AssetResponse = class _AssetResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "asset", valueSchema: Asset2.encodingSchema, omitEmpty: true }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetResponse` object.
   * @param asset - Specifies both the unique identifier and the parameters for an asset
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ asset, currentRound }) {
    this.asset = asset;
    this.currentRound = ensureBigInt(currentRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["asset", this.asset.toEncodingData()],
      ["current-round", this.currentRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetResponse: ${data}`);
    }
    return new _AssetResponse({
      asset: Asset2.fromEncodingData(data.get("asset") ?? /* @__PURE__ */ new Map()),
      currentRound: data.get("current-round")
    });
  }
};
var AssetsResponse = class _AssetsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "assets",
        valueSchema: new ArraySchema(Asset2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    this.assets = assets;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["assets", this.assets.map((v) => v.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetsResponse: ${data}`);
    }
    return new _AssetsResponse({
      assets: (data.get("assets") ?? []).map((v) => Asset2.fromEncodingData(v)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var Block3 = class _Block {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "genesis-hash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "genesis-id", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "previous-block-hash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "seed", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "timestamp", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "transactions-root",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "transactions-root-sha256",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "bonus",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "fees-collected",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "participation-updates",
        valueSchema: new OptionalSchema(ParticipationUpdates2.encodingSchema),
        omitEmpty: true
      }, {
        key: "previous-block-hash-512",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "proposer",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "proposer-payout",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "rewards",
        valueSchema: new OptionalSchema(BlockRewards.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof-tracking",
        valueSchema: new OptionalSchema(new ArraySchema(StateProofTracking.encodingSchema)),
        omitEmpty: true
      }, {
        key: "transactions",
        valueSchema: new OptionalSchema(new ArraySchema(Transaction2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "transactions-root-sha512",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "txn-counter",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-state",
        valueSchema: new OptionalSchema(BlockUpgradeState.encodingSchema),
        omitEmpty: true
      }, {
        key: "upgrade-vote",
        valueSchema: new OptionalSchema(BlockUpgradeVote.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Block` object.
   * @param genesisHash - (gh) hash to which this block belongs.
   * @param genesisId - (gen) ID to which this block belongs.
   * @param previousBlockHash - (prev) Previous block hash.
   * @param round - (rnd) Current round on which this block was appended to the chain.
   * @param seed - (seed) Sortition seed.
   * @param timestamp - (ts) Block creation timestamp in seconds since eposh
   * @param transactionsRoot - (txn) TransactionsRoot authenticates the set of transactions appearing in the
   * block. More specifically, it's the root of a merkle tree whose leaves are the
   * block's Txids, in lexicographic order. For the empty block, it's 0. Note that
   * the TxnRoot does not authenticate the signatures on the transactions, only the
   * transactions themselves. Two blocks with the same transactions but in a
   * different order and with different signatures will have the same TxnRoot.
   * @param transactionsRootSha256 - (txn256) TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a
   * vector commitment instead of a merkle tree, and SHA256 hash function instead of
   * the default SHA512_256. This commitment can be used on environments where only
   * the SHA256 function exists.
   * @param bonus - the potential bonus payout for this block.
   * @param feesCollected - the sum of all fees paid by transactions in this block.
   * @param participationUpdates - Participation account data that needs to be checked/acted on by the network.
   * @param previousBlockHash512 - (prev512) Previous block hash, using SHA-512.
   * @param proposer - the proposer of this block.
   * @param proposerPayout - the actual amount transferred to the proposer from the fee sink.
   * @param rewards - Fields relating to rewards,
   * @param stateProofTracking - Tracks the status of state proofs.
   * @param transactions - (txns) list of transactions corresponding to a given round.
   * @param transactionsRootSha512 - (txn512) TransactionsRootSHA512 is an auxiliary TransactionRoot, built using a
   * vector commitment instead of a merkle tree, and SHA512 hash function instead of
   * the default SHA512_256.
   * @param txnCounter - (tc) TxnCounter counts the number of transactions committed in the ledger, from
   * the time at which support for this feature was introduced.
   * Specifically, TxnCounter is the number of the next transaction that will be
   * committed after this block. It is 0 when no transactions have ever been
   * committed (since TxnCounter started being supported).
   * @param upgradeState - Fields relating to a protocol upgrade.
   * @param upgradeVote - Fields relating to voting for a protocol upgrade.
   */
  constructor({ genesisHash, genesisId, previousBlockHash, round, seed, timestamp, transactionsRoot, transactionsRootSha256, bonus, feesCollected, participationUpdates, previousBlockHash512, proposer, proposerPayout, rewards, stateProofTracking, transactions, transactionsRootSha512, txnCounter, upgradeState, upgradeVote }) {
    this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
    this.genesisId = genesisId;
    this.previousBlockHash = typeof previousBlockHash === "string" ? base64ToBytes(previousBlockHash) : previousBlockHash;
    this.round = ensureBigInt(round);
    this.seed = typeof seed === "string" ? base64ToBytes(seed) : seed;
    this.timestamp = ensureSafeInteger(timestamp);
    this.transactionsRoot = typeof transactionsRoot === "string" ? base64ToBytes(transactionsRoot) : transactionsRoot;
    this.transactionsRootSha256 = typeof transactionsRootSha256 === "string" ? base64ToBytes(transactionsRootSha256) : transactionsRootSha256;
    this.bonus = typeof bonus === "undefined" ? void 0 : ensureSafeInteger(bonus);
    this.feesCollected = typeof feesCollected === "undefined" ? void 0 : ensureSafeInteger(feesCollected);
    this.participationUpdates = participationUpdates;
    this.previousBlockHash512 = typeof previousBlockHash512 === "string" ? base64ToBytes(previousBlockHash512) : previousBlockHash512;
    this.proposer = typeof proposer === "string" ? Address.fromString(proposer) : proposer;
    this.proposerPayout = typeof proposerPayout === "undefined" ? void 0 : ensureSafeInteger(proposerPayout);
    this.rewards = rewards;
    this.stateProofTracking = stateProofTracking;
    this.transactions = transactions;
    this.transactionsRootSha512 = typeof transactionsRootSha512 === "string" ? base64ToBytes(transactionsRootSha512) : transactionsRootSha512;
    this.txnCounter = typeof txnCounter === "undefined" ? void 0 : ensureSafeInteger(txnCounter);
    this.upgradeState = upgradeState;
    this.upgradeVote = upgradeVote;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Block.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["genesis-hash", this.genesisHash],
      ["genesis-id", this.genesisId],
      ["previous-block-hash", this.previousBlockHash],
      ["round", this.round],
      ["seed", this.seed],
      ["timestamp", this.timestamp],
      ["transactions-root", this.transactionsRoot],
      ["transactions-root-sha256", this.transactionsRootSha256],
      ["bonus", this.bonus],
      ["fees-collected", this.feesCollected],
      [
        "participation-updates",
        typeof this.participationUpdates !== "undefined" ? this.participationUpdates.toEncodingData() : void 0
      ],
      ["previous-block-hash-512", this.previousBlockHash512],
      [
        "proposer",
        typeof this.proposer !== "undefined" ? this.proposer.toString() : void 0
      ],
      ["proposer-payout", this.proposerPayout],
      [
        "rewards",
        typeof this.rewards !== "undefined" ? this.rewards.toEncodingData() : void 0
      ],
      [
        "state-proof-tracking",
        typeof this.stateProofTracking !== "undefined" ? this.stateProofTracking.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "transactions",
        typeof this.transactions !== "undefined" ? this.transactions.map((v) => v.toEncodingData()) : void 0
      ],
      ["transactions-root-sha512", this.transactionsRootSha512],
      ["txn-counter", this.txnCounter],
      [
        "upgrade-state",
        typeof this.upgradeState !== "undefined" ? this.upgradeState.toEncodingData() : void 0
      ],
      [
        "upgrade-vote",
        typeof this.upgradeVote !== "undefined" ? this.upgradeVote.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Block: ${data}`);
    }
    return new _Block({
      genesisHash: data.get("genesis-hash"),
      genesisId: data.get("genesis-id"),
      previousBlockHash: data.get("previous-block-hash"),
      round: data.get("round"),
      seed: data.get("seed"),
      timestamp: data.get("timestamp"),
      transactionsRoot: data.get("transactions-root"),
      transactionsRootSha256: data.get("transactions-root-sha256"),
      bonus: data.get("bonus"),
      feesCollected: data.get("fees-collected"),
      participationUpdates: typeof data.get("participation-updates") !== "undefined" ? ParticipationUpdates2.fromEncodingData(data.get("participation-updates")) : void 0,
      previousBlockHash512: data.get("previous-block-hash-512"),
      proposer: data.get("proposer"),
      proposerPayout: data.get("proposer-payout"),
      rewards: typeof data.get("rewards") !== "undefined" ? BlockRewards.fromEncodingData(data.get("rewards")) : void 0,
      stateProofTracking: typeof data.get("state-proof-tracking") !== "undefined" ? data.get("state-proof-tracking").map((v) => StateProofTracking.fromEncodingData(v)) : void 0,
      transactions: typeof data.get("transactions") !== "undefined" ? data.get("transactions").map((v) => Transaction2.fromEncodingData(v)) : void 0,
      transactionsRootSha512: data.get("transactions-root-sha512"),
      txnCounter: data.get("txn-counter"),
      upgradeState: typeof data.get("upgrade-state") !== "undefined" ? BlockUpgradeState.fromEncodingData(data.get("upgrade-state")) : void 0,
      upgradeVote: typeof data.get("upgrade-vote") !== "undefined" ? BlockUpgradeVote.fromEncodingData(data.get("upgrade-vote")) : void 0
    });
  }
};
var BlockHeadersResponse = class _BlockHeadersResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "blocks",
        valueSchema: new ArraySchema(Block3.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockHeadersResponse` object.
   * @param blocks -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ blocks, currentRound, nextToken }) {
    this.blocks = blocks;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockHeadersResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["blocks", this.blocks.map((v) => v.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHeadersResponse: ${data}`);
    }
    return new _BlockHeadersResponse({
      blocks: (data.get("blocks") ?? []).map((v) => Block3.fromEncodingData(v)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var BlockRewards = class _BlockRewards {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "fee-sink", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "rewards-calculation-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "rewards-level",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "rewards-pool",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "rewards-rate",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "rewards-residue",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockRewards` object.
   * @param feeSink - (fees) accepts transaction fees, it can only spend to the incentive pool.
   * @param rewardsCalculationRound - (rwcalr) number of leftover MicroAlgos after the distribution of rewards-rate
   * MicroAlgos for every reward unit in the next round.
   * @param rewardsLevel - (earn) How many rewards, in MicroAlgos, have been distributed to each RewardUnit
   * of MicroAlgos since genesis.
   * @param rewardsPool - (rwd) accepts periodic injections from the fee-sink and continually
   * redistributes them as rewards.
   * @param rewardsRate - (rate) Number of new MicroAlgos added to the participation stake from rewards at
   * the next round.
   * @param rewardsResidue - (frac) Number of leftover MicroAlgos after the distribution of
   * RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
   */
  constructor({ feeSink, rewardsCalculationRound, rewardsLevel, rewardsPool, rewardsRate, rewardsResidue }) {
    this.feeSink = feeSink;
    this.rewardsCalculationRound = ensureBigInt(rewardsCalculationRound);
    this.rewardsLevel = ensureBigInt(rewardsLevel);
    this.rewardsPool = rewardsPool;
    this.rewardsRate = ensureBigInt(rewardsRate);
    this.rewardsResidue = ensureBigInt(rewardsResidue);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockRewards.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["fee-sink", this.feeSink],
      ["rewards-calculation-round", this.rewardsCalculationRound],
      ["rewards-level", this.rewardsLevel],
      ["rewards-pool", this.rewardsPool],
      ["rewards-rate", this.rewardsRate],
      ["rewards-residue", this.rewardsResidue]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockRewards: ${data}`);
    }
    return new _BlockRewards({
      feeSink: data.get("fee-sink"),
      rewardsCalculationRound: data.get("rewards-calculation-round"),
      rewardsLevel: data.get("rewards-level"),
      rewardsPool: data.get("rewards-pool"),
      rewardsRate: data.get("rewards-rate"),
      rewardsResidue: data.get("rewards-residue")
    });
  }
};
var BlockUpgradeState = class _BlockUpgradeState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-protocol",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "next-protocol",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "next-protocol-approvals",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "next-protocol-switch-on",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "next-protocol-vote-before",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockUpgradeState` object.
   * @param currentProtocol - (proto) The current protocol version.
   * @param nextProtocol - (nextproto) The next proposed protocol version.
   * @param nextProtocolApprovals - (nextyes) Number of blocks which approved the protocol upgrade.
   * @param nextProtocolSwitchOn - (nextswitch) Round on which the protocol upgrade will take effect.
   * @param nextProtocolVoteBefore - (nextbefore) Deadline round for this protocol upgrade (No votes will be consider
   * after this round).
   */
  constructor({ currentProtocol, nextProtocol, nextProtocolApprovals, nextProtocolSwitchOn, nextProtocolVoteBefore }) {
    this.currentProtocol = currentProtocol;
    this.nextProtocol = nextProtocol;
    this.nextProtocolApprovals = typeof nextProtocolApprovals === "undefined" ? void 0 : ensureSafeInteger(nextProtocolApprovals);
    this.nextProtocolSwitchOn = typeof nextProtocolSwitchOn === "undefined" ? void 0 : ensureBigInt(nextProtocolSwitchOn);
    this.nextProtocolVoteBefore = typeof nextProtocolVoteBefore === "undefined" ? void 0 : ensureBigInt(nextProtocolVoteBefore);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockUpgradeState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-protocol", this.currentProtocol],
      ["next-protocol", this.nextProtocol],
      ["next-protocol-approvals", this.nextProtocolApprovals],
      ["next-protocol-switch-on", this.nextProtocolSwitchOn],
      ["next-protocol-vote-before", this.nextProtocolVoteBefore]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockUpgradeState: ${data}`);
    }
    return new _BlockUpgradeState({
      currentProtocol: data.get("current-protocol"),
      nextProtocol: data.get("next-protocol"),
      nextProtocolApprovals: data.get("next-protocol-approvals"),
      nextProtocolSwitchOn: data.get("next-protocol-switch-on"),
      nextProtocolVoteBefore: data.get("next-protocol-vote-before")
    });
  }
};
var BlockUpgradeVote = class _BlockUpgradeVote {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "upgrade-approve",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "upgrade-delay",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-propose",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockUpgradeVote` object.
   * @param upgradeApprove - (upgradeyes) Indicates a yes vote for the current proposal.
   * @param upgradeDelay - (upgradedelay) Indicates the time between acceptance and execution.
   * @param upgradePropose - (upgradeprop) Indicates a proposed upgrade.
   */
  constructor({ upgradeApprove, upgradeDelay, upgradePropose }) {
    this.upgradeApprove = upgradeApprove;
    this.upgradeDelay = typeof upgradeDelay === "undefined" ? void 0 : ensureBigInt(upgradeDelay);
    this.upgradePropose = upgradePropose;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockUpgradeVote.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["upgrade-approve", this.upgradeApprove],
      ["upgrade-delay", this.upgradeDelay],
      ["upgrade-propose", this.upgradePropose]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockUpgradeVote: ${data}`);
    }
    return new _BlockUpgradeVote({
      upgradeApprove: data.get("upgrade-approve"),
      upgradeDelay: data.get("upgrade-delay"),
      upgradePropose: data.get("upgrade-propose")
    });
  }
};
var Box2 = class _Box {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "value", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param round - The round for which this information is relevant
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name, round, value }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
    this.round = ensureBigInt(round);
    this.value = typeof value === "string" ? base64ToBytes(value) : value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Box.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["name", this.name],
      ["round", this.round],
      ["value", this.value]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Box: ${data}`);
    }
    return new _Box({
      name: data.get("name"),
      round: data.get("round"),
      value: data.get("value")
    });
  }
};
var BoxDescriptor2 = class _BoxDescriptor {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "name",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxDescriptor.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["name", this.name]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxDescriptor: ${data}`);
    }
    return new _BoxDescriptor({
      name: data.get("name")
    });
  }
};
var BoxReference2 = class _BoxReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "app", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxReference` object.
   * @param app - Application ID to which the box belongs, or zero if referring to the called
   * application.
   * @param name - Base64 encoded box name
   */
  constructor({ app, name }) {
    this.app = ensureSafeInteger(app);
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app", this.app],
      ["name", this.name]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxReference: ${data}`);
    }
    return new _BoxReference({
      app: data.get("app"),
      name: data.get("name")
    });
  }
};
var BoxesResponse2 = class _BoxesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-id",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "boxes",
        valueSchema: new ArraySchema(BoxDescriptor2.encodingSchema),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxesResponse` object.
   * @param applicationId - (appidx) application index.
   * @param boxes -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, boxes, nextToken }) {
    this.applicationId = ensureBigInt(applicationId);
    this.boxes = boxes;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-id", this.applicationId],
      ["boxes", this.boxes.map((v) => v.toEncodingData())],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxesResponse: ${data}`);
    }
    return new _BoxesResponse({
      applicationId: data.get("application-id"),
      boxes: (data.get("boxes") ?? []).map((v) => BoxDescriptor2.fromEncodingData(v)),
      nextToken: data.get("next-token")
    });
  }
};
var ErrorResponse2 = class _ErrorResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "message", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "data",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    this.message = message;
    this.data = data;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ErrorResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["message", this.message],
      [
        "data",
        typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ErrorResponse: ${data}`);
    }
    return new _ErrorResponse({
      message: data.get("message"),
      data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0
    });
  }
};
var EvalDelta3 = class _EvalDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "action", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "bytes",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "uint",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    this.action = ensureSafeInteger(action);
    this.bytes = bytes;
    this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["action", this.action],
      ["bytes", this.bytes],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDelta: ${data}`);
    }
    return new _EvalDelta({
      action: data.get("action"),
      bytes: data.get("bytes"),
      uint: data.get("uint")
    });
  }
};
var EvalDeltaKeyValue2 = class _EvalDeltaKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new StringSchema(), omitEmpty: true }, { key: "value", valueSchema: EvalDelta3.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    this.key = key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDeltaKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDeltaKeyValue: ${data}`);
    }
    return new _EvalDeltaKeyValue({
      key: data.get("key"),
      value: EvalDelta3.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var HashFactory2 = class _HashFactory {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "hash-type",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HashFactory` object.
   * @param hashType - (t)
   */
  constructor({ hashType }) {
    this.hashType = typeof hashType === "undefined" ? void 0 : ensureSafeInteger(hashType);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HashFactory.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["hash-type", this.hashType]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HashFactory: ${data}`);
    }
    return new _HashFactory({
      hashType: data.get("hash-type")
    });
  }
};
var HbProofFields = class _HbProofFields {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "hb-pk",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-pk1sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-pk2",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-pk2sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HbProofFields` object.
   * @param hbPk - (p) Public key of the heartbeat message.
   * @param hbPk1sig - (p1s) Signature of OneTimeSignatureSubkeyOffsetID(PK, Batch, Offset) under the
   * key PK2.
   * @param hbPk2 - (p2) Key for new-style two-level ephemeral signature.
   * @param hbPk2sig - (p2s) Signature of OneTimeSignatureSubkeyBatchID(PK2, Batch) under the master
   * key (OneTimeSignatureVerifier).
   * @param hbSig - (s) Signature of the heartbeat message.
   */
  constructor({ hbPk, hbPk1sig, hbPk2, hbPk2sig, hbSig }) {
    this.hbPk = typeof hbPk === "string" ? base64ToBytes(hbPk) : hbPk;
    this.hbPk1sig = typeof hbPk1sig === "string" ? base64ToBytes(hbPk1sig) : hbPk1sig;
    this.hbPk2 = typeof hbPk2 === "string" ? base64ToBytes(hbPk2) : hbPk2;
    this.hbPk2sig = typeof hbPk2sig === "string" ? base64ToBytes(hbPk2sig) : hbPk2sig;
    this.hbSig = typeof hbSig === "string" ? base64ToBytes(hbSig) : hbSig;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HbProofFields.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hb-pk", this.hbPk],
      ["hb-pk1sig", this.hbPk1sig],
      ["hb-pk2", this.hbPk2],
      ["hb-pk2sig", this.hbPk2sig],
      ["hb-sig", this.hbSig]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HbProofFields: ${data}`);
    }
    return new _HbProofFields({
      hbPk: data.get("hb-pk"),
      hbPk1sig: data.get("hb-pk1sig"),
      hbPk2: data.get("hb-pk2"),
      hbPk2sig: data.get("hb-pk2sig"),
      hbSig: data.get("hb-sig")
    });
  }
};
var HealthCheck2 = class _HealthCheck {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "db-available",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, {
        key: "is-migrating",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, { key: "message", valueSchema: new StringSchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "version", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "data",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      }, {
        key: "errors",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HealthCheck` object.
   * @param dbAvailable -
   * @param isMigrating -
   * @param message -
   * @param round -
   * @param version - Current version.
   * @param data -
   * @param errors -
   */
  constructor({ dbAvailable, isMigrating, message, round, version, data, errors }) {
    this.dbAvailable = dbAvailable;
    this.isMigrating = isMigrating;
    this.message = message;
    this.round = ensureBigInt(round);
    this.version = version;
    this.data = data;
    this.errors = errors;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HealthCheck.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["db-available", this.dbAvailable],
      ["is-migrating", this.isMigrating],
      ["message", this.message],
      ["round", this.round],
      ["version", this.version],
      [
        "data",
        typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
      ],
      ["errors", this.errors]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HealthCheck: ${data}`);
    }
    return new _HealthCheck({
      dbAvailable: data.get("db-available"),
      isMigrating: data.get("is-migrating"),
      message: data.get("message"),
      round: data.get("round"),
      version: data.get("version"),
      data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0,
      errors: data.get("errors")
    });
  }
};
var HoldingRef = class _HoldingRef {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HoldingRef` object.
   * @param address - (d) Address in access list, or the sender of the transaction.
   * @param asset - (s) Asset ID for asset in access list.
   */
  constructor({ address, asset }) {
    this.address = typeof address === "string" ? Address.fromString(address) : address;
    this.asset = ensureSafeInteger(asset);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HoldingRef.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address.toString()],
      ["asset", this.asset]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HoldingRef: ${data}`);
    }
    return new _HoldingRef({
      address: data.get("address"),
      asset: data.get("asset")
    });
  }
};
var IndexerStateProofMessage = class _IndexerStateProofMessage {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "block-headers-commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "first-attested-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "latest-attested-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "ln-proven-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "voters-commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `IndexerStateProofMessage` object.
   * @param blockHeadersCommitment - (b)
   * @param firstAttestedRound - (f)
   * @param latestAttestedRound - (l)
   * @param lnProvenWeight - (P)
   * @param votersCommitment - (v)
   */
  constructor({ blockHeadersCommitment, firstAttestedRound, latestAttestedRound, lnProvenWeight, votersCommitment }) {
    this.blockHeadersCommitment = typeof blockHeadersCommitment === "string" ? base64ToBytes(blockHeadersCommitment) : blockHeadersCommitment;
    this.firstAttestedRound = typeof firstAttestedRound === "undefined" ? void 0 : ensureBigInt(firstAttestedRound);
    this.latestAttestedRound = typeof latestAttestedRound === "undefined" ? void 0 : ensureBigInt(latestAttestedRound);
    this.lnProvenWeight = typeof lnProvenWeight === "undefined" ? void 0 : ensureBigInt(lnProvenWeight);
    this.votersCommitment = typeof votersCommitment === "string" ? base64ToBytes(votersCommitment) : votersCommitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _IndexerStateProofMessage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["block-headers-commitment", this.blockHeadersCommitment],
      ["first-attested-round", this.firstAttestedRound],
      ["latest-attested-round", this.latestAttestedRound],
      ["ln-proven-weight", this.lnProvenWeight],
      ["voters-commitment", this.votersCommitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded IndexerStateProofMessage: ${data}`);
    }
    return new _IndexerStateProofMessage({
      blockHeadersCommitment: data.get("block-headers-commitment"),
      firstAttestedRound: data.get("first-attested-round"),
      latestAttestedRound: data.get("latest-attested-round"),
      lnProvenWeight: data.get("ln-proven-weight"),
      votersCommitment: data.get("voters-commitment")
    });
  }
};
var LocalsRef = class _LocalsRef {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "app", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `LocalsRef` object.
   * @param address - (d) Address in access list, or the sender of the transaction.
   * @param app - (p) Application ID for app in access list, or zero if referring to the called
   * application.
   */
  constructor({ address, app }) {
    this.address = typeof address === "string" ? Address.fromString(address) : address;
    this.app = ensureSafeInteger(app);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LocalsRef.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address.toString()],
      ["app", this.app]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LocalsRef: ${data}`);
    }
    return new _LocalsRef({
      address: data.get("address"),
      app: data.get("app")
    });
  }
};
var MerkleArrayProof2 = class _MerkleArrayProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "hash-factory",
        valueSchema: new OptionalSchema(HashFactory2.encodingSchema),
        omitEmpty: true
      }, {
        key: "path",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "tree-depth",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `MerkleArrayProof` object.
   * @param hashFactory -
   * @param path - (pth)
   * @param treeDepth - (td)
   */
  constructor({ hashFactory, path, treeDepth }) {
    this.hashFactory = hashFactory;
    this.path = path;
    this.treeDepth = typeof treeDepth === "undefined" ? void 0 : ensureSafeInteger(treeDepth);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MerkleArrayProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "hash-factory",
        typeof this.hashFactory !== "undefined" ? this.hashFactory.toEncodingData() : void 0
      ],
      ["path", this.path],
      ["tree-depth", this.treeDepth]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
    }
    return new _MerkleArrayProof({
      hashFactory: typeof data.get("hash-factory") !== "undefined" ? HashFactory2.fromEncodingData(data.get("hash-factory")) : void 0,
      path: data.get("path"),
      treeDepth: data.get("tree-depth")
    });
  }
};
var MiniAssetHolding = class _MiniAssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "opted-in-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "opted-out-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `MiniAssetHolding` object.
   * @param address -
   * @param amount -
   * @param isFrozen -
   * @param deleted - Whether or not this asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into the asset.
   * @param optedOutAtRound - Round during which the account opted out of the asset.
   */
  constructor({ address, amount, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    this.address = address;
    this.amount = ensureBigInt(amount);
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
    this.optedOutAtRound = typeof optedOutAtRound === "undefined" ? void 0 : ensureBigInt(optedOutAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MiniAssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["amount", this.amount],
      ["is-frozen", this.isFrozen],
      ["deleted", this.deleted],
      ["opted-in-at-round", this.optedInAtRound],
      ["opted-out-at-round", this.optedOutAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MiniAssetHolding: ${data}`);
    }
    return new _MiniAssetHolding({
      address: data.get("address"),
      amount: data.get("amount"),
      isFrozen: data.get("is-frozen"),
      deleted: data.get("deleted"),
      optedInAtRound: data.get("opted-in-at-round"),
      optedOutAtRound: data.get("opted-out-at-round")
    });
  }
};
var ParticipationUpdates2 = class _ParticipationUpdates {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "absent-participation-accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "expired-participation-accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ParticipationUpdates` object.
   * @param absentParticipationAccounts - (partupabs) a list of online accounts that need to be suspended.
   * @param expiredParticipationAccounts - (partupdrmv) a list of online accounts that needs to be converted to offline
   * since their participation key expired.
   */
  constructor({ absentParticipationAccounts, expiredParticipationAccounts }) {
    this.absentParticipationAccounts = absentParticipationAccounts;
    this.expiredParticipationAccounts = expiredParticipationAccounts;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ParticipationUpdates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["absent-participation-accounts", this.absentParticipationAccounts],
      ["expired-participation-accounts", this.expiredParticipationAccounts]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
    }
    return new _ParticipationUpdates({
      absentParticipationAccounts: data.get("absent-participation-accounts"),
      expiredParticipationAccounts: data.get("expired-participation-accounts")
    });
  }
};
var ResourceRef = class _ResourceRef {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "address",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "application-id",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "asset-id",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "box",
        valueSchema: new OptionalSchema(BoxReference2.encodingSchema),
        omitEmpty: true
      }, {
        key: "holding",
        valueSchema: new OptionalSchema(HoldingRef.encodingSchema),
        omitEmpty: true
      }, {
        key: "local",
        valueSchema: new OptionalSchema(LocalsRef.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ResourceRef` object.
   * @param address - (d) Account whose balance record is accessible by the executing ApprovalProgram
   * or ClearStateProgram.
   * @param applicationId - (p) Application id whose GlobalState may be read by the executing
   * ApprovalProgram or ClearStateProgram.
   * @param assetId - (s) Asset whose AssetParams may be read by the executing
   * ApprovalProgram or ClearStateProgram.
   * @param box - BoxReference names a box by its name and the application ID it belongs to.
   * @param holding - HoldingRef names a holding by referring to an Address and Asset it belongs to.
   * @param local - LocalsRef names a local state by referring to an Address and App it belongs to.
   */
  constructor({ address, applicationId, assetId, box, holding, local }) {
    this.address = typeof address === "string" ? Address.fromString(address) : address;
    this.applicationId = typeof applicationId === "undefined" ? void 0 : ensureSafeInteger(applicationId);
    this.assetId = typeof assetId === "undefined" ? void 0 : ensureSafeInteger(assetId);
    this.box = box;
    this.holding = holding;
    this.local = local;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ResourceRef.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "address",
        typeof this.address !== "undefined" ? this.address.toString() : void 0
      ],
      ["application-id", this.applicationId],
      ["asset-id", this.assetId],
      [
        "box",
        typeof this.box !== "undefined" ? this.box.toEncodingData() : void 0
      ],
      [
        "holding",
        typeof this.holding !== "undefined" ? this.holding.toEncodingData() : void 0
      ],
      [
        "local",
        typeof this.local !== "undefined" ? this.local.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ResourceRef: ${data}`);
    }
    return new _ResourceRef({
      address: data.get("address"),
      applicationId: data.get("application-id"),
      assetId: data.get("asset-id"),
      box: typeof data.get("box") !== "undefined" ? BoxReference2.fromEncodingData(data.get("box")) : void 0,
      holding: typeof data.get("holding") !== "undefined" ? HoldingRef.fromEncodingData(data.get("holding")) : void 0,
      local: typeof data.get("local") !== "undefined" ? LocalsRef.fromEncodingData(data.get("local")) : void 0
    });
  }
};
var StateProofFields = class _StateProofFields {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "part-proofs",
        valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
        omitEmpty: true
      }, {
        key: "positions-to-reveal",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "reveals",
        valueSchema: new OptionalSchema(new ArraySchema(StateProofReveal.encodingSchema)),
        omitEmpty: true
      }, {
        key: "salt-version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-commit",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "sig-proofs",
        valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
        omitEmpty: true
      }, {
        key: "signed-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofFields` object.
   * @param partProofs - (P)
   * @param positionsToReveal - (pr) Sequence of reveal positions.
   * @param reveals - (r) Note that this is actually stored as a map[uint64] - Reveal in the actual
   * msgp
   * @param saltVersion - (v) Salt version of the merkle signature.
   * @param sigCommit - (c)
   * @param sigProofs - (S)
   * @param signedWeight - (w)
   */
  constructor({ partProofs, positionsToReveal, reveals, saltVersion, sigCommit, sigProofs, signedWeight }) {
    this.partProofs = partProofs;
    this.positionsToReveal = typeof positionsToReveal === "undefined" ? void 0 : positionsToReveal.map(ensureBigInt);
    this.reveals = reveals;
    this.saltVersion = typeof saltVersion === "undefined" ? void 0 : ensureSafeInteger(saltVersion);
    this.sigCommit = typeof sigCommit === "string" ? base64ToBytes(sigCommit) : sigCommit;
    this.sigProofs = sigProofs;
    this.signedWeight = typeof signedWeight === "undefined" ? void 0 : ensureBigInt(signedWeight);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofFields.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "part-proofs",
        typeof this.partProofs !== "undefined" ? this.partProofs.toEncodingData() : void 0
      ],
      ["positions-to-reveal", this.positionsToReveal],
      [
        "reveals",
        typeof this.reveals !== "undefined" ? this.reveals.map((v) => v.toEncodingData()) : void 0
      ],
      ["salt-version", this.saltVersion],
      ["sig-commit", this.sigCommit],
      [
        "sig-proofs",
        typeof this.sigProofs !== "undefined" ? this.sigProofs.toEncodingData() : void 0
      ],
      ["signed-weight", this.signedWeight]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofFields: ${data}`);
    }
    return new _StateProofFields({
      partProofs: typeof data.get("part-proofs") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("part-proofs")) : void 0,
      positionsToReveal: data.get("positions-to-reveal"),
      reveals: typeof data.get("reveals") !== "undefined" ? data.get("reveals").map((v) => StateProofReveal.fromEncodingData(v)) : void 0,
      saltVersion: data.get("salt-version"),
      sigCommit: data.get("sig-commit"),
      sigProofs: typeof data.get("sig-proofs") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("sig-proofs")) : void 0,
      signedWeight: data.get("signed-weight")
    });
  }
};
var StateProofParticipant = class _StateProofParticipant {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "verifier",
        valueSchema: new OptionalSchema(StateProofVerifier.encodingSchema),
        omitEmpty: true
      }, {
        key: "weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofParticipant` object.
   * @param verifier - (p)
   * @param weight - (w)
   */
  constructor({ verifier, weight }) {
    this.verifier = verifier;
    this.weight = typeof weight === "undefined" ? void 0 : ensureBigInt(weight);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofParticipant.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "verifier",
        typeof this.verifier !== "undefined" ? this.verifier.toEncodingData() : void 0
      ],
      ["weight", this.weight]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofParticipant: ${data}`);
    }
    return new _StateProofParticipant({
      verifier: typeof data.get("verifier") !== "undefined" ? StateProofVerifier.fromEncodingData(data.get("verifier")) : void 0,
      weight: data.get("weight")
    });
  }
};
var StateProofReveal = class _StateProofReveal {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "participant",
        valueSchema: new OptionalSchema(StateProofParticipant.encodingSchema),
        omitEmpty: true
      }, {
        key: "position",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-slot",
        valueSchema: new OptionalSchema(StateProofSigSlot.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofReveal` object.
   * @param participant - (p)
   * @param position - The position in the signature and participants arrays corresponding to this
   * entry.
   * @param sigSlot - (s)
   */
  constructor({ participant, position, sigSlot }) {
    this.participant = participant;
    this.position = typeof position === "undefined" ? void 0 : ensureBigInt(position);
    this.sigSlot = sigSlot;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofReveal.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "participant",
        typeof this.participant !== "undefined" ? this.participant.toEncodingData() : void 0
      ],
      ["position", this.position],
      [
        "sig-slot",
        typeof this.sigSlot !== "undefined" ? this.sigSlot.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofReveal: ${data}`);
    }
    return new _StateProofReveal({
      participant: typeof data.get("participant") !== "undefined" ? StateProofParticipant.fromEncodingData(data.get("participant")) : void 0,
      position: data.get("position"),
      sigSlot: typeof data.get("sig-slot") !== "undefined" ? StateProofSigSlot.fromEncodingData(data.get("sig-slot")) : void 0
    });
  }
};
var StateProofSigSlot = class _StateProofSigSlot {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "lower-sig-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(StateProofSignature.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofSigSlot` object.
   * @param lowerSigWeight - (l) The total weight of signatures in the lower-numbered slots.
   * @param signature -
   */
  constructor({ lowerSigWeight, signature }) {
    this.lowerSigWeight = typeof lowerSigWeight === "undefined" ? void 0 : ensureBigInt(lowerSigWeight);
    this.signature = signature;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofSigSlot.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["lower-sig-weight", this.lowerSigWeight],
      [
        "signature",
        typeof this.signature !== "undefined" ? this.signature.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofSigSlot: ${data}`);
    }
    return new _StateProofSigSlot({
      lowerSigWeight: data.get("lower-sig-weight"),
      signature: typeof data.get("signature") !== "undefined" ? StateProofSignature.fromEncodingData(data.get("signature")) : void 0
    });
  }
};
var StateProofSignature = class _StateProofSignature {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "falcon-signature",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "merkle-array-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "proof",
        valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
        omitEmpty: true
      }, {
        key: "verifying-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofSignature` object.
   * @param falconSignature -
   * @param merkleArrayIndex -
   * @param proof -
   * @param verifyingKey - (vkey)
   */
  constructor({ falconSignature, merkleArrayIndex, proof, verifyingKey }) {
    this.falconSignature = typeof falconSignature === "string" ? base64ToBytes(falconSignature) : falconSignature;
    this.merkleArrayIndex = typeof merkleArrayIndex === "undefined" ? void 0 : ensureSafeInteger(merkleArrayIndex);
    this.proof = proof;
    this.verifyingKey = typeof verifyingKey === "string" ? base64ToBytes(verifyingKey) : verifyingKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofSignature.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["falcon-signature", this.falconSignature],
      ["merkle-array-index", this.merkleArrayIndex],
      [
        "proof",
        typeof this.proof !== "undefined" ? this.proof.toEncodingData() : void 0
      ],
      ["verifying-key", this.verifyingKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofSignature: ${data}`);
    }
    return new _StateProofSignature({
      falconSignature: data.get("falcon-signature"),
      merkleArrayIndex: data.get("merkle-array-index"),
      proof: typeof data.get("proof") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("proof")) : void 0,
      verifyingKey: data.get("verifying-key")
    });
  }
};
var StateProofTracking = class _StateProofTracking {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "next-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "online-total-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "type",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "voters-commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofTracking` object.
   * @param nextRound - (n) Next round for which we will accept a state proof transaction.
   * @param onlineTotalWeight - (t) The total number of microalgos held by the online accounts during the
   * StateProof round.
   * @param type - State Proof Type. Note the raw object uses map with this as key.
   * @param votersCommitment - (v) Root of a vector commitment containing online accounts that will help sign
   * the proof.
   */
  constructor({ nextRound, onlineTotalWeight, type, votersCommitment }) {
    this.nextRound = typeof nextRound === "undefined" ? void 0 : ensureBigInt(nextRound);
    this.onlineTotalWeight = typeof onlineTotalWeight === "undefined" ? void 0 : ensureBigInt(onlineTotalWeight);
    this.type = typeof type === "undefined" ? void 0 : ensureSafeInteger(type);
    this.votersCommitment = typeof votersCommitment === "string" ? base64ToBytes(votersCommitment) : votersCommitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofTracking.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["next-round", this.nextRound],
      ["online-total-weight", this.onlineTotalWeight],
      ["type", this.type],
      ["voters-commitment", this.votersCommitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofTracking: ${data}`);
    }
    return new _StateProofTracking({
      nextRound: data.get("next-round"),
      onlineTotalWeight: data.get("online-total-weight"),
      type: data.get("type"),
      votersCommitment: data.get("voters-commitment")
    });
  }
};
var StateProofVerifier = class _StateProofVerifier {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "key-lifetime",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofVerifier` object.
   * @param commitment - (cmt) Represents the root of the vector commitment tree.
   * @param keyLifetime - (lf) Key lifetime.
   */
  constructor({ commitment, keyLifetime }) {
    this.commitment = typeof commitment === "string" ? base64ToBytes(commitment) : commitment;
    this.keyLifetime = typeof keyLifetime === "undefined" ? void 0 : ensureBigInt(keyLifetime);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["commitment", this.commitment],
      ["key-lifetime", this.keyLifetime]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofVerifier: ${data}`);
    }
    return new _StateProofVerifier({
      commitment: data.get("commitment"),
      keyLifetime: data.get("key-lifetime")
    });
  }
};
var StateSchema2 = class _StateSchema {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "num-byte-slice",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateSchema` object.
   * @param numByteSlice - Maximum number of TEAL byte slices that may be stored in the key/value store.
   * @param numUint - Maximum number of TEAL uints that may be stored in the key/value store.
   */
  constructor({ numByteSlice, numUint }) {
    this.numByteSlice = ensureSafeInteger(numByteSlice);
    this.numUint = ensureSafeInteger(numUint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["num-byte-slice", this.numByteSlice],
      ["num-uint", this.numUint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateSchema: ${data}`);
    }
    return new _StateSchema({
      numByteSlice: data.get("num-byte-slice"),
      numUint: data.get("num-uint")
    });
  }
};
var TealKeyValue2 = class _TealKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: TealValue3.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealKeyValue: ${data}`);
    }
    return new _TealKeyValue({
      key: data.get("key"),
      value: TealValue3.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var TealValue3 = class _TealValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "bytes", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealValue` object.
   * @param bytes - bytes value.
   * @param type - type of the value. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param uint - uint value.
   */
  constructor({ bytes, type, uint }) {
    this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
    this.type = ensureSafeInteger(type);
    this.uint = ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["bytes", this.bytes],
      ["type", this.type],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealValue: ${data}`);
    }
    return new _TealValue({
      bytes: data.get("bytes"),
      type: data.get("type"),
      uint: data.get("uint")
    });
  }
};
var Transaction2 = class _Transaction {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "fee", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "first-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "last-valid", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "sender", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "application-transaction",
        valueSchema: new OptionalSchema(TransactionApplication.encodingSchema),
        omitEmpty: true
      }, {
        key: "asset-config-transaction",
        valueSchema: new OptionalSchema(TransactionAssetConfig.encodingSchema),
        omitEmpty: true
      }, {
        key: "asset-freeze-transaction",
        valueSchema: new OptionalSchema(TransactionAssetFreeze.encodingSchema),
        omitEmpty: true
      }, {
        key: "asset-transfer-transaction",
        valueSchema: new OptionalSchema(TransactionAssetTransfer.encodingSchema),
        omitEmpty: true
      }, {
        key: "auth-addr",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "close-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "closing-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "confirmed-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "created-application-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "created-asset-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "genesis-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "genesis-id",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "global-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "group",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "heartbeat-transaction",
        valueSchema: new OptionalSchema(TransactionHeartbeat.encodingSchema),
        omitEmpty: true
      }, {
        key: "id",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "inner-txns",
        valueSchema: new OptionalSchema(new ArraySchema(_Transaction.encodingSchema)),
        omitEmpty: true
      }, {
        key: "intra-round-offset",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "keyreg-transaction",
        valueSchema: new OptionalSchema(TransactionKeyreg.encodingSchema),
        omitEmpty: true
      }, {
        key: "lease",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "local-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "note",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "payment-transaction",
        valueSchema: new OptionalSchema(TransactionPayment.encodingSchema),
        omitEmpty: true
      }, {
        key: "receiver-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "rekey-to",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "round-time",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sender-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(TransactionSignature.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof-transaction",
        valueSchema: new OptionalSchema(TransactionStateProof.encodingSchema),
        omitEmpty: true
      }, {
        key: "tx-type",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Transaction` object.
   * @param fee - (fee) Transaction fee.
   * @param firstValid - (fv) First valid round for this transaction.
   * @param lastValid - (lv) Last valid round for this transaction.
   * @param sender - (snd) Sender's address.
   * @param applicationTransaction - Fields for application transactions.
   * Definition:
   * data/transactions/application.go : ApplicationCallTxnFields
   * @param assetConfigTransaction - Fields for asset allocation, re-configuration, and destruction.
   * A zero value for asset-id indicates asset creation.
   * A zero value for the params indicates asset destruction.
   * Definition:
   * data/transactions/asset.go : AssetConfigTxnFields
   * @param assetFreezeTransaction - Fields for an asset freeze transaction.
   * Definition:
   * data/transactions/asset.go : AssetFreezeTxnFields
   * @param assetTransferTransaction - Fields for an asset transfer transaction.
   * Definition:
   * data/transactions/asset.go : AssetTransferTxnFields
   * @param authAddr - (sgnr) this is included with signed transactions when the signing address does
   * not equal the sender. The backend can use this to ensure that auth addr is equal
   * to the accounts auth addr.
   * @param closeRewards - (rc) rewards applied to close-remainder-to account.
   * @param closingAmount - (ca) closing amount for transaction.
   * @param confirmedRound - Round when the transaction was confirmed.
   * @param createdApplicationIndex - Specifies an application index (ID) if an application was created with this
   * transaction.
   * @param createdAssetIndex - Specifies an asset index (ID) if an asset was created with this transaction.
   * @param genesisHash - (gh) Hash of genesis block.
   * @param genesisId - (gen) genesis block ID.
   * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
   * transaction.
   * @param group - (grp) Base64 encoded byte array of a sha512/256 digest. When present indicates
   * that this transaction is part of a transaction group and the value is the
   * sha512/256 hash of the transactions in that group.
   * @param heartbeatTransaction - Fields for a heartbeat transaction.
   * Definition:
   * data/transactions/heartbeat.go : HeartbeatTxnFields
   * @param id - Transaction ID
   * @param innerTxns - Inner transactions produced by application execution.
   * @param intraRoundOffset - Offset into the round where this transaction was confirmed.
   * @param keyregTransaction - Fields for a keyreg transaction.
   * Definition:
   * data/transactions/keyreg.go : KeyregTxnFields
   * @param lease - (lx) Base64 encoded 32-byte array. Lease enforces mutual exclusion of
   * transactions. If this field is nonzero, then once the transaction is confirmed,
   * it acquires the lease identified by the (Sender, Lease) pair of the transaction
   * until the LastValid round passes. While this transaction possesses the lease, no
   * other transaction specifying this lease can be confirmed.
   * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - (lg) Logs for the application being executed by this transaction.
   * @param note - (note) Free form data.
   * @param paymentTransaction - Fields for a payment transaction.
   * Definition:
   * data/transactions/payment.go : PaymentTxnFields
   * @param receiverRewards - (rr) rewards applied to receiver account.
   * @param rekeyTo - (rekey) when included in a valid transaction, the accounts auth addr will be
   * updated with this value and future signatures must be signed with the key
   * represented by this address.
   * @param roundTime - Time when the block this transaction is in was confirmed.
   * @param senderRewards - (rs) rewards applied to sender account.
   * @param signature - Validation signature associated with some data. Only one of the signatures
   * should be provided.
   * @param stateProofTransaction - Fields for a state proof transaction.
   * Definition:
   * data/transactions/stateproof.go : StateProofTxnFields
   * @param txType - (type) Indicates what type of transaction this is. Different types have
   * different fields.
   * Valid types, and where their fields are stored:
   * * (pay) payment-transaction
   * * (keyreg) keyreg-transaction
   * * (acfg) asset-config-transaction
   * * (axfer) asset-transfer-transaction
   * * (afrz) asset-freeze-transaction
   * * (appl) application-transaction
   * * (stpf) state-proof-transaction
   * * (hb) heartbeat-transaction
   */
  constructor({ fee, firstValid, lastValid, sender, applicationTransaction, assetConfigTransaction, assetFreezeTransaction, assetTransferTransaction, authAddr, closeRewards, closingAmount, confirmedRound, createdApplicationIndex, createdAssetIndex, genesisHash, genesisId, globalStateDelta, group, heartbeatTransaction, id, innerTxns, intraRoundOffset, keyregTransaction, lease, localStateDelta, logs, note, paymentTransaction, receiverRewards, rekeyTo, roundTime, senderRewards, signature, stateProofTransaction, txType }) {
    this.fee = ensureBigInt(fee);
    this.firstValid = ensureBigInt(firstValid);
    this.lastValid = ensureBigInt(lastValid);
    this.sender = sender;
    this.applicationTransaction = applicationTransaction;
    this.assetConfigTransaction = assetConfigTransaction;
    this.assetFreezeTransaction = assetFreezeTransaction;
    this.assetTransferTransaction = assetTransferTransaction;
    this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
    this.closeRewards = typeof closeRewards === "undefined" ? void 0 : ensureBigInt(closeRewards);
    this.closingAmount = typeof closingAmount === "undefined" ? void 0 : ensureBigInt(closingAmount);
    this.confirmedRound = typeof confirmedRound === "undefined" ? void 0 : ensureBigInt(confirmedRound);
    this.createdApplicationIndex = typeof createdApplicationIndex === "undefined" ? void 0 : ensureBigInt(createdApplicationIndex);
    this.createdAssetIndex = typeof createdAssetIndex === "undefined" ? void 0 : ensureBigInt(createdAssetIndex);
    this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
    this.genesisId = genesisId;
    this.globalStateDelta = globalStateDelta;
    this.group = typeof group === "string" ? base64ToBytes(group) : group;
    this.heartbeatTransaction = heartbeatTransaction;
    this.id = id;
    this.innerTxns = innerTxns;
    this.intraRoundOffset = typeof intraRoundOffset === "undefined" ? void 0 : ensureSafeInteger(intraRoundOffset);
    this.keyregTransaction = keyregTransaction;
    this.lease = typeof lease === "string" ? base64ToBytes(lease) : lease;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.note = typeof note === "string" ? base64ToBytes(note) : note;
    this.paymentTransaction = paymentTransaction;
    this.receiverRewards = typeof receiverRewards === "undefined" ? void 0 : ensureBigInt(receiverRewards);
    this.rekeyTo = typeof rekeyTo === "string" ? Address.fromString(rekeyTo) : rekeyTo;
    this.roundTime = typeof roundTime === "undefined" ? void 0 : ensureSafeInteger(roundTime);
    this.senderRewards = typeof senderRewards === "undefined" ? void 0 : ensureBigInt(senderRewards);
    this.signature = signature;
    this.stateProofTransaction = stateProofTransaction;
    this.txType = txType;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Transaction.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["fee", this.fee],
      ["first-valid", this.firstValid],
      ["last-valid", this.lastValid],
      ["sender", this.sender],
      [
        "application-transaction",
        typeof this.applicationTransaction !== "undefined" ? this.applicationTransaction.toEncodingData() : void 0
      ],
      [
        "asset-config-transaction",
        typeof this.assetConfigTransaction !== "undefined" ? this.assetConfigTransaction.toEncodingData() : void 0
      ],
      [
        "asset-freeze-transaction",
        typeof this.assetFreezeTransaction !== "undefined" ? this.assetFreezeTransaction.toEncodingData() : void 0
      ],
      [
        "asset-transfer-transaction",
        typeof this.assetTransferTransaction !== "undefined" ? this.assetTransferTransaction.toEncodingData() : void 0
      ],
      [
        "auth-addr",
        typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
      ],
      ["close-rewards", this.closeRewards],
      ["closing-amount", this.closingAmount],
      ["confirmed-round", this.confirmedRound],
      ["created-application-index", this.createdApplicationIndex],
      ["created-asset-index", this.createdAssetIndex],
      ["genesis-hash", this.genesisHash],
      ["genesis-id", this.genesisId],
      [
        "global-state-delta",
        typeof this.globalStateDelta !== "undefined" ? this.globalStateDelta.map((v) => v.toEncodingData()) : void 0
      ],
      ["group", this.group],
      [
        "heartbeat-transaction",
        typeof this.heartbeatTransaction !== "undefined" ? this.heartbeatTransaction.toEncodingData() : void 0
      ],
      ["id", this.id],
      [
        "inner-txns",
        typeof this.innerTxns !== "undefined" ? this.innerTxns.map((v) => v.toEncodingData()) : void 0
      ],
      ["intra-round-offset", this.intraRoundOffset],
      [
        "keyreg-transaction",
        typeof this.keyregTransaction !== "undefined" ? this.keyregTransaction.toEncodingData() : void 0
      ],
      ["lease", this.lease],
      [
        "local-state-delta",
        typeof this.localStateDelta !== "undefined" ? this.localStateDelta.map((v) => v.toEncodingData()) : void 0
      ],
      ["logs", this.logs],
      ["note", this.note],
      [
        "payment-transaction",
        typeof this.paymentTransaction !== "undefined" ? this.paymentTransaction.toEncodingData() : void 0
      ],
      ["receiver-rewards", this.receiverRewards],
      [
        "rekey-to",
        typeof this.rekeyTo !== "undefined" ? this.rekeyTo.toString() : void 0
      ],
      ["round-time", this.roundTime],
      ["sender-rewards", this.senderRewards],
      [
        "signature",
        typeof this.signature !== "undefined" ? this.signature.toEncodingData() : void 0
      ],
      [
        "state-proof-transaction",
        typeof this.stateProofTransaction !== "undefined" ? this.stateProofTransaction.toEncodingData() : void 0
      ],
      ["tx-type", this.txType]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Transaction: ${data}`);
    }
    return new _Transaction({
      fee: data.get("fee"),
      firstValid: data.get("first-valid"),
      lastValid: data.get("last-valid"),
      sender: data.get("sender"),
      applicationTransaction: typeof data.get("application-transaction") !== "undefined" ? TransactionApplication.fromEncodingData(data.get("application-transaction")) : void 0,
      assetConfigTransaction: typeof data.get("asset-config-transaction") !== "undefined" ? TransactionAssetConfig.fromEncodingData(data.get("asset-config-transaction")) : void 0,
      assetFreezeTransaction: typeof data.get("asset-freeze-transaction") !== "undefined" ? TransactionAssetFreeze.fromEncodingData(data.get("asset-freeze-transaction")) : void 0,
      assetTransferTransaction: typeof data.get("asset-transfer-transaction") !== "undefined" ? TransactionAssetTransfer.fromEncodingData(data.get("asset-transfer-transaction")) : void 0,
      authAddr: data.get("auth-addr"),
      closeRewards: data.get("close-rewards"),
      closingAmount: data.get("closing-amount"),
      confirmedRound: data.get("confirmed-round"),
      createdApplicationIndex: data.get("created-application-index"),
      createdAssetIndex: data.get("created-asset-index"),
      genesisHash: data.get("genesis-hash"),
      genesisId: data.get("genesis-id"),
      globalStateDelta: typeof data.get("global-state-delta") !== "undefined" ? data.get("global-state-delta").map((v) => EvalDeltaKeyValue2.fromEncodingData(v)) : void 0,
      group: data.get("group"),
      heartbeatTransaction: typeof data.get("heartbeat-transaction") !== "undefined" ? TransactionHeartbeat.fromEncodingData(data.get("heartbeat-transaction")) : void 0,
      id: data.get("id"),
      innerTxns: typeof data.get("inner-txns") !== "undefined" ? data.get("inner-txns").map((v) => _Transaction.fromEncodingData(v)) : void 0,
      intraRoundOffset: data.get("intra-round-offset"),
      keyregTransaction: typeof data.get("keyreg-transaction") !== "undefined" ? TransactionKeyreg.fromEncodingData(data.get("keyreg-transaction")) : void 0,
      lease: data.get("lease"),
      localStateDelta: typeof data.get("local-state-delta") !== "undefined" ? data.get("local-state-delta").map((v) => AccountStateDelta2.fromEncodingData(v)) : void 0,
      logs: data.get("logs"),
      note: data.get("note"),
      paymentTransaction: typeof data.get("payment-transaction") !== "undefined" ? TransactionPayment.fromEncodingData(data.get("payment-transaction")) : void 0,
      receiverRewards: data.get("receiver-rewards"),
      rekeyTo: data.get("rekey-to"),
      roundTime: data.get("round-time"),
      senderRewards: data.get("sender-rewards"),
      signature: typeof data.get("signature") !== "undefined" ? TransactionSignature.fromEncodingData(data.get("signature")) : void 0,
      stateProofTransaction: typeof data.get("state-proof-transaction") !== "undefined" ? TransactionStateProof.fromEncodingData(data.get("state-proof-transaction")) : void 0,
      txType: data.get("tx-type")
    });
  }
};
var TransactionApplication = class _TransactionApplication {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-id",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "access",
        valueSchema: new OptionalSchema(new ArraySchema(ResourceRef.encodingSchema)),
        omitEmpty: true
      }, {
        key: "accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "application-args",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "approval-program",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "box-references",
        valueSchema: new OptionalSchema(new ArraySchema(BoxReference2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "clear-state-program",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "extra-program-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "foreign-apps",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "foreign-assets",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "global-state-schema",
        valueSchema: new OptionalSchema(StateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "local-state-schema",
        valueSchema: new OptionalSchema(StateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "on-completion",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "reject-version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionApplication` object.
   * @param applicationId - (apid) ID of the application being configured or empty if creating.
   * @param access - (al) Access unifies `accounts`, `foreign-apps`, `foreign-assets`, and
   * `box-references` under a single list. If access is non-empty, these lists must
   * be empty. If access is empty, those lists may be non-empty.
   * @param accounts - (apat) List of accounts in addition to the sender that may be accessed from the
   * application's approval-program and clear-state-program.
   * @param applicationArgs - (apaa) transaction specific arguments accessed from the application's
   * approval-program and clear-state-program.
   * @param approvalProgram - (apap) Logic executed for every application transaction, except when
   * on-completion is set to "clear". It can read and write global state for the
   * application, as well as account-specific local state. Approval programs may
   * reject the transaction.
   * @param boxReferences - (apbx) the boxes that can be accessed by this transaction (and others in the
   * same group).
   * @param clearStateProgram - (apsu) Logic executed for application transactions with on-completion set to
   * "clear". It can read and write global state for the application, as well as
   * account-specific local state. Clear state programs cannot reject the
   * transaction.
   * @param extraProgramPages - (epp) specifies the additional app program len requested in pages.
   * @param foreignApps - (apfa) Lists the applications in addition to the application-id whose global
   * states may be accessed by this application's approval-program and
   * clear-state-program. The access is read-only.
   * @param foreignAssets - (apas) lists the assets whose parameters may be accessed by this application's
   * ApprovalProgram and ClearStateProgram. The access is read-only.
   * @param globalStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param localStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param onCompletion - (apan) defines the what additional actions occur with the transaction.
   * Valid types:
   * * noop
   * * optin
   * * closeout
   * * clear
   * * update
   * * update
   * * delete
   * @param rejectVersion - (aprv) the lowest application version for which this transaction should
   * immediately fail. 0 indicates that no version check should be performed.
   */
  constructor({ applicationId, access, accounts, applicationArgs, approvalProgram, boxReferences, clearStateProgram, extraProgramPages, foreignApps, foreignAssets, globalStateSchema, localStateSchema, onCompletion, rejectVersion }) {
    this.applicationId = ensureBigInt(applicationId);
    this.access = access;
    this.accounts = typeof accounts !== "undefined" ? accounts.map((addr) => typeof addr === "string" ? Address.fromString(addr) : addr) : void 0;
    this.applicationArgs = applicationArgs;
    this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
    this.boxReferences = boxReferences;
    this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
    this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
    this.foreignApps = typeof foreignApps === "undefined" ? void 0 : foreignApps.map(ensureBigInt);
    this.foreignAssets = typeof foreignAssets === "undefined" ? void 0 : foreignAssets.map(ensureBigInt);
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.onCompletion = onCompletion;
    this.rejectVersion = typeof rejectVersion === "undefined" ? void 0 : ensureSafeInteger(rejectVersion);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionApplication.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-id", this.applicationId],
      [
        "access",
        typeof this.access !== "undefined" ? this.access.map((v) => v.toEncodingData()) : void 0
      ],
      [
        "accounts",
        typeof this.accounts !== "undefined" ? this.accounts.map((v) => v.toString()) : void 0
      ],
      ["application-args", this.applicationArgs],
      ["approval-program", this.approvalProgram],
      [
        "box-references",
        typeof this.boxReferences !== "undefined" ? this.boxReferences.map((v) => v.toEncodingData()) : void 0
      ],
      ["clear-state-program", this.clearStateProgram],
      ["extra-program-pages", this.extraProgramPages],
      ["foreign-apps", this.foreignApps],
      ["foreign-assets", this.foreignAssets],
      [
        "global-state-schema",
        typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
      ],
      [
        "local-state-schema",
        typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
      ],
      ["on-completion", this.onCompletion],
      ["reject-version", this.rejectVersion]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionApplication: ${data}`);
    }
    return new _TransactionApplication({
      applicationId: data.get("application-id"),
      access: typeof data.get("access") !== "undefined" ? data.get("access").map((v) => ResourceRef.fromEncodingData(v)) : void 0,
      accounts: data.get("accounts"),
      applicationArgs: data.get("application-args"),
      approvalProgram: data.get("approval-program"),
      boxReferences: typeof data.get("box-references") !== "undefined" ? data.get("box-references").map((v) => BoxReference2.fromEncodingData(v)) : void 0,
      clearStateProgram: data.get("clear-state-program"),
      extraProgramPages: data.get("extra-program-pages"),
      foreignApps: data.get("foreign-apps"),
      foreignAssets: data.get("foreign-assets"),
      globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? StateSchema2.fromEncodingData(data.get("global-state-schema")) : void 0,
      localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? StateSchema2.fromEncodingData(data.get("local-state-schema")) : void 0,
      onCompletion: data.get("on-completion"),
      rejectVersion: data.get("reject-version")
    });
  }
};
var TransactionAssetConfig = class _TransactionAssetConfig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "asset-id",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "params",
        valueSchema: new OptionalSchema(AssetParams3.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionAssetConfig` object.
   * @param assetId - (xaid) ID of the asset being configured or empty if creating.
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ assetId, params }) {
    this.assetId = typeof assetId === "undefined" ? void 0 : ensureBigInt(assetId);
    this.params = params;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionAssetConfig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["asset-id", this.assetId],
      [
        "params",
        typeof this.params !== "undefined" ? this.params.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionAssetConfig: ${data}`);
    }
    return new _TransactionAssetConfig({
      assetId: data.get("asset-id"),
      params: typeof data.get("params") !== "undefined" ? AssetParams3.fromEncodingData(data.get("params")) : void 0
    });
  }
};
var TransactionAssetFreeze = class _TransactionAssetFreeze {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "new-freeze-status",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionAssetFreeze` object.
   * @param address - (fadd) Address of the account whose asset is being frozen or thawed.
   * @param assetId - (faid) ID of the asset being frozen or thawed.
   * @param newFreezeStatus - (afrz) The new freeze status.
   */
  constructor({ address, assetId, newFreezeStatus }) {
    this.address = address;
    this.assetId = ensureBigInt(assetId);
    this.newFreezeStatus = newFreezeStatus;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionAssetFreeze.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["asset-id", this.assetId],
      ["new-freeze-status", this.newFreezeStatus]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionAssetFreeze: ${data}`);
    }
    return new _TransactionAssetFreeze({
      address: data.get("address"),
      assetId: data.get("asset-id"),
      newFreezeStatus: data.get("new-freeze-status")
    });
  }
};
var TransactionAssetTransfer = class _TransactionAssetTransfer {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "receiver", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "close-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "close-to",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "sender",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionAssetTransfer` object.
   * @param amount - (aamt) Amount of asset to transfer. A zero amount transferred to self allocates
   * that asset in the account's Assets map.
   * @param assetId - (xaid) ID of the asset being transferred.
   * @param receiver - (arcv) Recipient address of the transfer.
   * @param closeAmount - Number of assets transferred to the close-to account as part of the transaction.
   * @param closeTo - (aclose) Indicates that the asset should be removed from the account's Assets
   * map, and specifies where the remaining asset holdings should be transferred.
   * It's always valid to transfer remaining asset holdings to the creator account.
   * @param sender - (asnd) The effective sender during a clawback transactions. If this is not a
   * zero value, the real transaction sender must be the Clawback address from the
   * AssetParams.
   */
  constructor({ amount, assetId, receiver, closeAmount, closeTo, sender }) {
    this.amount = ensureBigInt(amount);
    this.assetId = ensureBigInt(assetId);
    this.receiver = receiver;
    this.closeAmount = typeof closeAmount === "undefined" ? void 0 : ensureBigInt(closeAmount);
    this.closeTo = closeTo;
    this.sender = sender;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionAssetTransfer.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["asset-id", this.assetId],
      ["receiver", this.receiver],
      ["close-amount", this.closeAmount],
      ["close-to", this.closeTo],
      ["sender", this.sender]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionAssetTransfer: ${data}`);
    }
    return new _TransactionAssetTransfer({
      amount: data.get("amount"),
      assetId: data.get("asset-id"),
      receiver: data.get("receiver"),
      closeAmount: data.get("close-amount"),
      closeTo: data.get("close-to"),
      sender: data.get("sender")
    });
  }
};
var TransactionHeartbeat = class _TransactionHeartbeat {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "hb-address", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "hb-key-dilution",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "hb-proof",
        valueSchema: HbProofFields.encodingSchema,
        omitEmpty: true
      }, { key: "hb-seed", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
        key: "hb-vote-id",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionHeartbeat` object.
   * @param hbAddress - (hbad) HbAddress is the account this txn is proving onlineness for.
   * @param hbKeyDilution - (hbkd) HbKeyDilution must match HbAddress account's current KeyDilution.
   * @param hbProof - (hbprf) HbProof is a signature using HeartbeatAddress's partkey, thereby showing
   * it is online.
   * @param hbSeed - (hbsd) HbSeed must be the block seed for the this transaction's firstValid
   * block.
   * @param hbVoteId - (hbvid) HbVoteID must match the HbAddress account's current VoteID.
   */
  constructor({ hbAddress, hbKeyDilution, hbProof, hbSeed, hbVoteId }) {
    this.hbAddress = hbAddress;
    this.hbKeyDilution = ensureBigInt(hbKeyDilution);
    this.hbProof = hbProof;
    this.hbSeed = typeof hbSeed === "string" ? base64ToBytes(hbSeed) : hbSeed;
    this.hbVoteId = typeof hbVoteId === "string" ? base64ToBytes(hbVoteId) : hbVoteId;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionHeartbeat.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hb-address", this.hbAddress],
      ["hb-key-dilution", this.hbKeyDilution],
      ["hb-proof", this.hbProof.toEncodingData()],
      ["hb-seed", this.hbSeed],
      ["hb-vote-id", this.hbVoteId]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionHeartbeat: ${data}`);
    }
    return new _TransactionHeartbeat({
      hbAddress: data.get("hb-address"),
      hbKeyDilution: data.get("hb-key-dilution"),
      hbProof: HbProofFields.fromEncodingData(data.get("hb-proof") ?? /* @__PURE__ */ new Map()),
      hbSeed: data.get("hb-seed"),
      hbVoteId: data.get("hb-vote-id")
    });
  }
};
var TransactionKeyreg = class _TransactionKeyreg {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "non-participation",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "selection-participation-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "state-proof-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "vote-first-valid",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "vote-key-dilution",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "vote-last-valid",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "vote-participation-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionKeyreg` object.
   * @param nonParticipation - (nonpart) Mark the account as participating or non-participating.
   * @param selectionParticipationKey - (selkey) Public key used with the Verified Random Function (VRF) result during
   * committee selection.
   * @param stateProofKey - (sprfkey) State proof key used in key registration transactions.
   * @param voteFirstValid - (votefst) First round this participation key is valid.
   * @param voteKeyDilution - (votekd) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (votelst) Last round this participation key is valid.
   * @param voteParticipationKey - (votekey) Participation public key used in key registration transactions.
   */
  constructor({ nonParticipation, selectionParticipationKey, stateProofKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey }) {
    this.nonParticipation = nonParticipation;
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
    this.voteFirstValid = typeof voteFirstValid === "undefined" ? void 0 : ensureBigInt(voteFirstValid);
    this.voteKeyDilution = typeof voteKeyDilution === "undefined" ? void 0 : ensureBigInt(voteKeyDilution);
    this.voteLastValid = typeof voteLastValid === "undefined" ? void 0 : ensureBigInt(voteLastValid);
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionKeyreg.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["non-participation", this.nonParticipation],
      ["selection-participation-key", this.selectionParticipationKey],
      ["state-proof-key", this.stateProofKey],
      ["vote-first-valid", this.voteFirstValid],
      ["vote-key-dilution", this.voteKeyDilution],
      ["vote-last-valid", this.voteLastValid],
      ["vote-participation-key", this.voteParticipationKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionKeyreg: ${data}`);
    }
    return new _TransactionKeyreg({
      nonParticipation: data.get("non-participation"),
      selectionParticipationKey: data.get("selection-participation-key"),
      stateProofKey: data.get("state-proof-key"),
      voteFirstValid: data.get("vote-first-valid"),
      voteKeyDilution: data.get("vote-key-dilution"),
      voteLastValid: data.get("vote-last-valid"),
      voteParticipationKey: data.get("vote-participation-key")
    });
  }
};
var TransactionPayment = class _TransactionPayment {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "receiver", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "close-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "close-remainder-to",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionPayment` object.
   * @param amount - (amt) number of MicroAlgos intended to be transferred.
   * @param receiver - (rcv) receiver's address.
   * @param closeAmount - Number of MicroAlgos that were sent to the close-remainder-to address when
   * closing the sender account.
   * @param closeRemainderTo - (close) when set, indicates that the sending account should be closed and all
   * remaining funds be transferred to this address.
   */
  constructor({ amount, receiver, closeAmount, closeRemainderTo }) {
    this.amount = ensureBigInt(amount);
    this.receiver = receiver;
    this.closeAmount = typeof closeAmount === "undefined" ? void 0 : ensureBigInt(closeAmount);
    this.closeRemainderTo = closeRemainderTo;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionPayment.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["receiver", this.receiver],
      ["close-amount", this.closeAmount],
      ["close-remainder-to", this.closeRemainderTo]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionPayment: ${data}`);
    }
    return new _TransactionPayment({
      amount: data.get("amount"),
      receiver: data.get("receiver"),
      closeAmount: data.get("close-amount"),
      closeRemainderTo: data.get("close-remainder-to")
    });
  }
};
var TransactionResponse = class _TransactionResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "transaction",
        valueSchema: Transaction2.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transaction - Contains all fields common to all transactions and serves as an envelope to all
   * transactions type. Represents both regular and inner transactions.
   * Definition:
   * data/transactions/signedtxn.go : SignedTxn
   * data/transactions/transaction.go : Transaction
   */
  constructor({ currentRound, transaction }) {
    this.currentRound = ensureBigInt(currentRound);
    this.transaction = transaction;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-round", this.currentRound],
      ["transaction", this.transaction.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionResponse: ${data}`);
    }
    return new _TransactionResponse({
      currentRound: data.get("current-round"),
      transaction: Transaction2.fromEncodingData(data.get("transaction") ?? /* @__PURE__ */ new Map())
    });
  }
};
var TransactionSignature = class _TransactionSignature {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "logicsig",
        valueSchema: new OptionalSchema(TransactionSignatureLogicsig.encodingSchema),
        omitEmpty: true
      }, {
        key: "multisig",
        valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
        omitEmpty: true
      }, {
        key: "sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignature` object.
   * @param logicsig - (lsig) Programatic transaction signature.
   * Definition:
   * data/transactions/logicsig.go
   * @param multisig - structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param sig - (sig) Standard ed25519 signature.
   */
  constructor({ logicsig, multisig, sig }) {
    this.logicsig = logicsig;
    this.multisig = multisig;
    this.sig = typeof sig === "string" ? base64ToBytes(sig) : sig;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignature.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "logicsig",
        typeof this.logicsig !== "undefined" ? this.logicsig.toEncodingData() : void 0
      ],
      [
        "multisig",
        typeof this.multisig !== "undefined" ? this.multisig.toEncodingData() : void 0
      ],
      ["sig", this.sig]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignature: ${data}`);
    }
    return new _TransactionSignature({
      logicsig: typeof data.get("logicsig") !== "undefined" ? TransactionSignatureLogicsig.fromEncodingData(data.get("logicsig")) : void 0,
      multisig: typeof data.get("multisig") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("multisig")) : void 0,
      sig: data.get("sig")
    });
  }
};
var TransactionSignatureLogicsig = class _TransactionSignatureLogicsig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "logic", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
        key: "args",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "logic-multisig-signature",
        valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
        omitEmpty: true
      }, {
        key: "multisig-signature",
        valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignatureLogicsig` object.
   * @param logic - (l) Program signed by a signature or multi signature, or hashed to be the
   * address of ana ccount. Base64 encoded TEAL program.
   * @param args - (arg) Logic arguments, base64 encoded.
   * @param logicMultisigSignature - structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param multisigSignature - structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param signature - (sig) ed25519 signature.
   */
  constructor({ logic, args, logicMultisigSignature, multisigSignature, signature }) {
    this.logic = typeof logic === "string" ? base64ToBytes(logic) : logic;
    this.args = args;
    this.logicMultisigSignature = logicMultisigSignature;
    this.multisigSignature = multisigSignature;
    this.signature = typeof signature === "string" ? base64ToBytes(signature) : signature;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignatureLogicsig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["logic", this.logic],
      ["args", this.args],
      [
        "logic-multisig-signature",
        typeof this.logicMultisigSignature !== "undefined" ? this.logicMultisigSignature.toEncodingData() : void 0
      ],
      [
        "multisig-signature",
        typeof this.multisigSignature !== "undefined" ? this.multisigSignature.toEncodingData() : void 0
      ],
      ["signature", this.signature]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignatureLogicsig: ${data}`);
    }
    return new _TransactionSignatureLogicsig({
      logic: data.get("logic"),
      args: data.get("args"),
      logicMultisigSignature: typeof data.get("logic-multisig-signature") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("logic-multisig-signature")) : void 0,
      multisigSignature: typeof data.get("multisig-signature") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("multisig-signature")) : void 0,
      signature: data.get("signature")
    });
  }
};
var TransactionSignatureMultisig = class _TransactionSignatureMultisig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "subsignature",
        valueSchema: new OptionalSchema(new ArraySchema(TransactionSignatureMultisigSubsignature.encodingSchema)),
        omitEmpty: true
      }, {
        key: "threshold",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignatureMultisig` object.
   * @param subsignature - (subsig) holds pairs of public key and signatures.
   * @param threshold - (thr)
   * @param version - (v)
   */
  constructor({ subsignature, threshold, version }) {
    this.subsignature = subsignature;
    this.threshold = typeof threshold === "undefined" ? void 0 : ensureSafeInteger(threshold);
    this.version = typeof version === "undefined" ? void 0 : ensureSafeInteger(version);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignatureMultisig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "subsignature",
        typeof this.subsignature !== "undefined" ? this.subsignature.map((v) => v.toEncodingData()) : void 0
      ],
      ["threshold", this.threshold],
      ["version", this.version]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignatureMultisig: ${data}`);
    }
    return new _TransactionSignatureMultisig({
      subsignature: typeof data.get("subsignature") !== "undefined" ? data.get("subsignature").map((v) => TransactionSignatureMultisigSubsignature.fromEncodingData(v)) : void 0,
      threshold: data.get("threshold"),
      version: data.get("version")
    });
  }
};
var TransactionSignatureMultisigSubsignature = class _TransactionSignatureMultisigSubsignature {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "public-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignatureMultisigSubsignature` object.
   * @param publicKey - (pk)
   * @param signature - (s)
   */
  constructor({ publicKey, signature }) {
    this.publicKey = typeof publicKey === "string" ? base64ToBytes(publicKey) : publicKey;
    this.signature = typeof signature === "string" ? base64ToBytes(signature) : signature;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignatureMultisigSubsignature.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["public-key", this.publicKey],
      ["signature", this.signature]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignatureMultisigSubsignature: ${data}`);
    }
    return new _TransactionSignatureMultisigSubsignature({
      publicKey: data.get("public-key"),
      signature: data.get("signature")
    });
  }
};
var TransactionStateProof = class _TransactionStateProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "message",
        valueSchema: new OptionalSchema(IndexerStateProofMessage.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof",
        valueSchema: new OptionalSchema(StateProofFields.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof-type",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionStateProof` object.
   * @param message - (spmsg)
   * @param stateProof - (sp) represents a state proof.
   * Definition:
   * crypto/stateproof/structs.go : StateProof
   * @param stateProofType - (sptype) Type of the state proof. Integer representing an entry defined in
   * protocol/stateproof.go
   */
  constructor({ message, stateProof, stateProofType }) {
    this.message = message;
    this.stateProof = stateProof;
    this.stateProofType = typeof stateProofType === "undefined" ? void 0 : ensureSafeInteger(stateProofType);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionStateProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "message",
        typeof this.message !== "undefined" ? this.message.toEncodingData() : void 0
      ],
      [
        "state-proof",
        typeof this.stateProof !== "undefined" ? this.stateProof.toEncodingData() : void 0
      ],
      ["state-proof-type", this.stateProofType]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionStateProof: ${data}`);
    }
    return new _TransactionStateProof({
      message: typeof data.get("message") !== "undefined" ? IndexerStateProofMessage.fromEncodingData(data.get("message")) : void 0,
      stateProof: typeof data.get("state-proof") !== "undefined" ? StateProofFields.fromEncodingData(data.get("state-proof")) : void 0,
      stateProofType: data.get("state-proof-type")
    });
  }
};
var TransactionsResponse = class _TransactionsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "transactions",
        valueSchema: new ArraySchema(Transaction2.encodingSchema),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionsResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transactions -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ currentRound, transactions, nextToken }) {
    this.currentRound = ensureBigInt(currentRound);
    this.transactions = transactions;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-round", this.currentRound],
      ["transactions", this.transactions.map((v) => v.toEncodingData())],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionsResponse: ${data}`);
    }
    return new _TransactionsResponse({
      currentRound: data.get("current-round"),
      transactions: (data.get("transactions") ?? []).map((v) => Transaction2.fromEncodingData(v)),
      nextToken: data.get("next-token")
    });
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/makeHealthCheck.js
var MakeHealthCheck = class extends JSONRequest {
  /**
   * @returns `/health`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), HealthCheck2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetBalances.js
var LookupAssetBalances = class extends JSONRequest {
  /**
   * Returns the list of accounts which hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   */
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/assets/${index}/balances`
   */
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filtered results should have an asset balance greater than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const minBalance = 1000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyGreaterThan(minBalance)
   *        .do();
   * ```
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an asset balance less than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxBalance = 2000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyLessThan(maxBalance)
   *        .do();
   * ```
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   *
   * const assetBalancesPage1 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetBalancesPage2 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetBalancesPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetBalancesResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountTransactions.js
function base64StringFunnel(data) {
  if (typeof data === "string") {
    return data;
  }
  return bytesToBase64(data);
}
var LookupAccountTransactions = class extends JSONRequest {
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   */
  constructor(c, account) {
    super(c);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/transactions`
   */
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txType("appl")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .sigType("msig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * The next page of results. Use the next token provided by the previous results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   *
   * const accountTxnsPage1 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountTxnsPage2 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .nextToken(accountTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetTransactions.js
var LookupAssetTransactions = class extends JSONRequest {
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   */
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/assets/${index}/transactions`
   */
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txType("axfer")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .sigType("lsig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const minBalance = 300000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const maxBalance = 500000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "sender";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .do();
   * ```
   *
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address.toString();
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   *
   * const assetTxnsPage1 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetTxnsPage2 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupBlock.js
var LookupBlock = class extends JSONRequest {
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  constructor(c, round) {
    super(c);
    this.round = BigInt(round);
  }
  /**
   * @returns `/v2/blocks/${round}`
   */
  path() {
    return `/v2/blocks/${this.round}`;
  }
  /**
   * Header only flag. When this is set to true, returned block does not contain the
   * transactions.
   */
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Block3);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupTransactionByID.js
var LookupTransactionByID = class extends JSONRequest {
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  constructor(c, txID) {
    super(c);
    this.txID = txID;
  }
  /**
   * @returns `/v2/transactions/${txID}`
   */
  path() {
    return `/v2/transactions/${this.txID}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountByID.js
var LookupAccountByID = class extends JSONRequest {
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, account) {
    super(c);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}`
   */
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll()
   *        .do();
   * ```
   * @param value
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAssets.js
var LookupAccountAssets = class extends JSONRequest {
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, account) {
    super(c);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/assets`
   */
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .assetId(assetId)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetId(index) {
    this.query["asset-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetHoldingsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedAssets.js
var LookupAccountCreatedAssets = class extends JSONRequest {
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, account) {
    super(c);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/created-assets`
   */
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetID(index) {
    this.query["asset-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAppLocalStates.js
var LookupAccountAppLocalStates = class extends JSONRequest {
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, account) {
    super(c);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/apps-local-state`
   */
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index) {
    this.query["application-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationLocalStatesResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedApplications.js
var LookupAccountCreatedApplications = class extends JSONRequest {
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, account) {
    super(c);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/created-applications`
   */
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index) {
    this.query["application-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetByID.js
var LookupAssetByID = class extends JSONRequest {
  /**
   * Returns asset information of the queried asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   */
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/assets/${index}`
   */
  path() {
    return `/v2/assets/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplications.js
var LookupApplications = class extends JSONRequest {
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/applications/${index}`
   */
  path() {
    return `/v2/applications/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationLogs.js
var LookupApplicationLogs = class extends JSONRequest {
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  constructor(c, appID) {
    super(c);
    this.appID = BigInt(appID);
  }
  /**
   * @returns `/v2/applications/${appID}/logs`
   */
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const appLogsPage1 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   *
   * const appLogsPage2 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .nextToken(appLogsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Only include transactions with this sender address.
   *
   * #### Example
   * ```typescript
   * const sender = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .sender(sender)
   *        .do();
   * ```
   *
   * @param senderAddress
   * @category query
   */
  sender(senderAddress) {
    this.query["sender-address"] = senderAddress;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationLogsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationBoxByIDandName.js
var LookupApplicationBoxByIDandName = class extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, index, boxName) {
    super(c);
    this.index = BigInt(index);
    const encodedName = bytesToBase64(boxName);
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Box2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchAccounts.js
var SearchAccounts = class extends JSONRequest {
  /**
   * @returns `/v2/accounts`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/accounts";
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for accounts with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude accounts with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const accountsPage1 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   *
   * const accountsPage2 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .nextToken(accountsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks For performance reasons, this parameter may be disabled on some configurations.
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include accounts that use this spending key.
   *
   * #### Example
   * ```typescript
   * const authAddr = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .authAddr(authAddr)
   *        .do();
   * ```
   *
   * @param authAddr
   */
  authAddr(authAddr) {
    this.query["auth-addr"] = authAddr.toString();
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
  /**
   * If true, only online accounts will be returned in the response.
   *
   * #### Example
   * ```typescript
   * const onlineOnly = true;
   * const accounts = await indexerClient
   *        .searchAccounts
   *        .onlineOnly(onlineOnly)
   *        .do();
   * ```
   *
   * @param onlineOnly - if true, only online accounts will be returned in the response
   * @category query
   */
  onlineOnly(onlineOnly) {
    this.query["online-only"] = onlineOnly;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForBlockHeaders.js
var SearchForBlockHeaders = class extends JSONRequest {
  /**
   * @returns `/v2/block-headers`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/block-headers";
  }
  /**
   * Accounts marked as absent in the block header's participation updates.
   *
   * #### Example
   * ```typescript
   * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .absent([address1,address2])
   *        .do();
   * ```
   *
   * @param absent - a comma separated list of addresses
   * @category query
   */
  absent(absent) {
    this.query.absent = absent;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Accounts marked as expired in the block header's participation updates.
   *
   * #### Example
   * ```typescript
   * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .expired([address1,address2])
   *        .do();
   * ```
   *
   * @param expired - - a comma separated list of addresses
   * @category query
   */
  expired(expired) {
    this.query.expired = expired;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const bh1 = await indexerClient
   *        .searchForBlockHeaders()
   *        .limit(maxResults)
   *        .do();
   *
   * const bh2 = await indexerClient
   *        .searchForBlockHeaders()
   *        .limit(maxResults)
   *        .nextToken(bh1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Accounts marked as proposer in the block header's participation updates.
   *
   * #### Example
   * ```typescript
   * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .proposers([address1,address2])
   *        .do();
   * ```
   *
   * @param proposers - a comma separated list of addresses
   * @category query
   */
  proposers(proposers) {
    this.query.proposers = proposers;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BlockHeadersResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForTransactions.js
var SearchForTransactions = class extends JSONRequest {
  /**
   * @returns `/v2/transactions`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txType("keyreg")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .sigType("sig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Lookup transactions by group ID.
   *
   * #### Example
   * ```typescript
   * const groupIdBase64Encoded = "A62qVigWtWo0laUzcE1iZY8+KXWzK1vSkgwN/eKgvjc=";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .groupid(groupIdBase64Encoded)
   *        .do();
   * ```
   *
   * @param groupid - base64 string or uint8array
   * @category query
   */
  groupid(groupid) {
    this.query["group-id"] = base64StringFunnel(groupid);
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupBlock(targetBlock).do()`
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetTransactions(assetId).do()`
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "freeze-target";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAccountTransactions(address).do()`
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address.toString();
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const txnsPage1 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   *
   * const txnsPage2 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .nextToken(txnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForAssets.js
var SearchForAssets = class extends JSONRequest {
  /**
   * @returns `/v2/assets`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/assets";
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filter just assets with the given creator address.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .creator(address)
   *        .do();
   * ```
   *
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator.toString();
    return this;
  }
  /**
   * Filter just assets with the given name.
   *
   * #### Example
   * ```typescript
   * const name = "Test Token";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .name(name)
   *        .do();
   * ```
   *
   * @param name
   * @category query
   */
  name(name) {
    this.query.name = name;
    return this;
  }
  /**
   * Filter just assets with the given unit.
   *
   * #### Example
   * ```typescript
   * const unit = "test";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .unit(unit)
   *        .do();
   * ```
   *
   * @param unit
   * @category query
   */
  unit(unit) {
    this.query.unit = unit;
    return this;
  }
  /**
   * Asset ID for filter, as int.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .index(assetId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetByID(assetId).do();`
   * @param index
   * @category query
   */
  index(index) {
    this.query["asset-id"] = index;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const assetsPage1 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   *
   * const assetsPage2 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .nextToken(assetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplications.js
var SearchForApplications = class extends JSONRequest {
  /**
   * @returns `/v2/applications`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/applications";
  }
  /**
   * Application ID for filter, as int
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .index(appId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupApplications(appId).do()`
   * @param index
   * @category query
   */
  index(index) {
    this.query["application-id"] = index;
    return this;
  }
  /**
   * Creator for filter, as string
   *
   * #### Example
   * ```typescript
   * const creator = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .creator(creator)
   *        .do();
   * ```
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator.toString();
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const appsPage1 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   *
   * const appsPage2 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .nextToken(appsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplicationBoxes.js
var SearchForApplicationBoxes = class extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, index) {
    super(c);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResponse = await indexerClient
   *        .searchForApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BoxesResponse2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/indexer.js
var IndexerClient = class extends ServiceClient {
  /**
   * Create an IndexerClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "";
   * const server = "http://localhost";
   * const port   = 8980;
   * const indexerClient = new algosdk.Indexer(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node with indexer, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The API token for the Indexer API
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
    super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns the health object for the service.
   * Returns 200 if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await indexerClient.makeHealthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-health)
   * @category GET
   */
  makeHealthCheck() {
    return new MakeHealthCheck(this.c);
  }
  /**
   * Returns the list of accounts who hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetBalances(index) {
    return new LookupAssetBalances(this.c, index);
  }
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetTransactions(index) {
    return new LookupAssetTransactions(this.c, index);
  }
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   * @category GET
   */
  lookupAccountTransactions(account) {
    return new LookupAccountTransactions(this.c, account);
  }
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  lookupBlock(round) {
    return new LookupBlock(this.c, round);
  }
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  lookupTransactionByID(txID) {
    return new LookupTransactionByID(this.c, txID);
  }
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountByID(account) {
    return new LookupAccountByID(this.c, account);
  }
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAssets(account) {
    return new LookupAccountAssets(this.c, account);
  }
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedAssets(account) {
    return new LookupAccountCreatedAssets(this.c, account);
  }
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAppLocalStates(account) {
    return new LookupAccountAppLocalStates(this.c, account);
  }
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedApplications(account) {
    return new LookupAccountCreatedApplications(this.c, account);
  }
  /**
   * Returns information about the passed asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The ID of the asset ot look up.
   * @category GET
   */
  lookupAssetByID(index) {
    return new LookupAssetByID(this.c, index);
  }
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  lookupApplications(index) {
    return new LookupApplications(this.c, index);
  }
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  lookupApplicationLogs(appID) {
    return new LookupApplicationLogs(this.c, appID);
  }
  /**
   * Returns information about indexed accounts.
   *
   * #### Example
   * ```typescript
   * const accounts = await indexerClient.searchAccounts().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accounts)
   * @category GET
   */
  searchAccounts() {
    return new SearchAccounts(this.c);
  }
  /**
   * Returns information about indexed block headers.
   *
   * #### Example
   * ```typescript
   * const bhs = await indexerClient.searchForBlockHeaders().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2block-headers)
   * @category GET
   */
  searchForBlockHeaders() {
    return new SearchForBlockHeaders(this.c);
  }
  /**
   * Returns information about indexed transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient.searchForTransactions().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactions)
   * @category GET
   */
  searchForTransactions() {
    return new SearchForTransactions(this.c);
  }
  /**
   * Returns information about indexed assets.
   *
   * #### Example
   * ```typescript
   * const assets = await indexerClient.searchForAssets().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assets)
   * @category GET
   */
  searchForAssets() {
    return new SearchForAssets(this.c);
  }
  /**
   * Returns information about indexed applications.
   *
   * #### Example
   * ```typescript
   * const apps = await indexerClient.searchForApplications().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applications)
   * @category GET
   */
  searchForApplications() {
    return new SearchForApplications(this.c);
  }
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  searchForApplicationBoxes(appID) {
    return new SearchForApplicationBoxes(this.c, appID);
  }
  /**
   * Returns information about the application box given its name.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  lookupApplicationBoxByIDandName(appID, boxName) {
    return new LookupApplicationBoxByIDandName(this.c, appID, boxName);
  }
};

// node_modules/algosdk/dist/esm/wait.js
async function waitForConfirmation(client, txid, waitRounds) {
  const status = await client.status().do();
  if (typeof status === "undefined") {
    throw new Error("Unable to get node status");
  }
  const startRound = status.lastRound + BigInt(1);
  const stopRound = startRound + BigInt(waitRounds);
  let currentRound = startRound;
  while (currentRound < stopRound) {
    let poolError = false;
    try {
      const pendingInfo = await client.pendingTransactionInformation(txid).do();
      if (pendingInfo.confirmedRound) {
        return pendingInfo;
      }
      if (pendingInfo.poolError) {
        poolError = true;
        throw new Error(`Transaction Rejected: ${pendingInfo.poolError}`);
      }
    } catch (err) {
      if (poolError) {
        throw err;
      }
    }
    await client.statusAfterBlock(currentRound).do();
    currentRound += BigInt(1);
  }
  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
}

// node_modules/algosdk/dist/esm/encoding/bigint.js
function bigIntToBytes(bi, size) {
  let hex = bi.toString(16);
  if (hex.length !== size * 2) {
    hex = hex.padStart(size * 2, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {
    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);
  }
  return byteArray;
}
function bytesToBigInt(bytes) {
  let res = BigInt(0);
  const buf = new DataView(bytes.buffer, bytes.byteOffset);
  for (let i = 0; i < bytes.length; i++) {
    res = BigInt(Number(buf.getUint8(i))) + res * BigInt(256);
  }
  return res;
}

// node_modules/algosdk/dist/esm/account.js
function generateAccount() {
  const keys = keyPair();
  const addr = new Address(keys.publicKey);
  return { addr, sk: keys.secretKey };
}

// node_modules/algosdk/dist/esm/mnemonic/wordlists/english.js
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
var english_default = english;

// node_modules/algosdk/dist/esm/mnemonic/mnemonic.js
var FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
var NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
function toUint11Array(buffer8) {
  const buffer11 = [];
  let acc = 0;
  let accBits = 0;
  function add(octet) {
    acc |= octet << accBits;
    accBits += 8;
    if (accBits >= 11) {
      buffer11.push(acc & 2047);
      acc >>= 11;
      accBits -= 11;
    }
  }
  function flush() {
    if (accBits) {
      buffer11.push(acc);
    }
  }
  buffer8.forEach(add);
  flush();
  return buffer11;
}
function applyWords(nums) {
  return nums.map((n) => english_default[n]);
}
function computeChecksum(seed) {
  const hashBuffer = genericHash(seed);
  const uint11Hash = toUint11Array(hashBuffer);
  const words = applyWords(uint11Hash);
  return words[0];
}
function mnemonicFromSeed(seed) {
  if (seed.length !== SEED_BTYES_LENGTH) {
    throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
  }
  const uint11Array = toUint11Array(seed);
  const words = applyWords(uint11Array);
  const checksumWord = computeChecksum(seed);
  return `${words.join(" ")} ${checksumWord}`;
}
function toUint8Array(buffer11) {
  const buffer8 = [];
  let acc = 0;
  let accBits = 0;
  function add(ui11) {
    acc |= ui11 << accBits;
    accBits += 11;
    while (accBits >= 8) {
      buffer8.push(acc & 255);
      acc >>= 8;
      accBits -= 8;
    }
  }
  function flush() {
    if (accBits) {
      buffer8.push(acc);
    }
  }
  buffer11.forEach(add);
  flush();
  return new Uint8Array(buffer8);
}
function seedFromMnemonic(mnemonic) {
  const words = mnemonic.split(" ");
  const key = words.slice(0, 24);
  for (const w of key) {
    if (english_default.indexOf(w) === -1)
      throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
  }
  const checksum = words[words.length - 1];
  const uint11Array = key.map((word) => english_default.indexOf(word));
  let uint8Array = toUint8Array(uint11Array);
  if (uint8Array.length !== 33)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  if (uint8Array[uint8Array.length - 1] !== 0)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  uint8Array = uint8Array.slice(0, uint8Array.length - 1);
  const cs = computeChecksum(uint8Array);
  if (cs === checksum)
    return uint8Array;
  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
}
function mnemonicToSecretKey(mn) {
  const seed = seedFromMnemonic(mn);
  const keys = keyPairFromSeed(seed);
  const addr = new Address(keys.publicKey);
  return { addr, sk: keys.secretKey };
}
function secretKeyToMnemonic(sk) {
  const seed = sk.slice(0, SEED_BTYES_LENGTH);
  return mnemonicFromSeed(seed);
}
function mnemonicToMasterDerivationKey(mn) {
  return seedFromMnemonic(mn);
}
function masterDerivationKeyToMnemonic(mdk) {
  return mnemonicFromSeed(mdk);
}

// node_modules/algosdk/dist/esm/group.js
var ALGORAND_MAX_TX_GROUP_SIZE = 16;
var TX_GROUP_TAG = new TextEncoder().encode("TG");
function txGroupPreimage(txnHashes) {
  if (txnHashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
    throw new Error(`${txnHashes.length} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE}`);
  }
  if (txnHashes.length === 0) {
    throw new Error("Cannot compute group ID of zero transactions");
  }
  const bytes = msgpackRawEncode({
    txlist: txnHashes
  });
  return concatArrays(TX_GROUP_TAG, bytes);
}
function computeGroupID(txns) {
  const hashes = [];
  for (const txn of txns) {
    hashes.push(txn.rawTxID());
  }
  const toBeHashed = txGroupPreimage(hashes);
  const gid = genericHash(toBeHashed);
  return Uint8Array.from(gid);
}
function assignGroupID(txns) {
  const gid = computeGroupID(txns);
  for (const txn of txns) {
    txn.group = gid;
  }
  return txns;
}

// node_modules/algosdk/dist/esm/signing.js
function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
  if (!lsig.verify(lsigAddress.publicKey)) {
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  }
  let sgnr;
  if (!bytesEqual(lsigAddress.publicKey, txn.sender.publicKey)) {
    sgnr = lsigAddress;
  }
  const signedTxn = new SignedTransaction({
    lsig,
    txn,
    sgnr
  });
  return {
    txID: txn.txID(),
    blob: encodeMsgpack(signedTxn)
  };
}
function signLogicSigTransactionObject(txn, lsigObject) {
  let lsig;
  let lsigAddress;
  if (lsigObject instanceof LogicSigAccount) {
    lsig = lsigObject.lsig;
    lsigAddress = lsigObject.address();
  } else {
    lsig = lsigObject;
    if (lsig.sig) {
      lsigAddress = new Address(txn.sender.publicKey);
    } else if (lsig.lmsig) {
      const msigMetadata = {
        version: lsig.lmsig.v,
        threshold: lsig.lmsig.thr,
        pks: lsig.lmsig.subsig.map((subsig) => subsig.pk)
      };
      lsigAddress = addressFromMultisigPreImg(msigMetadata);
    } else {
      lsigAddress = lsig.address();
    }
  }
  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
}
function signLogicSigTransaction(txn, lsigObject) {
  return signLogicSigTransactionObject(txn, lsigObject);
}

// node_modules/algosdk/dist/esm/multisigSigning.js
var MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
var MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
var MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
var MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
var MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
var MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = "Cannot add multisig signature. Signature is not of the correct length.";
var MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
function createMultisigTransaction(txn, { version, threshold, addrs }) {
  const pks = pksFromAddresses(addrs);
  const subsigs = pks.map((pk) => ({ pk }));
  const msig = {
    v: version,
    thr: threshold,
    subsig: subsigs
  };
  const msigAddr = addressFromMultisigPreImg({
    version,
    threshold,
    pks
  });
  let sgnr;
  if (!txn.sender.equals(msigAddr)) {
    sgnr = msigAddr;
  }
  const signedTxn = new SignedTransaction({
    txn,
    msig,
    sgnr
  });
  return encodeMsgpack(signedTxn);
}
function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version, threshold, pks }) {
  const encodedMsig = createMultisigTransaction(txn, {
    version,
    threshold,
    addrs: pks.map((pk) => new Address(pk))
  });
  const signedTxn = decodeMsgpack(encodedMsig, SignedTransaction);
  let keyExist = false;
  signedTxn.msig.subsig.forEach((subsig, i) => {
    if (bytesEqual(subsig.pk, myPk)) {
      keyExist = true;
      signedTxn.msig.subsig[i].s = rawSig;
    }
  });
  if (!keyExist) {
    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
  }
  return encodeMsgpack(signedTxn);
}
function partialSignTxn(transaction, { version, threshold, pks }, sk) {
  const myPk = keyPairFromSecretKey(sk).publicKey;
  return createMultisigTransactionWithSignature(transaction, { rawSig: transaction.rawSignTxn(sk), myPk }, { version, threshold, pks });
}
function partialSignWithMultisigSignature(transaction, metadata, signerAddr, signature) {
  if (!isValidSignatureLength(signature.length)) {
    throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
  }
  const signerAddressObj = typeof signerAddr === "string" ? Address.fromString(signerAddr) : signerAddr;
  return createMultisigTransactionWithSignature(transaction, {
    rawSig: signature,
    myPk: signerAddressObj.publicKey
  }, metadata);
}
function mergeMultisigTransactions(multisigTxnBlobs) {
  if (multisigTxnBlobs.length < 2) {
    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
  }
  const refSigTx = decodeMsgpack(multisigTxnBlobs[0], SignedTransaction);
  if (!refSigTx.msig) {
    throw new Error("Invalid multisig transaction, multisig structure missing at index 0");
  }
  const refTxID = refSigTx.txn.txID();
  const refAuthAddr = refSigTx.sgnr ? refSigTx.sgnr.toString() : void 0;
  const refPreImage = {
    version: refSigTx.msig.v,
    threshold: refSigTx.msig.thr,
    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
  };
  const refMsigAddr = addressFromMultisigPreImg(refPreImage);
  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));
  for (let i = 1; i < multisigTxnBlobs.length; i++) {
    const unisig = decodeMsgpack(multisigTxnBlobs[i], SignedTransaction);
    if (!unisig.msig) {
      throw new Error(`Invalid multisig transaction, multisig structure missing at index ${i}`);
    }
    if (unisig.txn.txID() !== refTxID) {
      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
    }
    const authAddr = unisig.sgnr ? unisig.sgnr.toString() : void 0;
    if (refAuthAddr !== authAddr) {
      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
    }
    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    const preimg = {
      version: unisig.msig.v,
      threshold: unisig.msig.thr,
      pks: unisig.msig.subsig.map((subsig) => subsig.pk)
    };
    const msgigAddr = addressFromMultisigPreImg(preimg);
    if (!refMsigAddr.equals(msgigAddr)) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    unisig.msig.subsig.forEach((uniSubsig, index) => {
      if (!uniSubsig.s)
        return;
      const current = newSubsigs[index];
      if (current.s && !arrayEqual(uniSubsig.s, current.s)) {
        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
      }
      current.s = uniSubsig.s;
    });
  }
  const msig = {
    v: refSigTx.msig.v,
    thr: refSigTx.msig.thr,
    subsig: newSubsigs
  };
  const refSgnr = typeof refAuthAddr !== "undefined" ? refSigTx.sgnr : void 0;
  const signedTxn = new SignedTransaction({
    msig,
    txn: refSigTx.txn,
    sgnr: refSgnr
  });
  return encodeMsgpack(signedTxn);
}
function signMultisigTransaction(txn, { version, threshold, addrs }, sk) {
  const pks = pksFromAddresses(addrs);
  const blob = partialSignTxn(txn, { version, threshold, pks }, sk);
  return {
    txID: txn.txID(),
    blob
  };
}
function appendSignMultisigTransaction(multisigTxnBlob, { version, threshold, addrs }, sk) {
  const pks = pksFromAddresses(addrs);
  const multisigTxObj = decodeMsgpack(multisigTxnBlob, SignedTransaction);
  const partialSignedBlob = partialSignTxn(multisigTxObj.txn, { version, threshold, pks }, sk);
  return {
    txID: multisigTxObj.txn.txID(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function appendSignRawMultisigSignature(multisigTxnBlob, { version, threshold, addrs }, signerAddr, signature) {
  const pks = pksFromAddresses(addrs);
  const multisigTxObj = decodeMsgpack(multisigTxnBlob, SignedTransaction);
  const partialSignedBlob = partialSignWithMultisigSignature(multisigTxObj.txn, { version, threshold, pks }, signerAddr, signature);
  return {
    txID: multisigTxObj.txn.txID(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}

// node_modules/vlq/src/index.js
var char_to_integer = {};
var integer_to_char = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i) {
  char_to_integer[char] = i;
  integer_to_char[i] = char;
});
function decode2(string) {
  let result = [];
  let shift = 0;
  let value = 0;
  for (let i = 0; i < string.length; i += 1) {
    let integer = char_to_integer[string[i]];
    if (integer === void 0) {
      throw new Error("Invalid character (" + string[i] + ")");
    }
    const has_continuation_bit = integer & 32;
    integer &= 31;
    value += integer << shift;
    if (has_continuation_bit) {
      shift += 5;
    } else {
      const should_negate = value & 1;
      value >>>= 1;
      if (should_negate) {
        result.push(value === 0 ? -2147483648 : -value);
      } else {
        result.push(value);
      }
      value = shift = 0;
    }
  }
  return result;
}

// node_modules/algosdk/dist/esm/logic/sourcemap.js
var ProgramSourceMap = class {
  constructor({ version, sources, names, mappings }) {
    this.version = version;
    this.sources = sources;
    this.names = names;
    this.mappings = mappings;
    if (this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    const pcList = this.mappings.split(";").map(decode2);
    this.pcToLocation = /* @__PURE__ */ new Map();
    this.sourceAndLineToPc = /* @__PURE__ */ new Map();
    const lastLocation = {
      line: 0,
      column: 0,
      sourceIndex: 0,
      nameIndex: 0
    };
    for (const [pc, data] of pcList.entries()) {
      if (data.length < 4)
        continue;
      const nameDelta = data.length > 4 ? data[4] : void 0;
      const [, sourceDelta, lineDelta, columnDelta] = data;
      lastLocation.sourceIndex += sourceDelta;
      lastLocation.line += lineDelta;
      lastLocation.column += columnDelta;
      if (typeof nameDelta !== "undefined") {
        lastLocation.nameIndex += nameDelta;
      }
      const sourceAndLineKey = `${lastLocation.sourceIndex}:${lastLocation.line}`;
      let pcsForSourceAndLine = this.sourceAndLineToPc.get(sourceAndLineKey);
      if (pcsForSourceAndLine === void 0) {
        pcsForSourceAndLine = [];
        this.sourceAndLineToPc.set(sourceAndLineKey, pcsForSourceAndLine);
      }
      const pcInLine = {
        pc,
        column: lastLocation.column
      };
      const pcLocation = {
        line: lastLocation.line,
        column: lastLocation.column,
        sourceIndex: lastLocation.sourceIndex
      };
      if (typeof nameDelta !== "undefined") {
        pcInLine.nameIndex = lastLocation.nameIndex;
        pcLocation.nameIndex = lastLocation.nameIndex;
      }
      pcsForSourceAndLine.push(pcInLine);
      this.pcToLocation.set(pc, pcLocation);
    }
  }
  getPcs() {
    return Array.from(this.pcToLocation.keys());
  }
  getLocationForPc(pc) {
    return this.pcToLocation.get(pc);
  }
  getPcsOnSourceLine(sourceIndex, line) {
    const pcs = this.sourceAndLineToPc.get(`${sourceIndex}:${line}`);
    if (pcs === void 0)
      return [];
    return pcs;
  }
};

// node_modules/algosdk/dist/esm/dryrun.js
var defaultAppId = 1380011588;
var defaultMaxWidth = 30;
async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
  const appInfos = [];
  const acctInfos = [];
  const apps = [];
  const assets = [];
  const accts = [];
  for (const t of txns) {
    if (t.txn.type === TransactionType.appl) {
      accts.push(t.txn.sender.toString());
      accts.push(...t.txn.applicationCall.accounts.map((a) => a.toString()));
      apps.push(...t.txn.applicationCall.foreignApps);
      accts.push(...t.txn.applicationCall.foreignApps.map(getApplicationAddress).map((a) => a.toString()));
      assets.push(...t.txn.applicationCall.foreignAssets);
      if (t.txn.applicationCall.appIndex === BigInt(0)) {
        appInfos.push(new Application({
          id: defaultAppId,
          params: new ApplicationParams({
            creator: t.txn.sender.toString(),
            approvalProgram: t.txn.applicationCall.approvalProgram,
            clearStateProgram: t.txn.applicationCall.clearProgram,
            localStateSchema: new ApplicationStateSchema({
              numUint: t.txn.applicationCall.numLocalInts,
              numByteSlice: t.txn.applicationCall.numLocalByteSlices
            }),
            globalStateSchema: new ApplicationStateSchema({
              numUint: t.txn.applicationCall.numGlobalInts,
              numByteSlice: t.txn.applicationCall.numGlobalByteSlices
            })
          })
        }));
      } else {
        const { appIndex } = t.txn.applicationCall;
        apps.push(appIndex);
        accts.push(getApplicationAddress(appIndex).toString());
      }
    }
  }
  const assetPromises = [];
  for (const assetId of new Set(assets)) {
    assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
      accts.push(assetInfo.params.creator);
    }));
  }
  await Promise.all(assetPromises);
  const appPromises = [];
  for (const appId of new Set(apps)) {
    appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
      appInfos.push(appInfo);
      accts.push(appInfo.params.creator.toString());
    }));
  }
  await Promise.all(appPromises);
  const acctPromises = [];
  for (const acct of new Set(accts)) {
    acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
      acctInfos.push(acctInfo);
    }));
  }
  await Promise.all(acctPromises);
  return new DryrunRequest({
    txns: txns.slice(),
    accounts: acctInfos,
    apps: appInfos,
    latestTimestamp: latestTimestamp ?? 0,
    round: round ?? 0,
    protocolVersion: protocolVersion ?? "",
    sources: sources ?? []
  });
}
function truncate(str, maxValueWidth) {
  if (str.length > maxValueWidth && maxValueWidth > 0) {
    return `${str.slice(0, maxValueWidth)}...`;
  }
  return str;
}
function scratchToString(prevScratch, currScratch) {
  if (currScratch.length === 0)
    return "";
  let newScratchIdx = null;
  for (let idx = 0; idx < currScratch.length; idx++) {
    if (idx > prevScratch.length) {
      newScratchIdx = idx;
      continue;
    }
    if (stringifyJSON(prevScratch[idx]) !== stringifyJSON(currScratch[idx])) {
      newScratchIdx = idx;
    }
  }
  if (newScratchIdx == null)
    return "";
  const newScratch = currScratch[newScratchIdx];
  if (newScratch.bytes.length > 0) {
    return `${newScratchIdx} = 0x${bytesToHex(newScratch.bytes)}`;
  }
  return `${newScratchIdx} = ${newScratch.uint.toString()}`;
}
function stackToString(stack, reverse) {
  const svs = reverse ? stack.reverse() : stack;
  return `[${svs.map((sv) => {
    switch (sv.type) {
      case 1:
        return `0x${bytesToHex(sv.bytes)}`;
      case 2:
        return sv.uint.toString();
      default:
        return "";
    }
  }).join(", ")}]`;
}
function dryrunTrace(trace, disassembly, spc) {
  const maxWidth = spc.maxValueWidth || defaultMaxWidth;
  const lines = [["pc#", "ln#", "source", "scratch", "stack"]];
  for (let idx = 0; idx < trace.length; idx++) {
    const { line, error, pc, scratch, stack } = trace[idx];
    const currScratch = scratch !== void 0 ? scratch : [];
    const prevScratch = idx > 0 && trace[idx - 1].scratch !== void 0 ? trace[idx - 1].scratch : [];
    const src = !error ? disassembly[line] : `!! ${error} !!`;
    lines.push([
      pc.toString().padEnd(3, " "),
      line.toString().padEnd(3, " "),
      truncate(src, maxWidth),
      truncate(scratchToString(prevScratch, currScratch), maxWidth),
      truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)
    ]);
  }
  const maxLengths = lines.reduce((prev, curr) => {
    const newVal = new Array(lines[0].length).fill(0);
    for (let idx = 0; idx < prev.length; idx++) {
      newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];
    }
    return newVal;
  }, new Array(lines[0].length).fill(0));
  return `${lines.map((line) => line.map((v, idx) => v.padEnd(maxLengths[idx] + 1, " ")).join("|").trim()).join("\n")}
`;
}
function dryrunTxnResultAppTrace(result, spc) {
  if (!result.appCallTrace || !result.disassembly)
    return "";
  let conf = spc;
  if (spc !== void 0)
    conf = spc;
  else {
    conf = {
      maxValueWidth: defaultMaxWidth,
      topOfStackFirst: false
    };
  }
  return dryrunTrace(result.appCallTrace, result.disassembly, conf);
}
function dryrunTxnResultLogicSigTrace(result, spc) {
  if (!result.logicSigTrace || !result.logicSigDisassembly)
    return "";
  let conf;
  if (spc !== void 0)
    conf = spc;
  else {
    conf = {
      maxValueWidth: defaultMaxWidth,
      topOfStackFirst: true
    };
  }
  return dryrunTrace(result.logicSigTrace, result.logicSigDisassembly, conf);
}

// node_modules/algosdk/dist/esm/makeTxn.js
function makePaymentTxnWithSuggestedParamsFromObject({ sender, receiver, amount, closeRemainderTo, suggestedParams, note, lease, rekeyTo }) {
  return new Transaction({
    type: TransactionType.pay,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    paymentParams: {
      receiver,
      amount,
      closeRemainderTo
    }
  });
}
function makeKeyRegistrationTxnWithSuggestedParamsFromObject({ sender, voteKey, selectionKey, stateProofKey, voteFirst, voteLast, voteKeyDilution, nonParticipation, suggestedParams, note, lease, rekeyTo }) {
  return new Transaction({
    type: TransactionType.keyreg,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    keyregParams: {
      voteKey,
      selectionKey,
      stateProofKey,
      voteFirst,
      voteLast,
      voteKeyDilution,
      nonParticipation
    }
  });
}
function makeBaseAssetConfigTxn({ sender, assetIndex, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, note, lease, rekeyTo, suggestedParams }) {
  return new Transaction({
    type: TransactionType.acfg,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    assetConfigParams: {
      assetIndex,
      total,
      decimals,
      defaultFrozen,
      manager,
      reserve,
      freeze,
      clawback,
      unitName,
      assetName,
      assetURL,
      assetMetadataHash
    }
  });
}
function makeAssetCreateTxnWithSuggestedParamsFromObject({ sender, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, note, lease, rekeyTo, suggestedParams }) {
  return makeBaseAssetConfigTxn({
    sender,
    total,
    decimals,
    defaultFrozen,
    manager,
    reserve,
    freeze,
    clawback,
    unitName,
    assetName,
    assetURL,
    assetMetadataHash,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeAssetConfigTxnWithSuggestedParamsFromObject({ sender, assetIndex, manager, reserve, freeze, clawback, strictEmptyAddressChecking, note, lease, rekeyTo, suggestedParams }) {
  if (!assetIndex) {
    throw Error("assetIndex must be provided");
  }
  const strictChecking = strictEmptyAddressChecking ?? true;
  if (strictChecking && (manager == null || reserve == null || freeze == null || clawback == null)) {
    throw Error("strictEmptyAddressChecking is enabled, but an address is empty. If this is intentional, set strictEmptyAddressChecking to false.");
  }
  return makeBaseAssetConfigTxn({
    sender,
    assetIndex,
    manager,
    reserve,
    freeze,
    clawback,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeAssetDestroyTxnWithSuggestedParamsFromObject({ sender, assetIndex, note, lease, rekeyTo, suggestedParams }) {
  if (!assetIndex) {
    throw Error("assetIndex must be provided");
  }
  return makeBaseAssetConfigTxn({
    sender,
    assetIndex,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeAssetFreezeTxnWithSuggestedParamsFromObject({ sender, assetIndex, freezeTarget, frozen, suggestedParams, note, lease, rekeyTo }) {
  return new Transaction({
    type: TransactionType.afrz,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    assetFreezeParams: {
      assetIndex,
      freezeTarget,
      frozen
    }
  });
}
function makeAssetTransferTxnWithSuggestedParamsFromObject({ sender, receiver, amount, closeRemainderTo, assetSender, note, assetIndex, suggestedParams, rekeyTo, lease }) {
  if (!assetIndex) {
    throw Error("assetIndex must be provided");
  }
  return new Transaction({
    type: TransactionType.axfer,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    assetTransferParams: {
      assetIndex,
      receiver,
      amount,
      assetSender,
      closeRemainderTo
    }
  });
}
function makeApplicationCallTxnFromObject({ sender, appIndex, onComplete, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, extraPages, rejectVersion, note, lease, rekeyTo, suggestedParams }) {
  if (onComplete == null) {
    throw Error("onComplete must be provided");
  }
  if (access && (accounts || foreignApps || foreignAssets || boxes || holdings || locals)) {
    throw Error("cannot specify both access and other access fields");
  }
  let access2 = access;
  if (convertToAccess) {
    access2 = foreignArraysToResourceReferences({
      appIndex,
      accounts,
      foreignApps,
      foreignAssets,
      holdings,
      locals,
      boxes
    });
  }
  return new Transaction({
    type: TransactionType.appl,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    appCallParams: {
      appIndex,
      onComplete,
      appArgs,
      // Only pass legacy foreign arrays if access is not provided
      accounts: access2 ? void 0 : accounts,
      foreignAssets: access2 ? void 0 : foreignAssets,
      foreignApps: access2 ? void 0 : foreignApps,
      boxes: access2 ? void 0 : boxes,
      access: access2,
      approvalProgram,
      clearProgram,
      numLocalInts,
      numLocalByteSlices,
      numGlobalInts,
      numGlobalByteSlices,
      extraPages,
      rejectVersion
    }
  });
}
function makeApplicationCreateTxnFromObject({ sender, onComplete, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, extraPages, note, lease, rekeyTo, suggestedParams }) {
  if (!approvalProgram || !clearProgram) {
    throw Error("approvalProgram and clearProgram must be provided");
  }
  if (onComplete == null) {
    throw Error("onComplete must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex: 0,
    onComplete,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    approvalProgram,
    clearProgram,
    numLocalInts,
    numLocalByteSlices,
    numGlobalInts,
    numGlobalByteSlices,
    extraPages,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationUpdateTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, approvalProgram, clearProgram, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  if (!approvalProgram || !clearProgram) {
    throw Error("approvalProgram and clearProgram must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.UpdateApplicationOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    approvalProgram,
    clearProgram,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationDeleteTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.DeleteApplicationOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationOptInTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.OptInOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    note,
    convertToAccess,
    holdings,
    locals,
    access,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationCloseOutTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.CloseOutOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationClearStateTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.ClearStateOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationNoOpTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.NoOpOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}

// node_modules/algosdk/dist/esm/signer.js
function makeBasicAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      signed.push(txnGroup[index].signTxn(account.sk));
    }
    return Promise.resolve(signed);
  };
}
function makeLogicSigAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      const { blob } = signLogicSigTransactionObject(txnGroup[index], account);
      signed.push(blob);
    }
    return Promise.resolve(signed);
  };
}
function makeMultiSigAccountTransactionSigner(msig, sks) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      const txn = txnGroup[index];
      const partialSigs = [];
      for (const sk of sks) {
        const { blob } = signMultisigTransaction(txn, msig, sk);
        partialSigs.push(blob);
      }
      if (partialSigs.length > 1) {
        signed.push(mergeMultisigTransactions(partialSigs));
      } else {
        signed.push(partialSigs[0]);
      }
    }
    return Promise.resolve(signed);
  };
}
function makeEmptyTransactionSigner() {
  return (txnGroup, indexesToSign) => {
    const unsigned = [];
    for (const index of indexesToSign) {
      unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index]));
    }
    return Promise.resolve(unsigned);
  };
}
function isTransactionWithSigner(value) {
  return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
}

// node_modules/algosdk/dist/esm/abi/abi_type.js
var MAX_LEN = 2 ** 16 - 1;
var ADDR_BYTE_SIZE = 32;
var SINGLE_BYTE_SIZE = 1;
var SINGLE_BOOL_SIZE = 1;
var LENGTH_ENCODE_BYTE_SIZE = 2;
var staticArrayRegexp = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/;
var ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
var ABIType = class _ABIType {
  // De-serializes the ABI type from a string using the ABI specs
  static from(str) {
    if (str.endsWith("[]")) {
      const arrayArgType = _ABIType.from(str.slice(0, str.length - 2));
      return new ABIArrayDynamicType(arrayArgType);
    }
    if (str.endsWith("]")) {
      const stringMatches = str.match(staticArrayRegexp);
      if (!stringMatches || stringMatches.length !== 3) {
        throw new Error(`malformed static array string: ${str}`);
      }
      const arrayLengthStr = stringMatches[2];
      const arrayLength = parseInt(arrayLengthStr, 10);
      if (arrayLength > MAX_LEN) {
        throw new Error(`array length exceeds limit ${MAX_LEN}`);
      }
      const arrayType = _ABIType.from(stringMatches[1]);
      return new ABIArrayStaticType(arrayType, arrayLength);
    }
    if (str.startsWith("uint")) {
      const digitsOnly = (s) => [...s].every((c) => "0123456789".includes(c));
      const typeSizeStr = str.slice(4, str.length);
      if (!digitsOnly(typeSizeStr)) {
        throw new Error(`malformed uint string: ${typeSizeStr}`);
      }
      const typeSize = parseInt(typeSizeStr, 10);
      if (typeSize > MAX_LEN) {
        throw new Error(`malformed uint string: ${typeSize}`);
      }
      return new ABIUintType(typeSize);
    }
    if (str === "byte") {
      return new ABIByteType();
    }
    if (str.startsWith("ufixed")) {
      const stringMatches = str.match(ufixedRegexp);
      if (!stringMatches || stringMatches.length !== 3) {
        throw new Error(`malformed ufixed type: ${str}`);
      }
      const ufixedSize = parseInt(stringMatches[1], 10);
      const ufixedPrecision = parseInt(stringMatches[2], 10);
      return new ABIUfixedType(ufixedSize, ufixedPrecision);
    }
    if (str === "bool") {
      return new ABIBoolType();
    }
    if (str === "address") {
      return new ABIAddressType();
    }
    if (str === "string") {
      return new ABIStringType();
    }
    if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
      const tupleTypes = [];
      for (let i = 0; i < tupleContent.length; i++) {
        const ti = _ABIType.from(tupleContent[i]);
        tupleTypes.push(ti);
      }
      return new ABITupleType(tupleTypes);
    }
    throw new Error(`cannot convert a string ${str} to an ABI type`);
  }
};
var ABIUintType = class _ABIUintType extends ABIType {
  constructor(size) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported uint type bitSize: ${size}`);
    }
    this.bitSize = size;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(other) {
    return other instanceof _ABIUintType && this.bitSize === other.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIUfixedType = class _ABIUfixedType extends ABIType {
  constructor(size, denominator) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported ufixed type bitSize: ${size}`);
    }
    if (denominator > 160 || denominator < 1) {
      throw new Error(`unsupported ufixed type precision: ${denominator}`);
    }
    this.bitSize = size;
    this.precision = denominator;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(other) {
    return other instanceof _ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIAddressType = class _ABIAddressType extends ABIType {
  toString() {
    return "address";
  }
  equals(other) {
    return other instanceof _ABIAddressType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return ADDR_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value === "string") {
      const decodedAddress = decodeAddress(value);
      return decodedAddress.publicKey;
    }
    if (value instanceof Address) {
      return value.publicKey;
    }
    if (value instanceof Uint8Array) {
      if (value.byteLength !== 32) {
        throw new Error(`byte string must be 32 bytes long for an address`);
      }
      return value;
    }
    throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
  }
  decode(byteString) {
    if (byteString.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return encodeAddress(byteString);
  }
};
var ABIBoolType = class _ABIBoolType extends ABIType {
  toString() {
    return "bool";
  }
  equals(other) {
    return other instanceof _ABIBoolType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BOOL_SIZE;
  }
  encode(value) {
    if (typeof value !== "boolean") {
      throw new Error(`Cannot encode value as bool: ${value}`);
    }
    if (value) {
      return new Uint8Array([128]);
    }
    return new Uint8Array([0]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`bool string must be 1 byte long`);
    }
    const value = byteString[0];
    if (value === 128) {
      return true;
    }
    if (value === 0) {
      return false;
    }
    throw new Error(`boolean could not be decoded from the byte string`);
  }
};
var ABIByteType = class _ABIByteType extends ABIType {
  toString() {
    return "byte";
  }
  equals(other) {
    return other instanceof _ABIByteType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "number" && typeof value !== "bigint") {
      throw new Error(`Cannot encode value as byte: ${value}`);
    }
    if (typeof value === "bigint") {
      value = Number(value);
    }
    if (value < 0 || value > 255) {
      throw new Error(`${value} cannot be encoded into a byte`);
    }
    return new Uint8Array([value]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`byte string must be 1 byte long`);
    }
    return byteString[0];
  }
};
var ABIStringType = class _ABIStringType extends ABIType {
  toString() {
    return "string";
  }
  equals(other) {
    return other instanceof _ABIStringType;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as string: ${value}`);
    }
    let encodedBytes;
    if (typeof value === "string") {
      encodedBytes = new TextEncoder().encode(value);
    } else {
      encodedBytes = value;
    }
    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);
    mergedBytes.set(encodedLength);
    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
    return mergedBytes;
  }
  decode(byteString) {
    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
    }
    const view = new DataView(byteString.buffer, byteString.byteOffset, LENGTH_ENCODE_BYTE_SIZE);
    const byteLength = view.getUint16(0);
    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
    if (byteLength !== byteValue.length) {
      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);
    }
    return new TextDecoder("utf-8").decode(byteValue);
  }
};
var ABIArrayStaticType = class _ABIArrayStaticType extends ABIType {
  constructor(argType, arrayLength) {
    super();
    if (arrayLength < 0) {
      throw new Error(`static array must have a non negative length: ${arrayLength}`);
    }
    this.childType = argType;
    this.staticLength = arrayLength;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(other) {
    return other instanceof _ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    if (this.childType.constructor === ABIBoolType) {
      return Math.ceil(this.staticLength / 8);
    }
    return this.staticLength * this.childType.byteLen();
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value.length !== this.staticLength) {
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
    }
    const convertedTuple = this.toABITupleType();
    return convertedTuple.encode(value);
  }
  decode(byteString) {
    const convertedTuple = this.toABITupleType();
    return convertedTuple.decode(byteString);
  }
  toABITupleType() {
    return new ABITupleType(Array(this.staticLength).fill(this.childType));
  }
};
var ABIArrayDynamicType = class _ABIArrayDynamicType extends ABIType {
  constructor(argType) {
    super();
    this.childType = argType;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(other) {
    return other instanceof _ABIArrayDynamicType && this.childType.equals(other.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const convertedTuple = this.toABITupleType(value.length);
    const encodedTuple = convertedTuple.encode(value);
    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = concatArrays(encodedLength, encodedTuple);
    return mergedBytes;
  }
  decode(byteString) {
    const view = new DataView(byteString.buffer, 0, LENGTH_ENCODE_BYTE_SIZE);
    const byteLength = view.getUint16(0);
    const convertedTuple = this.toABITupleType(byteLength);
    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
  }
  toABITupleType(length) {
    return new ABITupleType(Array(length).fill(this.childType));
  }
};
var ABITupleType = class _ABITupleType extends ABIType {
  constructor(argTypes) {
    super();
    if (argTypes.length >= MAX_LEN) {
      throw new Error("tuple type child type number larger than maximum uint16 error");
    }
    this.childTypes = argTypes;
  }
  toString() {
    const typeStrings = [];
    for (let i = 0; i < this.childTypes.length; i++) {
      typeStrings[i] = this.childTypes[i].toString();
    }
    return `(${typeStrings.join(",")})`;
  }
  equals(other) {
    return other instanceof _ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));
  }
  isDynamic() {
    const isDynamic = (child) => child.isDynamic();
    return this.childTypes.some(isDynamic);
  }
  byteLen() {
    let size = 0;
    for (let i = 0; i < this.childTypes.length; i++) {
      if (this.childTypes[i].constructor === ABIBoolType) {
        const after = findBoolLR(this.childTypes, i, 1);
        const boolNum = after + 1;
        i += after;
        size += Math.trunc((boolNum + 7) / 8);
      } else {
        const childByteSize = this.childTypes[i].byteLen();
        size += childByteSize;
      }
    }
    return size;
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const values = Array.from(value);
    if (value.length > MAX_LEN) {
      throw new Error("length of tuple array should not exceed a uint16");
    }
    const tupleTypes = this.childTypes;
    const heads = [];
    const tails = [];
    const isDynamicIndex = /* @__PURE__ */ new Map();
    let i = 0;
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        isDynamicIndex.set(heads.length, true);
        heads.push(new Uint8Array([0, 0]));
        tails.push(tupleType.encode(values[i]));
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(tupleTypes, i, -1);
          let after = findBoolLR(tupleTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          }
          after = Math.min(7, after);
          const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));
          heads.push(bigIntToBytes(compressedInt, 1));
          i += after;
        } else {
          const encodedTupleValue = tupleType.encode(values[i]);
          heads.push(encodedTupleValue);
        }
        isDynamicIndex.set(i, false);
        tails.push(new Uint8Array());
      }
      i += 1;
    }
    let headLength = 0;
    for (const headElement of heads) {
      headLength += headElement.length;
    }
    let tailLength = 0;
    for (let j = 0; j < heads.length; j++) {
      if (isDynamicIndex.get(j)) {
        const headValue = headLength + tailLength;
        if (headValue > MAX_LEN) {
          throw new Error(`byte length of ${headValue} should not exceed a uint16`);
        }
        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
      }
      tailLength += tails[j].length;
    }
    return concatArrays(...heads, ...tails);
  }
  decode(byteString) {
    const tupleTypes = this.childTypes;
    const dynamicSegments = [];
    const valuePartition = [];
    let i = 0;
    let iterIndex = 0;
    const view = new DataView(byteString.buffer);
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
          throw new Error("dynamic type in tuple is too short to be decoded");
        }
        const dynamicIndex = view.getUint16(iterIndex);
        if (dynamicSegments.length > 0) {
          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
            throw new Error("dynamic index segment miscalculation: left is greater than right index");
          }
        }
        const seg = {
          left: dynamicIndex,
          right: -1
        };
        dynamicSegments.push(seg);
        valuePartition.push(null);
        iterIndex += LENGTH_ENCODE_BYTE_SIZE;
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(this.childTypes, i, -1);
          let after = findBoolLR(this.childTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before bool number mod 8 === 0");
          }
          after = Math.min(7, after);
          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
            const boolMask = 128 >> boolIndex;
            if ((byteString[iterIndex] & boolMask) > 0) {
              valuePartition.push(new Uint8Array([128]));
            } else {
              valuePartition.push(new Uint8Array([0]));
            }
          }
          i += after;
          iterIndex += 1;
        } else {
          const currLen = tupleType.byteLen();
          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
          iterIndex += currLen;
        }
      }
      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
        throw new Error("input byte not enough to decode");
      }
      i += 1;
    }
    if (dynamicSegments.length > 0) {
      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
      iterIndex = byteString.length;
    }
    if (iterIndex < byteString.length) {
      throw new Error("input byte not fully consumed");
    }
    for (let j = 0; j < dynamicSegments.length; j++) {
      const seg = dynamicSegments[j];
      if (seg.left > seg.right) {
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      }
      if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {
        throw new Error("dynamic segment should be consecutive");
      }
    }
    let segIndex = 0;
    for (let j = 0; j < tupleTypes.length; j++) {
      if (tupleTypes[j].isDynamic()) {
        valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
        segIndex += 1;
      }
    }
    const returnValues = [];
    for (let j = 0; j < tupleTypes.length; j++) {
      const valueTi = tupleTypes[j].decode(valuePartition[j]);
      returnValues.push(valueTi);
    }
    return returnValues;
  }
  static parseTupleContent(str) {
    if (str.length === 0) {
      return [];
    }
    if (str.endsWith(",") || str.startsWith(",")) {
      throw new Error("tuple string should not start with comma");
    }
    if (str.includes(",,")) {
      throw new Error("tuple string should not have consecutive commas");
    }
    const tupleStrings = [];
    let depth = 0;
    let word = "";
    for (const char of str) {
      word += char;
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        depth -= 1;
      } else if (char === ",") {
        if (depth === 0) {
          tupleStrings.push(word.slice(0, word.length - 1));
          word = "";
        }
      }
    }
    if (word.length !== 0) {
      tupleStrings.push(word);
    }
    if (depth !== 0) {
      throw new Error("tuple string has mismatched parentheses");
    }
    return tupleStrings;
  }
};
function compressMultipleBool(valueList) {
  let res = 0;
  if (valueList.length > 8) {
    throw new Error("value list passed in should be no greater than length 8");
  }
  for (let i = 0; i < valueList.length; i++) {
    const boolVal = valueList[i];
    if (typeof boolVal !== "boolean") {
      throw new Error("non-boolean values cannot be compressed into a byte");
    }
    if (boolVal) {
      res |= 1 << 7 - i;
    }
  }
  return res;
}
function findBoolLR(typeList, index, delta) {
  let until = 0;
  while (true) {
    const curr = index + delta * until;
    if (typeList[curr].constructor === ABIBoolType) {
      if (curr !== typeList.length - 1 && delta === 1) {
        until += 1;
      } else if (curr > 0 && delta === -1) {
        until += 1;
      } else {
        break;
      }
    } else {
      until -= 1;
      break;
    }
  }
  return until;
}

// node_modules/algosdk/dist/esm/abi/transaction.js
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
function abiTypeIsTransaction(type) {
  return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
}
function abiCheckTransactionType(type, txn) {
  if (type === ABITransactionType.any) {
    return true;
  }
  return txn.type ? txn.type.toString() === type.toString() : false;
}

// node_modules/algosdk/dist/esm/abi/reference.js
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
function abiTypeIsReference(type) {
  return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
}

// node_modules/algosdk/dist/esm/abi/method.js
function parseMethodSignature(signature) {
  const argsStart = signature.indexOf("(");
  if (argsStart === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  let argsEnd = -1;
  let depth = 0;
  for (let i = argsStart; i < signature.length; i++) {
    const char = signature[i];
    if (char === "(") {
      depth += 1;
    } else if (char === ")") {
      if (depth === 0) {
        break;
      }
      depth -= 1;
      if (depth === 0) {
        argsEnd = i;
        break;
      }
    }
  }
  if (argsEnd === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  return {
    name: signature.slice(0, argsStart),
    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
    returns: signature.slice(argsEnd + 1)
  };
}
var ABIMethod = class _ABIMethod {
  constructor(params) {
    if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
      throw new Error("Invalid ABIMethod parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.args = params.args.map(({ type, name, desc }) => {
      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
        return {
          type,
          name,
          description: desc
        };
      }
      return {
        type: ABIType.from(type),
        name,
        description: desc
      };
    });
    this.returns = {
      type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
      description: params.returns.desc
    };
    this.events = params.events;
    this.readonly = params.readonly;
  }
  getSignature() {
    const args = this.args.map((arg) => arg.type.toString()).join(",");
    const returns = this.returns.type.toString();
    return `${this.name}(${args})${returns}`;
  }
  getSelector() {
    const hash = genericHash(this.getSignature());
    return new Uint8Array(hash.slice(0, 4));
  }
  txnCount() {
    let count = 1;
    for (const arg of this.args) {
      if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
        count += 1;
      }
    }
    return count;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      args: this.args.map(({ type, name, description }) => ({
        type: type.toString(),
        name,
        desc: description
      })),
      returns: {
        type: this.returns.type.toString(),
        desc: this.returns.description
      },
      events: this.events,
      readonly: this.readonly
    };
  }
  static fromSignature(signature) {
    const { name, args, returns } = parseMethodSignature(signature);
    return new _ABIMethod({
      name,
      args: args.map((arg) => ({ type: arg })),
      returns: { type: returns }
    });
  }
};
function getMethodByName(methods, name) {
  if (methods === null || !Array.isArray(methods) || !methods.every((item) => item instanceof ABIMethod))
    throw new Error("Methods list provided is null or not the correct type");
  const filteredMethods = methods.filter((m) => m.name === name);
  if (filteredMethods.length > 1)
    throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map((m) => m.getSignature()).join(",")}`);
  if (filteredMethods.length === 0)
    throw new Error(`found 0 methods with the name ${name}`);
  return filteredMethods[0];
}

// node_modules/algosdk/dist/esm/abi/contract.js
var ABIContract = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
      throw new Error("Invalid ABIContract parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.networks = params.networks ? { ...params.networks } : {};
    this.methods = params.methods.map((method) => new ABIMethod(method));
    this.events = params.events;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      networks: this.networks,
      methods: this.methods.map((method) => method.toJSON()),
      events: this.events
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
};

// node_modules/algosdk/dist/esm/abi/interface.js
var ABIInterface = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
      throw new Error("Invalid ABIInterface parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
};

// node_modules/algosdk/dist/esm/composer.js
var RETURN_PREFIX = new Uint8Array([21, 31, 124, 117]);
var MAX_APP_ARGS = 16;
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
function populateForeignArray(valueToAdd, array, zeroValue) {
  if (zeroValue != null && valueToAdd === zeroValue) {
    return 0;
  }
  const offset = zeroValue == null ? 0 : 1;
  for (let i = 0; i < array.length; i++) {
    if (valueToAdd === array[i]) {
      return i + offset;
    }
  }
  array.push(valueToAdd);
  return array.length - 1 + offset;
}
var AtomicTransactionComposer = class _AtomicTransactionComposer {
  constructor() {
    this.status = AtomicTransactionComposerStatus.BUILDING;
    this.transactions = [];
    this.methodCalls = /* @__PURE__ */ new Map();
    this.signedTxns = [];
    this.txIDs = [];
  }
  /**
   * Get the status of this composer's transaction group.
   */
  getStatus() {
    return this.status;
  }
  /**
   * Get the number of transactions currently in this atomic group.
   */
  count() {
    return this.transactions.length;
  }
  /**
   * Create a new composer with the same underlying transactions. The new composer's status will be
   * BUILDING, so additional transactions may be added to it.
   */
  clone() {
    const theClone = new _AtomicTransactionComposer();
    theClone.transactions = this.transactions.map(({ txn, signer }) => {
      const txnMap = txn.toEncodingData();
      txnMap.delete("grp");
      return {
        // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)
        txn: Transaction.fromEncodingData(txnMap),
        signer
      };
    });
    theClone.methodCalls = new Map(this.methodCalls);
    return theClone;
  }
  /**
   * Add a transaction to this atomic group.
   *
   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is
   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.
   */
  addTransaction(txnAndSigner) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length === _AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${_AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {
      throw new Error("Cannot add a transaction with nonzero group ID");
    }
    this.transactions.push(txnAndSigner);
  }
  /**
   * Add a smart contract method call to this atomic group.
   *
   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction
   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid
   * for the given method.
   */
  addMethodCall({ appID, method, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, appAccounts, appForeignApps, appForeignAssets, boxes, access, note, lease, rekeyTo, rejectVersion, signer }) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length + method.txnCount() > _AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${_AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (BigInt(appID) === BigInt(0)) {
      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
      }
    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
      if (approvalProgram == null || clearProgram == null) {
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      }
      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
      }
    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    }
    if (access && (appAccounts || appForeignApps || appForeignAssets || boxes)) {
      throw new Error("Cannot specify both access and legacy foreign arrays (appAccounts, appForeignApps, appForeignAssets, boxes)");
    }
    if (methodArgs == null) {
      methodArgs = [];
    }
    if (methodArgs.length !== method.args.length) {
      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);
    }
    let basicArgTypes = [];
    let basicArgValues = [];
    const txnArgs = [];
    const refArgTypes = [];
    const refArgValues = [];
    const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
    const boxReferences = !boxes ? [] : boxes;
    for (let i = 0; i < methodArgs.length; i++) {
      let argType = method.args[i].type;
      const argValue = methodArgs[i];
      if (abiTypeIsTransaction(argType)) {
        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
          throw new Error(`Expected ${argType} TransactionWithSigner for argument at index ${i}`);
        }
        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {
          throw new Error("Cannot add a transaction with nonzero group ID");
        }
        txnArgs.push(argValue);
        continue;
      }
      if (isTransactionWithSigner(argValue)) {
        throw new Error(`Expected non-transaction value for argument at index ${i}`);
      }
      if (abiTypeIsReference(argType)) {
        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
        refArgTypes.push(argType);
        refArgValues.push(argValue);
        argType = new ABIUintType(8);
      }
      if (typeof argType === "string") {
        throw new Error(`Unknown ABI type: ${argType}`);
      }
      basicArgTypes.push(argType);
      basicArgValues.push(argValue);
    }
    const resolvedRefIndexes = [];
    const foreignAccounts = appAccounts == null ? [] : appAccounts.map((addr) => addr.toString());
    const foreignApps = appForeignApps == null ? [] : appForeignApps.map(ensureUint64);
    const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.map(ensureUint64);
    for (let i = 0; i < refArgTypes.length; i++) {
      const refType = refArgTypes[i];
      const refValue = refArgValues[i];
      let resolved = 0;
      switch (refType) {
        case ABIReferenceType.account: {
          const addressType = new ABIAddressType();
          const address = addressType.decode(addressType.encode(refValue));
          resolved = populateForeignArray(address, foreignAccounts, sender.toString());
          break;
        }
        case ABIReferenceType.application: {
          const uint64Type = new ABIUintType(64);
          const refAppID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAppID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for application value, got ${refAppID}`);
          }
          resolved = populateForeignArray(refAppID, foreignApps, ensureUint64(appID));
          break;
        }
        case ABIReferenceType.asset: {
          const uint64Type = new ABIUintType(64);
          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAssetID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
          }
          resolved = populateForeignArray(refAssetID, foreignAssets);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${refType}`);
      }
      resolvedRefIndexes.push(resolved);
    }
    for (let i = 0; i < resolvedRefIndexes.length; i++) {
      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);
      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];
    }
    if (basicArgTypes.length > MAX_APP_ARGS - 1) {
      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
      basicArgValues.push(lastArgTupleValues);
    }
    const appArgsEncoded = [method.getSelector()];
    for (let i = 0; i < basicArgTypes.length; i++) {
      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));
    }
    const appCall = {
      txn: makeApplicationCallTxnFromObject({
        sender,
        appIndex: appID,
        appArgs: appArgsEncoded,
        // Only pass legacy foreign arrays if access is not provided
        accounts: access ? void 0 : foreignAccounts,
        foreignApps: access ? void 0 : foreignApps,
        foreignAssets: access ? void 0 : foreignAssets,
        boxes: access ? void 0 : boxReferences,
        access,
        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
        approvalProgram,
        clearProgram,
        numGlobalInts,
        numGlobalByteSlices,
        numLocalInts,
        numLocalByteSlices,
        extraPages,
        rejectVersion,
        lease,
        note,
        rekeyTo,
        suggestedParams
      }),
      signer
    };
    this.transactions.push(...txnArgs, appCall);
    this.methodCalls.set(this.transactions.length - 1, method);
  }
  /**
   * Finalize the transaction group and returned the finalized transactions.
   *
   * The composer's status will be at least BUILT after executing this method.
   */
  buildGroup() {
    if (this.status === AtomicTransactionComposerStatus.BUILDING) {
      if (this.transactions.length === 0) {
        throw new Error("Cannot build a group with 0 transactions");
      }
      if (this.transactions.length > 1) {
        assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
      }
      this.status = AtomicTransactionComposerStatus.BUILT;
    }
    return this.transactions;
  }
  /**
   * Obtain signatures for each transaction in this group. If signatures have already been obtained,
   * this method will return cached versions of the signatures.
   *
   * The composer's status will be at least SIGNED after executing this method.
   *
   * An error will be thrown if signing any of the transactions fails.
   *
   * @returns A promise that resolves to an array of signed transactions.
   */
  async gatherSignatures() {
    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
      return this.signedTxns;
    }
    const txnsWithSigners = this.buildGroup();
    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
    const indexesPerSigner = /* @__PURE__ */ new Map();
    for (let i = 0; i < txnsWithSigners.length; i++) {
      const { signer } = txnsWithSigners[i];
      if (!indexesPerSigner.has(signer)) {
        indexesPerSigner.set(signer, []);
      }
      indexesPerSigner.get(signer).push(i);
    }
    const orderedSigners = Array.from(indexesPerSigner);
    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
    const signedTxns = txnsWithSigners.map(() => null);
    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
      const indexes = orderedSigners[signerIndex][1];
      const sigs = batchedSigs[signerIndex];
      for (let i = 0; i < indexes.length; i++) {
        signedTxns[indexes[i]] = sigs[i];
      }
    }
    function fullyPopulated(a) {
      return a.every((v) => v != null);
    }
    if (!fullyPopulated(signedTxns)) {
      throw new Error(`Missing signatures. Got ${signedTxns}`);
    }
    const txIDs = signedTxns.map((stxn, index) => {
      try {
        return decodeMsgpack(stxn, SignedTransaction).txn.txID();
      } catch (err) {
        throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);
      }
    });
    this.signedTxns = signedTxns;
    this.txIDs = txIDs;
    this.status = AtomicTransactionComposerStatus.SIGNED;
    return signedTxns;
  }
  /**
   * Send the transaction group to the network, but don't wait for it to be committed to a block. An
   * error will be thrown if submission fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method. If submission is
   * successful, this composer's status will update to SUBMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   *
   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.
   */
  async submit(client) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Transaction group cannot be resubmitted");
    }
    const stxns = await this.gatherSignatures();
    await client.sendRawTransaction(stxns).do();
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    return this.txIDs;
  }
  /**
   * Simulates the transaction group in the network.
   *
   * The composer will try to sign any transactions in the group, then simulate
   * the results.
   * Simulating the group will not change the composer's status.
   *
   * @param client - An Algodv2 client
   * @param request - SimulateRequest with options in simulation.
   *   If provided, the request's transaction group will be overrwritten by the composer's group,
   *   only simulation related options will be used.
   *
   * @returns A promise that, upon success, resolves to an object containing an
   *   array of results containing one element for each method call transaction
   *   in this group (ABIResult[]) and the SimulateResponse object.
   */
  async simulate(client, request) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Simulated Transaction group has already been submitted to the network");
    }
    const stxns = await this.gatherSignatures();
    const txnObjects = stxns.map((stxn) => decodeMsgpack(stxn, SignedTransaction));
    const currentRequest = request == null ? new SimulateRequest({ txnGroups: [] }) : request;
    currentRequest.txnGroups = [
      new SimulateRequestTransactionGroup({
        txns: txnObjects
      })
    ];
    const simulateResponse = await client.simulateTransactions(currentRequest).do();
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = this.txIDs[txnIndex];
      const pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;
      const methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      methodResults.push(_AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo));
    }
    return { methodResults, simulateResponse };
  }
  /**
   * Send the transaction group to the network and wait until it's committed to a block. An error
   * will be thrown if submission or execution fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method, since execution is
   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.
   * If the execution is also successful, this composer's status will update to COMMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation
   *
   * @returns A promise that, upon success, resolves to an object containing the confirmed round for
   *   this transaction, the txIDs of the submitted transactions, and an array of results containing
   *   one element for each method call transaction in this group.
   */
  async execute(client, waitRounds) {
    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
      throw new Error("Transaction group has already been executed successfully");
    }
    const txIDs = await this.submit(client);
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));
    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
    this.status = AtomicTransactionComposerStatus.COMMITTED;
    const confirmedRound = confirmedTxnInfo.confirmedRound;
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = txIDs[txnIndex];
      let methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      try {
        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : (
          // eslint-disable-next-line no-await-in-loop
          await client.pendingTransactionInformation(txID).do()
        );
        methodResult = _AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);
      } catch (err) {
        methodResult.decodeError = err;
      }
      methodResults.push(methodResult);
    }
    return {
      confirmedRound,
      txIDs,
      methodResults
    };
  }
  /**
   * Parses a single ABI Method transaction log into a ABI result object.
   *
   * @param method
   * @param methodResult
   * @param pendingInfo
   * @returns An ABIResult object
   */
  static parseMethodResponse(method, methodResult, pendingInfo) {
    const returnedResult = methodResult;
    try {
      returnedResult.txInfo = pendingInfo;
      if (method.returns.type !== "void") {
        const logs = pendingInfo.logs || [];
        if (logs.length === 0) {
          throw new Error(`App call transaction did not log a return value ${stringifyJSON(pendingInfo)}`);
        }
        const lastLog = logs[logs.length - 1];
        if (lastLog.byteLength < 4 || !arrayEqual(lastLog.slice(0, 4), RETURN_PREFIX)) {
          throw new Error(`App call transaction did not log a ABI return value ${stringifyJSON(pendingInfo)}`);
        }
        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
        returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);
      }
    } catch (err) {
      returnedResult.decodeError = err;
    }
    return returnedResult;
  }
};
AtomicTransactionComposer.MAX_GROUP_SIZE = 16;

// node_modules/algosdk/dist/esm/main.js
var SIGN_BYTES_PREFIX = Uint8Array.from([77, 88]);
var MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
function signTransaction(txn, sk) {
  return {
    txID: txn.txID(),
    blob: txn.signTxn(sk)
  };
}
function signBytes(bytes, sk) {
  const toBeSigned = concatArrays(SIGN_BYTES_PREFIX, bytes);
  const sig = sign(toBeSigned, sk);
  return sig;
}
function verifyBytes(bytes, signature, addr) {
  const toBeVerified = concatArrays(SIGN_BYTES_PREFIX, bytes);
  const addrObj = typeof addr === "string" ? Address.fromString(addr) : addr;
  return verify(toBeVerified, signature, addrObj.publicKey);
}
var ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
var ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);

// node_modules/algosdk/dist/esm/index.js
var esm_default = main_exports;

export {
  intDecoding_default,
  parseJSON,
  stringifyJSON,
  encodeUint64,
  decodeUint64,
  base64ToBytes,
  bytesToBase64,
  bytesToString,
  coerceToBytes,
  bytesToHex,
  hexToBytes,
  ALGORAND_ZERO_ADDRESS_STRING,
  Address,
  decodeAddress,
  isValidAddress,
  encodeAddress,
  getApplicationAddress,
  INVALID_MICROALGOS_ERROR_MSG,
  microalgosToAlgos,
  algosToMicroalgos,
  msgpackRawEncode,
  encodeObj,
  msgpackRawDecode,
  decodeObj,
  msgpackRawDecodeAsMap,
  decodeMsgpack,
  encodeMsgpack,
  decodeJSON,
  encodeJSON,
  TransactionType,
  isTransactionType,
  OnApplicationComplete,
  isOnApplicationComplete,
  HashFactory,
  MerkleArrayProof,
  MerkleSignatureVerifier,
  Participant,
  FalconVerifier,
  FalconSignatureStruct,
  SigslotCommit,
  Reveal,
  StateProof,
  StateProofMessage,
  Transaction,
  encodeUnsignedTransaction,
  decodeUnsignedTransaction,
  verifyMultisig,
  multisigAddress,
  ENCODED_SUBSIG_SCHEMA,
  encodedSubsigFromEncodingData,
  encodedSubsigToEncodingData,
  ENCODED_MULTISIG_SCHEMA,
  encodedMultiSigFromEncodingData,
  encodedMultiSigToEncodingData,
  LogicSig,
  LogicSigAccount,
  logicSigFromByte,
  tealSign,
  verifyTealSign,
  tealSignFromProgram,
  SignedTransaction,
  decodeSignedTransaction,
  encodeUnsignedSimulateTransaction,
  StateProofTrackingData,
  TxnCommitments,
  RewardState,
  UpgradeState,
  UpgradeVote,
  ParticipationUpdates,
  BlockHeader,
  ValueDelta,
  EvalDelta,
  ApplyData,
  SignedTxnWithAD,
  SignedTxnInBlock,
  Block,
  UntypedValue,
  TealValue,
  StateSchema,
  AppParams,
  AppLocalState,
  AppLocalStateDelta,
  AppParamsDelta,
  AppResourceRecord,
  AssetHolding,
  AssetHoldingDelta,
  AssetParams,
  AssetParamsDelta,
  AssetResourceRecord,
  VotingData,
  AccountBaseData,
  AccountData,
  BalanceRecord,
  AccountDeltas,
  KvValueDelta,
  IncludedTransactions,
  ModifiedCreatable,
  AlgoCount,
  AccountTotals,
  LedgerStateDelta,
  types_exports,
  AlgodClient,
  KmdClient,
  types_exports2,
  IndexerClient,
  waitForConfirmation,
  bigIntToBytes,
  bytesToBigInt,
  generateAccount,
  mnemonicFromSeed,
  seedFromMnemonic,
  mnemonicToSecretKey,
  secretKeyToMnemonic,
  mnemonicToMasterDerivationKey,
  masterDerivationKeyToMnemonic,
  computeGroupID,
  assignGroupID,
  signLogicSigTransactionObject,
  signLogicSigTransaction,
  createMultisigTransaction,
  mergeMultisigTransactions,
  signMultisigTransaction,
  appendSignMultisigTransaction,
  appendSignRawMultisigSignature,
  ProgramSourceMap,
  createDryrun,
  dryrunTxnResultAppTrace,
  dryrunTxnResultLogicSigTrace,
  makePaymentTxnWithSuggestedParamsFromObject,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeBaseAssetConfigTxn,
  makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeApplicationCallTxnFromObject,
  makeApplicationCreateTxnFromObject,
  makeApplicationUpdateTxnFromObject,
  makeApplicationDeleteTxnFromObject,
  makeApplicationOptInTxnFromObject,
  makeApplicationCloseOutTxnFromObject,
  makeApplicationClearStateTxnFromObject,
  makeApplicationNoOpTxnFromObject,
  makeBasicAccountTransactionSigner,
  makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner,
  makeEmptyTransactionSigner,
  isTransactionWithSigner,
  MAX_LEN,
  ADDR_BYTE_SIZE,
  SINGLE_BYTE_SIZE,
  SINGLE_BOOL_SIZE,
  LENGTH_ENCODE_BYTE_SIZE,
  ABIType,
  ABIUintType,
  ABIUfixedType,
  ABIAddressType,
  ABIBoolType,
  ABIByteType,
  ABIStringType,
  ABIArrayStaticType,
  ABIArrayDynamicType,
  ABITupleType,
  ABITransactionType,
  abiTypeIsTransaction,
  abiCheckTransactionType,
  ABIReferenceType,
  abiTypeIsReference,
  ABIMethod,
  getMethodByName,
  ABIContract,
  ABIInterface,
  AtomicTransactionComposerStatus,
  AtomicTransactionComposer,
  MULTISIG_BAD_SENDER_ERROR_MSG,
  signTransaction,
  signBytes,
  verifyBytes,
  ERROR_MULTISIG_BAD_SENDER,
  ERROR_INVALID_MICROALGOS,
  esm_default
};
/*! Bundled license information:

js-sha512/src/sha512.js:
  (*
   * [js-sha512]{@link https://github.com/emn178/js-sha512}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2018
   * @license MIT
   *)

hi-base32/src/base32.js:
  (*
   * [hi-base32]{@link https://github.com/emn178/hi-base32}
   *
   * @version 0.5.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-Q4KW3TCG.js.map
