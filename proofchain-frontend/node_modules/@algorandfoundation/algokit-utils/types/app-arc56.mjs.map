{"version":3,"file":"app-arc56.mjs","sources":["../../src/types/app-arc56.ts"],"sourcesContent":["import algosdk from 'algosdk'\nimport { convertAbiByteArrays, convertABIDecodedBigIntToNumber } from '../util'\nimport { ABIReturn } from './app'\nimport { Expand } from './expand'\n\n/** Type to describe an argument within an `Arc56Method`. */\nexport type Arc56MethodArg = Expand<\n  Omit<Method['args'][number], 'type'> & {\n    type: algosdk.ABIArgumentType\n  }\n>\n\n/** Type to describe a return type within an `Arc56Method`. */\nexport type Arc56MethodReturnType = Expand<\n  Omit<Method['returns'], 'type'> & {\n    type: algosdk.ABIReturnType\n  }\n>\n\n/**\n * Wrapper around `algosdk.ABIMethod` that represents an ARC-56 ABI method.\n */\nexport class Arc56Method extends algosdk.ABIMethod {\n  override readonly args: Array<Arc56MethodArg>\n  override readonly returns: Arc56MethodReturnType\n\n  constructor(public method: Method) {\n    super(method)\n    this.args = method.args.map((arg) => ({\n      ...arg,\n      type: algosdk.abiTypeIsTransaction(arg.type) || algosdk.abiTypeIsReference(arg.type) ? arg.type : algosdk.ABIType.from(arg.type),\n    }))\n    this.returns = {\n      ...this.method.returns,\n      type: this.method.returns.type === 'void' ? 'void' : algosdk.ABIType.from(this.method.returns.type),\n    }\n  }\n\n  override toJSON(): Method {\n    return this.method\n  }\n}\n\n/**\n * Returns the `ABITupleType` for the given ARC-56 struct definition\n * @param struct The ARC-56 struct definition\n * @returns The `ABITupleType`\n */\nexport function getABITupleTypeFromABIStructDefinition(\n  struct: StructField[],\n  structs: Record<string, StructField[]>,\n): algosdk.ABITupleType {\n  return new algosdk.ABITupleType(\n    struct.map((v) =>\n      typeof v.type === 'string'\n        ? structs[v.type]\n          ? getABITupleTypeFromABIStructDefinition(structs[v.type], structs)\n          : algosdk.ABIType.from(v.type)\n        : getABITupleTypeFromABIStructDefinition(v.type, structs),\n    ),\n  )\n}\n\n/**\n * Converts a decoded ABI tuple as a struct.\n * @param decodedABITuple The decoded ABI tuple value\n * @param structFields The struct fields from an ARC-56 app spec\n * @returns The struct as a Record<string, any>\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getABIStructFromABITuple<TReturn extends ABIStruct = Record<string, any>>(\n  decodedABITuple: algosdk.ABIValue[],\n  structFields: StructField[],\n  structs: Record<string, StructField[]>,\n): TReturn {\n  return Object.fromEntries(\n    structFields.map(({ name: key, type }, i) => {\n      let abiType: algosdk.ABIType\n\n      if (typeof type === 'string') {\n        if (type in structs) {\n          abiType = getABITupleTypeFromABIStructDefinition(structs[type], structs)\n        } else {\n          abiType = algosdk.ABIType.from(type)\n        }\n      } else {\n        abiType = getABITupleTypeFromABIStructDefinition(type, structs)\n      }\n\n      const abiValue = convertAbiByteArrays(decodedABITuple[i], abiType)\n      const convertedValue = convertABIDecodedBigIntToNumber(abiValue, abiType)\n      return [\n        key,\n        (typeof type === 'string' && !structs[type]) || !Array.isArray(convertedValue)\n          ? convertedValue\n          : getABIStructFromABITuple(convertedValue, typeof type === 'string' ? structs[type] : type, structs),\n      ]\n    }),\n  ) as TReturn\n}\n\n/**\n * Converts an ARC-56 struct as an ABI tuple.\n * @param struct The struct to convert\n * @param structFields The struct fields from an ARC-56 app spec\n * @returns The struct as a decoded ABI tuple\n */\nexport function getABITupleFromABIStruct(\n  struct: ABIStruct,\n  structFields: StructField[],\n  structs: Record<string, StructField[]>,\n): algosdk.ABIValue[] {\n  return structFields.map(({ name: key, type }) => {\n    const value = struct[key]\n    return typeof type === 'string' && !structs[type]\n      ? (value as algosdk.ABIValue)\n      : getABITupleFromABIStruct(value as ABIStruct, typeof type === 'string' ? structs[type] : type, structs)\n  })\n}\n\n/** Decoded ARC-56 struct as a struct rather than a tuple. */\nexport type ABIStruct = {\n  [key: string]: ABIStruct | algosdk.ABIValue\n}\n\n/**\n * Returns the decoded ABI value (or struct for a struct type)\n * for the given raw Algorand value given an ARC-56 type and defined ARC-56 structs.\n * @param value The raw Algorand value (bytes or uint64)\n * @param type The ARC-56 type - either an ABI Type string or a struct name\n * @param structs The defined ARC-56 structs\n * @returns The decoded ABI value or struct\n */\nexport function getABIDecodedValue(\n  value: Uint8Array | number | bigint,\n  type: string,\n  structs: Record<string, StructField[]>,\n): algosdk.ABIValue | ABIStruct {\n  if (type === 'AVMBytes' || typeof value !== 'object') return value\n  if (type === 'AVMString') return Buffer.from(value).toString('utf-8')\n  if (type === 'AVMUint64') return algosdk.ABIType.from('uint64').decode(value)\n  if (structs[type]) {\n    const tupleValue = getABITupleTypeFromABIStructDefinition(structs[type], structs).decode(value)\n    return getABIStructFromABITuple(tupleValue, structs[type], structs)\n  }\n\n  const abiType = algosdk.ABIType.from(type)\n  const decodedValue = convertAbiByteArrays(abiType.decode(value), abiType)\n  return convertABIDecodedBigIntToNumber(decodedValue, abiType)\n}\n\n/**\n * Returns the ABI-encoded value for the given value.\n * @param value The value to encode either already in encoded binary form (`Uint8Array`), a decoded ABI value or an ARC-56 struct\n * @param type The ARC-56 type - either an ABI Type string or a struct name\n * @param structs The defined ARC-56 structs\n * @returns The binary ABI-encoded value\n */\nexport function getABIEncodedValue(\n  value: Uint8Array | algosdk.ABIValue | ABIStruct,\n  type: string,\n  structs: Record<string, StructField[]>,\n): Uint8Array {\n  if (typeof value === 'object' && value instanceof Uint8Array) return value\n  if (type === 'AVMUint64') return algosdk.ABIType.from('uint64').encode(value as bigint | number)\n  if (type === 'AVMBytes' || type === 'AVMString') {\n    if (typeof value === 'string') return Buffer.from(value, 'utf-8')\n    if (typeof value !== 'object' || !(value instanceof Uint8Array)) throw new Error(`Expected bytes value for ${type}, but got ${value}`)\n    return value\n  }\n  if (structs[type]) {\n    const tupleType = getABITupleTypeFromABIStructDefinition(structs[type], structs)\n    if (Array.isArray(value)) {\n      tupleType.encode(value as algosdk.ABIValue[])\n    } else {\n      return tupleType.encode(getABITupleFromABIStruct(value as ABIStruct, structs[type], structs))\n    }\n  }\n  return algosdk.ABIType.from(type).encode(value as algosdk.ABIValue)\n}\n\n/**\n * Returns the ARC-56 ABI method object for a given method name or signature and ARC-56 app spec.\n * @param methodNameOrSignature The method name or method signature to call if an ABI call is being emitted.\n * e.g. `my_method` or `my_method(unit64,string)bytes`\n * @param appSpec The app spec for the app\n * @returns The `Arc56Method`\n */\nexport function getArc56Method(methodNameOrSignature: string, appSpec: Arc56Contract): Arc56Method {\n  let method: Method\n  if (!methodNameOrSignature.includes('(')) {\n    const methods = appSpec.methods.filter((m) => m.name === methodNameOrSignature)\n    if (methods.length === 0) throw new Error(`Unable to find method ${methodNameOrSignature} in ${appSpec.name} app.`)\n    if (methods.length > 1) {\n      throw new Error(\n        `Received a call to method ${methodNameOrSignature} in contract ${\n          appSpec.name\n        }, but this resolved to multiple methods; please pass in an ABI signature instead: ${appSpec.methods\n          .map((m) => new algosdk.ABIMethod(m).getSignature())\n          .join(', ')}`,\n      )\n    }\n    method = methods[0]\n  } else {\n    const m = appSpec.methods.find((m) => new algosdk.ABIMethod(m).getSignature() === methodNameOrSignature)\n    if (!m) throw new Error(`Unable to find method ${methodNameOrSignature} in ${appSpec.name} app.`)\n    method = m\n  }\n  return new Arc56Method(method)\n}\n\n/**\n * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n *\n * @param returnValue The smart contract response\n * @param method The method that was called\n * @param structs The struct fields from the app spec\n * @returns The smart contract response with an updated return value\n */\nexport function getArc56ReturnValue<TReturn extends Uint8Array | algosdk.ABIValue | ABIStruct | undefined>(\n  returnValue: ABIReturn | undefined,\n  method: Method | Arc56Method,\n  structs: Record<string, StructField[]>,\n): TReturn {\n  const m = 'method' in method ? method.method : method\n  const type = m.returns.struct ?? m.returns.type\n  if (returnValue?.decodeError) {\n    throw returnValue.decodeError\n  }\n  if (type === undefined || type === 'void' || returnValue?.returnValue === undefined) return undefined as TReturn\n\n  if (type === 'AVMBytes') return returnValue.rawReturnValue as TReturn\n  if (type === 'AVMString') return Buffer.from(returnValue.rawReturnValue).toString('utf-8') as TReturn\n  if (type === 'AVMUint64') return algosdk.ABIType.from('uint64').decode(returnValue.rawReturnValue) as TReturn\n\n  if (structs[type]) {\n    return getABIStructFromABITuple(returnValue.returnValue as algosdk.ABIValue[], structs[type], structs) as TReturn\n  }\n\n  return convertAbiByteArrays(returnValue.returnValue, algosdk.ABIType.from(type)) as TReturn\n}\n\n/****************/\n/** ARC-56 spec */\n/****************/\n\n/** Describes the entire contract. This interface is an extension of the interface described in ARC-4 */\nexport interface Arc56Contract {\n  /** The ARCs used and/or supported by this contract. All contracts implicitly support ARC4 and ARC56 */\n  arcs: number[]\n  /** A user-friendly name for the contract */\n  name: string\n  /** Optional, user-friendly description for the interface */\n  desc?: string\n  /**\n   * Optional object listing the contract instances across different networks.\n   * The key is the base64 genesis hash of the network, and the value contains\n   * information about the deployed contract in the network indicated by the\n   * key. A key containing the human-readable name of the network MAY be\n   * included, but the corresponding genesis hash key MUST also be defined\n   */\n  networks?: {\n    [network: string]: {\n      /** The app ID of the deployed contract in this network */\n      appID: number\n    }\n  }\n  /** Named structs used by the application. Each struct field appears in the same order as ABI encoding. */\n  structs: { [structName: StructName]: StructField[] }\n  /** All of the methods that the contract implements */\n  methods: Method[]\n  state: {\n    /** Defines the values that should be used for GlobalNumUint, GlobalNumByteSlice, LocalNumUint, and LocalNumByteSlice when creating the application  */\n    schema: {\n      global: {\n        ints: number\n        bytes: number\n      }\n      local: {\n        ints: number\n        bytes: number\n      }\n    }\n    /** Mapping of human-readable names to StorageKey objects */\n    keys: {\n      global: { [name: string]: StorageKey }\n      local: { [name: string]: StorageKey }\n      box: { [name: string]: StorageKey }\n    }\n    /** Mapping of human-readable names to StorageMap objects */\n    maps: {\n      global: { [name: string]: StorageMap }\n      local: { [name: string]: StorageMap }\n      box: { [name: string]: StorageMap }\n    }\n  }\n  /** Supported bare actions for the contract. An action is a combination of call/create and an OnComplete */\n  bareActions: {\n    /** OnCompletes this method allows when appID === 0 */\n    create: ('NoOp' | 'OptIn' | 'DeleteApplication')[]\n    /** OnCompletes this method allows when appID !== 0 */\n    call: ('NoOp' | 'OptIn' | 'CloseOut' | 'ClearState' | 'UpdateApplication' | 'DeleteApplication')[]\n  }\n  /** Information about the TEAL programs */\n  sourceInfo?: {\n    /** Approval program information */\n    approval: ProgramSourceInfo\n    /** Clear program information */\n    clear: ProgramSourceInfo\n  }\n  /** The pre-compiled TEAL that may contain template variables. MUST be omitted if included as part of ARC23 */\n  source?: {\n    /** The approval program */\n    approval: string\n    /** The clear program */\n    clear: string\n  }\n  /** The compiled bytecode for the application. MUST be omitted if included as part of ARC23 */\n  byteCode?: {\n    /** The approval program */\n    approval: string\n    /** The clear program */\n    clear: string\n  }\n  /** Information used to get the given byteCode and/or PC values in sourceInfo. MUST be given if byteCode or PC values are present */\n  compilerInfo?: {\n    /** The name of the compiler */\n    compiler: 'algod' | 'puya'\n    /** Compiler version information */\n    compilerVersion: {\n      major: number\n      minor: number\n      patch: number\n      commitHash?: string\n    }\n  }\n  /** ARC-28 events that MAY be emitted by this contract */\n  events?: Array<Event>\n  /** A mapping of template variable names as they appear in the TEAL (not including TMPL_ prefix) to their respective types and values (if applicable) */\n  templateVariables?: {\n    [name: string]: {\n      /** The type of the template variable */\n      type: ABIType | AVMType | StructName\n      /** If given, the base64 encoded value used for the given app/program */\n      value?: string\n    }\n  }\n  /** The scratch variables used during runtime */\n  scratchVariables?: {\n    [name: string]: {\n      slot: number\n      type: ABIType | AVMType | StructName\n    }\n  }\n}\n\n/** Describes a method in the contract. This interface is an extension of the interface described in ARC-4 */\nexport interface Method {\n  /** The name of the method */\n  name: string\n  /** Optional, user-friendly description for the method */\n  desc?: string\n  /** The arguments of the method, in order */\n  args: Array<{\n    /** The type of the argument. The `struct` field should also be checked to determine if this arg is a struct. */\n    type: ABIType\n    /** If the type is a struct, the name of the struct */\n    struct?: StructName\n    /** Optional, user-friendly name for the argument */\n    name?: string\n    /** Optional, user-friendly description for the argument */\n    desc?: string\n    /** The default value that clients should use. */\n    defaultValue?: {\n      /** Base64 encoded bytes, base64 ARC4 encoded uint64, or UTF-8 method selector */\n      data: string\n      /** How the data is encoded. This is the encoding for the data provided here, not the arg type */\n      type?: ABIType | AVMType\n      /** Where the default value is coming from\n       * - box: The data key signifies the box key to read the value from\n       * - global: The data key signifies the global state key to read the value from\n       * - local: The data key signifies the local state key to read the value from (for the sender)\n       * - literal: the value is a literal and should be passed directly as the argument\n       * - method: The utf8 signature of the method in this contract to call to get the default value. If the method has arguments, they all must have default values. The method **MUST** be readonly so simulate can be used to get the default value\n       */\n      source: 'box' | 'global' | 'local' | 'literal' | 'method'\n    }\n  }>\n  /** Information about the method's return value */\n  returns: {\n    /** The type of the return value, or \"void\" to indicate no return value. The `struct` field should also be checked to determine if this return value is a struct. */\n    type: ABIType\n    /** If the type is a struct, the name of the struct */\n    struct?: StructName\n    /** Optional, user-friendly description for the return value */\n    desc?: string\n  }\n  /** an action is a combination of call/create and an OnComplete */\n  actions: {\n    /** OnCompletes this method allows when appID === 0 */\n    create: ('NoOp' | 'OptIn' | 'DeleteApplication')[]\n    /** OnCompletes this method allows when appID !== 0 */\n    call: ('NoOp' | 'OptIn' | 'CloseOut' | 'ClearState' | 'UpdateApplication' | 'DeleteApplication')[]\n  }\n  /** If this method does not write anything to the ledger (ARC-22) */\n  readonly?: boolean\n  /** ARC-28 events that MAY be emitted by this method */\n  events?: Array<Event>\n  /** Information that clients can use when calling the method */\n  recommendations?: {\n    /** The number of inner transactions the caller should cover the fees for */\n    innerTransactionCount?: number\n    /** Recommended box references to include */\n    boxes?: {\n      /** The app ID for the box */\n      app?: number\n      /** The base64 encoded box key */\n      key: string\n      /** The number of bytes being read from the box */\n      readBytes: number\n      /** The number of bytes being written to the box */\n      writeBytes: number\n    }\n    /** Recommended foreign accounts */\n    accounts?: string[]\n    /** Recommended foreign apps */\n    apps?: number[]\n    /** Recommended foreign assets */\n    assets?: number[]\n  }\n}\n\n/** ARC-28 event */\nexport interface Event {\n  /** The name of the event */\n  name: string\n  /** Optional, user-friendly description for the event */\n  desc?: string\n  /** The arguments of the event, in order */\n  args: Array<{\n    /** The type of the argument. The `struct` field should also be checked to determine if this arg is a struct. */\n    type: ABIType\n    /** Optional, user-friendly name for the argument */\n    name?: string\n    /** Optional, user-friendly description for the argument */\n    desc?: string\n    /** If the type is a struct, the name of the struct */\n    struct?: StructName\n  }>\n}\n\n/** An ABI-encoded type */\nexport type ABIType = string\n\n/** The name of a defined struct */\nexport type StructName = string\n\n/** Raw byteslice without the length prefixed that is specified in ARC-4 */\nexport type AVMBytes = 'AVMBytes'\n\n/** A utf-8 string without the length prefix that is specified in ARC-4 */\nexport type AVMString = 'AVMString'\n\n/** A 64-bit unsigned integer */\nexport type AVMUint64 = 'AVMUint64'\n\n/** A native AVM type */\nexport type AVMType = AVMBytes | AVMString | AVMUint64\n\n/** Information about a single field in a struct */\nexport interface StructField {\n  /** The name of the struct field */\n  name: string\n  /** The type of the struct field's value */\n  type: ABIType | StructName | StructField[]\n}\n\n/** Describes a single key in app storage */\nexport interface StorageKey {\n  /** Description of what this storage key holds */\n  desc?: string\n  /** The type of the key */\n  keyType: ABIType | AVMType | StructName\n\n  /** The type of the value */\n  valueType: ABIType | AVMType | StructName\n  /** The bytes of the key encoded as base64 */\n  key: string\n}\n\n/** Describes a mapping of key-value pairs in storage */\nexport interface StorageMap {\n  /** Description of what the key-value pairs in this mapping hold */\n  desc?: string\n  /** The type of the keys in the map */\n  keyType: ABIType | AVMType | StructName\n  /** The type of the values in the map */\n  valueType: ABIType | AVMType | StructName\n  /** The base64-encoded prefix of the map keys*/\n  prefix?: string\n}\n\ninterface SourceInfo {\n  /** The program counter value(s). Could be offset if pcOffsetMethod is not \"none\" */\n  pc: Array<number>\n  /** A human-readable string that describes the error when the program fails at the given PC */\n  errorMessage?: string\n  /** The TEAL line number that corresponds to the given PC. RECOMMENDED to be used for development purposes, but not required for clients */\n  teal?: number\n  /** The original source file and line number that corresponds to the given PC. RECOMMENDED to be used for development purposes, but not required for clients */\n  source?: string\n}\n\nexport interface ProgramSourceInfo {\n  /** The source information for the program */\n  sourceInfo: SourceInfo[]\n  /** How the program counter offset is calculated\n   * - none: The pc values in sourceInfo are not offset\n   * - cblocks: The pc values in sourceInfo are offset by the PC of the first op following the last cblock at the top of the program\n   */\n  pcOffsetMethod: 'none' | 'cblocks'\n}\n"],"names":[],"mappings":"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"}